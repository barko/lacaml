<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vec (lacaml.Lacaml.Z.Vec)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">lacaml</a> &#x00BB; <a href="../../index.html">Lacaml</a> &#x00BB; <a href="../index.html">Z</a> &#x00BB; Vec</nav><h1>Module <code>Z.Vec</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="../index.html#type-vec">vec</a></code></dt></dl><section><header><h4 id="vector-operations"><a href="#vector-operations" class="anchor"></a>Vector operations</h4></header></section><section><header><h4 id="creation-of-vectors"><a href="#creation-of-vectors" class="anchor"></a>Creation of vectors</h4></header><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val </span>random : ?&#8288;rnd_state:Stdlib.Random.State.t <span>&#45;&gt;</span> ?&#8288;re_from:float <span>&#45;&gt;</span> ?&#8288;re_range:float <span>&#45;&gt;</span> ?&#8288;im_from:float <span>&#45;&gt;</span> ?&#8288;im_range:float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>random ?rnd_state ?re_from ?re_range ?im_from ?im_range n</code></p><dl><dt>returns</dt><dd><p>a vector of size <code>n</code> initialized with random elements sampled uniformly from <code>re_range</code> and <code>im_range</code> starting at <code>re_from</code> and <code>im_from</code> for real and imaginary numbers respectively. A random state <code>rnd_state</code> can be passed.</p></dd></dl><dl><dt>parameter rnd_state</dt><dd><p>default = Random.get_state ()</p></dd></dl><dl><dt>parameter re_from</dt><dd><p>default = -1.0</p></dd></dl><dl><dt>parameter re_range</dt><dd><p>default = 2.0</p></dd></dl><dl><dt>parameter im_from</dt><dd><p>default = -1.0</p></dd></dl><dl><dt>parameter im_range</dt><dd><p>default = 2.0</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span class="keyword">type </span>unop</code><code><span class="keyword"> = </span>?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec type" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span class="keyword">type </span>binop</code><code><span class="keyword"> = </span>?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsz:int <span>&#45;&gt;</span> ?&#8288;incz:int <span>&#45;&gt;</span> ?&#8288;z:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt></dl></section><section><header><h4 id="creation/conversion-of-vectors-and-dimension-accessor"><a href="#creation/conversion-of-vectors-and-dimension-accessor" class="anchor"></a>Creation/conversion of vectors and dimension accessor</h4></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : int <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-make0"><a href="#val-make0" class="anchor"></a><code><span class="keyword">val </span>make0 : int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> Stdlib.Complex.t) <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val </span>of_array : Stdlib.Complex.t array <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t array</code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : Stdlib.Complex.t list <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t list</code></dt><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : <a href="../index.html#type-vec">vec</a> list <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>empty</code>, the empty vector.</p></dd></dl><dl><dt class="spec value" id="val-linspace"><a href="#val-linspace" class="anchor"></a><code><span class="keyword">val </span>linspace : ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-logspace"><a href="#val-logspace" class="anchor"></a><code><span class="keyword">val </span>logspace : ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;base:float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-dim"><a href="#val-dim" class="anchor"></a><code><span class="keyword">val </span>dim : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><code><span class="keyword">val </span>has_zero_dim : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_zero_dim vec</code> checks whether vector <code>vec</code> has a dimension of size <code>zero</code>. In this case it cannot contain data.</p></dd></dl></section><section><header><h4 id="iterators-over-vectors"><a href="#iterators-over-vectors" class="anchor"></a>Iterators over vectors</h4></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (Stdlib.Complex.t <span>&#45;&gt;</span> Stdlib.Complex.t) <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (Stdlib.Complex.t <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter ?n ?ofsx ?incx f x</code> applies function <code>f</code> in turn to all elements of vector <code>x</code>.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : (int <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri ?n ?ofsx ?incx f x</code> same as <code>iter</code> but additionally passes the index of the element as first argument and the element itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f a ?n ?ofsx ?incx x</code> is <code>f (... (f (f a x.{ofsx}) x.{ofsx + incx}) ...) x.{ofsx + (n-1)*incx}</code> if <code>incx &gt; 0</code> and the same in the reverse order of appearance of the <code>x</code> values if <code>incx &lt; 0</code>.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h4 id="operations-on-one-vector"><a href="#operations-on-one-vector" class="anchor"></a>Operations on one vector</h4></header><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val </span>rev : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>rev x</code> reverses vector <code>x</code> (non-destructive).</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val </span>max : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>max ?n ?ofsx ?incx x</code> computes the greater of the <code>n</code> elements in vector <code>x</code> (2-norm), separated by <code>incx</code> incremental steps. NaNs are ignored. If only NaNs are encountered, the negative <code>infinity</code> value will be returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val </span>min : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>min ?n ?ofsx ?incx x</code> computes the smaller of the <code>n</code> elements in vector <code>x</code> (2-norm), separated by <code>incx</code> incremental steps. NaNs are ignored. If only NaNs are encountered, the <code>infinity</code> value will be returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val </span>sort : ?&#8288;cmp:(Stdlib.Complex.t <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> ?&#8288;decr:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsp:int <span>&#45;&gt;</span> ?&#8288;incp:int <span>&#45;&gt;</span> ?&#8288;p:<a href="../../Common/index.html#type-int_vec">Common.int_vec</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sort ?cmp ?n ?ofsx ?incx x</code> sorts the array <code>x</code> in increasing order according to the comparison function <code>cmp</code>.</p><dl><dt>parameter cmp</dt><dd><p>a function such that <code>cmp a b &lt; 0</code> if <code>a</code> is less than <code>b</code>, <code>cmp a b = 0</code> if <code>a</code> equal <code>b</code> and <code>cmp a b &gt; 0</code> if <code>a</code> is greater than <code>b</code> for the desired order. Default: the usual order on floating point values or the lexicographic order on complex ones (a special routine makes it fast). Whatever the order you choose, NaNs (in any component for complex numbers) are considered larger than any other value (so they will be last, in no specified order, in the sorted vector). Therefore, NaN are never passed to <code>cmp</code>.</p></dd></dl><dl><dt>parameter p</dt><dd><p>if you pass a vector of size <code>ofsp+(n - 1)(abs incp)</code>, the vector <code>x</code> will be unchanged and the permutation to sort it will be stored in <code>p</code>. Thus <code>x.{p.{ofsp + (i-1) * incp}}</code> will give the elements of <code>x</code> in increasing order. Default: no vector is provided.</p></dd></dl><dl><dt>parameter decr</dt><dd><p>sort in decreasing order (stays fast for the default <code>cmp</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater <code>n</code> s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsp</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incp</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val </span>fill : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill ?n ?ofsx ?incx x a</code> fills vector <code>x</code> with value <code>a</code> in the designated range.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val </span>sum : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>sum ?n ?ofsx ?incx x</code> computes the sum of the <code>n</code> elements in vector <code>x</code>, separated by <code>incx</code> incremental steps.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span class="keyword">val </span>prod : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>prod ?n ?ofsx ?incx x</code> computes the product of the <code>n</code> elements in vector <code>x</code>, separated by <code>incx</code> incremental steps.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_const"><a href="#val-add_const" class="anchor"></a><code><span class="keyword">val </span>add_const : Stdlib.Complex.t <span>&#45;&gt;</span> <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>add_const c ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> adds constant <code>c</code> to the <code>n</code> elements of vector <code>x</code> and stores the result in <code>y</code>, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqr_nrm2"><a href="#val-sqr_nrm2" class="anchor"></a><code><span class="keyword">val </span>sqr_nrm2 : ?&#8288;stable:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sqr_nrm2 ?stable ?n ?c ?ofsx ?incx x</code> computes the square of the 2-norm (Euclidean norm) of vector <code>x</code> separated by <code>incx</code> incremental steps. If <code>stable</code> is true, this is equivalent to squaring the result of calling the BLAS-function <code>nrm2</code>, which avoids over- and underflow if possible. If <code>stable</code> is false (default), <code>dot</code> will be called instead for greatly improved performance.</p><dl><dt>parameter stable</dt><dd><p>default = <code>false</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr"><a href="#val-ssqr" class="anchor"></a><code><span class="keyword">val </span>ssqr : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;c:Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>ssqr ?n ?c ?ofsx ?incx x</code> computes the sum of squared differences of the <code>n</code> elements in vector <code>x</code> from constant <code>c</code>, separated by <code>incx</code> incremental steps. Please do not confuse with <a href="index.html#val-sqr_nrm2"><code>sqr_nrm2</code></a>! The current function behaves differently with complex numbers when zero is passed in for <code>c</code>. It computes the square for each entry then, whereas <a href="index.html#val-sqr_nrm2"><code>sqr_nrm2</code></a> uses the conjugate transpose in the product. The latter will therefore always return a real number.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter c</dt><dd><p>default = zero</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val </span>neg : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>neg ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> negates <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reci"><a href="#val-reci" class="anchor"></a><code><span class="keyword">val </span>reci : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>reci ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the reciprocal value of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h4 id="operations-on-two-vectors"><a href="#operations-on-two-vectors" class="anchor"></a>Operations on two vectors</h4></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val </span>add : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>add ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> adds <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>sub ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> subtracts <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val </span>mul : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>mul ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val </span>div : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>div ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> divides <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-zpxy"><a href="#val-zpxy" class="anchor"></a><code><span class="keyword">val </span>zpxy : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsz:int <span>&#45;&gt;</span> ?&#8288;incz:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>zpxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively, and adds the result to and stores it in the specified range in <code>z</code>. This function is useful for convolutions.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-zmxy"><a href="#val-zmxy" class="anchor"></a><code><span class="keyword">val </span>zmxy : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsz:int <span>&#45;&gt;</span> ?&#8288;incz:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>zmxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively, and substracts the result from and stores it in the specified range in <code>z</code>. This function is useful for convolutions.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><code><span class="keyword">val </span>ssqr_diff : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>ssqr_diff ?n ?ofsx ?incx x ?ofsy ?incy y</code> returns the sum of squared differences of <code>n</code> elements of vectors <code>x</code> and <code>y</code>, using <code>incx</code> and <code>incy</code> as incremental steps respectively.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl></section></div></body></html>