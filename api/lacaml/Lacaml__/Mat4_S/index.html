<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mat4_S (lacaml.Lacaml__.Mat4_S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">lacaml</a> &#x00BB; <a href="../index.html">Lacaml__</a> &#x00BB; Mat4_S</nav><h1>Module <code>Lacaml__.Mat4_S</code></h1><nav class="toc"><ul><li><a href="#creation-of-matrices-and-accessors">Creation of matrices and accessors</a></li><li><a href="#matrix-transformations">Matrix transformations</a></li><li><a href="#operations-on-one-matrix">Operations on one matrix</a></li><li><a href="#operations-on-two-matrices">Operations on two matrices</a></li><li><a href="#iterators-over-matrices">Iterators over matrices</a></li></ul></nav></header><section><header><h6 id="creation-of-matrices-and-accessors"><a href="#creation-of-matrices-and-accessors" class="anchor"></a>Creation of matrices and accessors</h6></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>create m n</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>make m n x</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns initialized with value <code>x</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make0"><a href="#val-make0" class="anchor"></a><code><span class="keyword">val</span> make0 : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>make0 m n x</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns initialized with the zero element.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span><span>float array</span> array</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>of_array ar</code> </p><dl><dt>returns</dt><dd><p>a matrix initialized from the array of arrays <code>ar</code>. It is assumed that the OCaml matrix is in row major order (standard).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span><span>float array</span> array</span></code></dt><dd><p><code>to_array mat</code> </p><dl><dt>returns</dt><dd><p>an array of arrays initialized from matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><span>float list</span> list</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>of_list ls</code> </p><dl><dt>returns</dt><dd><p>a matrix initialized from the list of lists <code>ls</code>. Each sublist of <code>ls</code> represents a row of the desired matrix, and must be of the same length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span><span>float list</span> list</span></code></dt><dd><p><code>to_array mat</code> </p><dl><dt>returns</dt><dd><p><code>mat</code> in row major order as lists.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_col_vecs"><a href="#val-of_col_vecs" class="anchor"></a><code><span class="keyword">val</span> of_col_vecs : <span><a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> array</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>of_col_vecs ar</code> </p><dl><dt>returns</dt><dd><p>a matrix whose columns are initialized from the array of vectors <code>ar</code>. The vectors must be of same length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_col_vecs"><a href="#val-to_col_vecs" class="anchor"></a><code><span class="keyword">val</span> to_col_vecs : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span><a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> array</span></code></dt><dd><p><code>to_col_vecs mat</code> </p><dl><dt>returns</dt><dd><p>an array of column vectors initialized from matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_col_vecs_list"><a href="#val-of_col_vecs_list" class="anchor"></a><code><span class="keyword">val</span> of_col_vecs_list : <span><a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> list</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>of_col_vecs_list ar</code> </p><dl><dt>returns</dt><dd><p>a matrix whose columns are initialized from the list of vectors <code>ar</code>. The vectors must be of same length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_col_vecs_list"><a href="#val-to_col_vecs_list" class="anchor"></a><code><span class="keyword">val</span> to_col_vecs_list : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span><a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> list</span></code></dt><dd><p><code>to_col_vecs_list mat</code> </p><dl><dt>returns</dt><dd><p>a list of column vectors initialized from matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-as_vec"><a href="#val-as_vec" class="anchor"></a><code><span class="keyword">val</span> as_vec : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>as_vec mat</code> </p><dl><dt>returns</dt><dd><p>a vector containing all elements of the matrix in column-major order. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-init_rows"><a href="#val-init_rows" class="anchor"></a><code><span class="keyword">val</span> init_rows : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>init_cols m n f</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns, where each element at <code>row</code> and <code>col</code> is initialized by the result of calling <code>f row col</code>. The elements are passed row-wise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-init_cols"><a href="#val-init_cols" class="anchor"></a><code><span class="keyword">val</span> init_cols : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>init_cols m n f</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns, where each element at <code>row</code> and <code>col</code> is initialized by the result of calling <code>f row col</code>. The elements are passed column-wise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_mvec"><a href="#val-create_mvec" class="anchor"></a><code><span class="keyword">val</span> create_mvec : int <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>create_mvec m</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column containing <code>m</code> rows.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make_mvec"><a href="#val-make_mvec" class="anchor"></a><code><span class="keyword">val</span> make_mvec : int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>make_mvec m x</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column containing <code>m</code> rows initialized with value <code>x</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mvec_of_array"><a href="#val-mvec_of_array" class="anchor"></a><code><span class="keyword">val</span> mvec_of_array : <span>float array</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>mvec_of_array ar</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column initialized with values from array <code>ar</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mvec_to_array"><a href="#val-mvec_to_array" class="anchor"></a><code><span class="keyword">val</span> mvec_to_array : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>float array</span></code></dt><dd><p><code>mvec_to_array mat</code> </p><dl><dt>returns</dt><dd><p>an array initialized with values from the first (not necessarily only) column vector of matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_col_vec"><a href="#val-from_col_vec" class="anchor"></a><code><span class="keyword">val</span> from_col_vec : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>from_col_vec v</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column representing vector <code>v</code>. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_row_vec"><a href="#val-from_row_vec" class="anchor"></a><code><span class="keyword">val</span> from_row_vec : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>from_row_vec v</code> </p><dl><dt>returns</dt><dd><p>a matrix with one row representing vector <code>v</code>. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>empty</code>, the empty matrix.</p></dd></dl><dl><dt class="spec value" id="val-identity"><a href="#val-identity" class="anchor"></a><code><span class="keyword">val</span> identity : int <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>identity n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>x<code>n</code> identity matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_diag"><a href="#val-of_diag" class="anchor"></a><code><span class="keyword">val</span> of_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>of_diag ?n ?br ?bc ?b ?ofsx ?incx x</code> </p><dl><dt>returns</dt><dd><p>matrix <code>b</code> with diagonal elements in the designated sub-matrix coming from the designated sub-vector in <code>x</code>.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater <code>n</code> s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = minimal fresh matrix consistent with <code>n</code>, <code>br</code>, and <code>bc</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-dim1"><a href="#val-dim1" class="anchor"></a><code><span class="keyword">val</span> dim1 : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>dim1 m</code> </p><dl><dt>returns</dt><dd><p>the first dimension of matrix <code>m</code> (number of rows).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-dim2"><a href="#val-dim2" class="anchor"></a><code><span class="keyword">val</span> dim2 : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>dim2 m</code> </p><dl><dt>returns</dt><dd><p>the second dimension of matrix <code>m</code> (number of columns).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><code><span class="keyword">val</span> has_zero_dim : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_zero_dim mat</code> checks whether matrix <code>mat</code> has a dimension of size <code>zero</code>. In this case it cannot contain data.</p></dd></dl><dl><dt class="spec value" id="val-col"><a href="#val-col" class="anchor"></a><code><span class="keyword">val</span> col : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>col m n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>th column of matrix <code>m</code> as a vector. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy_row"><a href="#val-copy_row" class="anchor"></a><code><span class="keyword">val</span> copy_row : <span>?&#8288;vec:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>copy_row ?vec mat int</code> </p><dl><dt>returns</dt><dd><p>a copy of the <code>n</code>th row of matrix <code>m</code> in vector <code>vec</code>.</p></dd></dl><dl><dt>parameter vec</dt><dd><p>default = fresh vector of length <code>dim2 mat</code></p></dd></dl></dd></dl></section><section><header><h6 id="matrix-transformations"><a href="#matrix-transformations" class="anchor"></a>Matrix transformations</h6></header><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val</span> swap : <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> swaps the contents of (sub-matrices) <code>a</code> and <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-transpose_copy"><a href="#val-transpose_copy" class="anchor"></a><code><span class="keyword">val</span> transpose_copy : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>transpose_copy ?m ?n ?br ?bc ?b ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the transpose of (sub-)matrix <code>a</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. NOTE: this operations does _not_ support in-place transposes!</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + n - 1</code> rows and <code>bc + m - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-detri"><a href="#val-detri" class="anchor"></a><code><span class="keyword">val</span> detri : <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>detri ?up ?n ?ar ?ac a</code> takes a triangular (sub-)matrix <code>a</code>, i.e. one where only the upper (iff <code>up</code> is true) or lower triangle is defined, and makes it a symmetric matrix by mirroring the defined triangle along the diagonal.</p><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-packed"><a href="#val-packed" class="anchor"></a><code><span class="keyword">val</span> packed : <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>packed ?up ?n ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>(sub-)matrix <code>a</code> in packed storage format.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-unpacked"><a href="#val-unpacked" class="anchor"></a><code><span class="keyword">val</span> unpacked : <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>unpacked ?up x</code> </p><dl><dt>returns</dt><dd><p>an upper or lower (depending on <code>up</code>) triangular matrix from packed representation <code>vec</code>. The other triangle of the matrix will be filled with zeros.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Vec.dim x</code></p></dd></dl></dd></dl></section><section><header><h6 id="operations-on-one-matrix"><a href="#operations-on-one-matrix" class="anchor"></a>Operations on one matrix</h6></header><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill ?patt ?m ?n ?ar ?ac a x</code> fills the specified sub-matrix in <code>a</code> with value <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sum ?patt ?m ?n ?ar ?ac a</code> computes the sum of all elements in the <code>m</code>-by-<code>n</code> submatrix using pattern <code>patt</code>, starting at row <code>ar</code> and column <code>ac</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_const"><a href="#val-add_const" class="anchor"></a><code><span class="keyword">val</span> add_const : float <span>&#45;&gt;</span> <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></dt><dd><p><code>add_const c ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> adds constant <code>c</code> to the designated <code>m</code> by <code>n</code> submatrix in <code>a</code> using pattern <code>patt</code> and stores the result in the designated submatrix in <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = <code>Mat.dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size <code>m</code> by <code>n</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_const_diag"><a href="#val-add_const_diag" class="anchor"></a><code><span class="keyword">val</span> add_const_diag : float <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_const c ?n ?ar ?ac a</code> adds constant <code>c</code> to the diagonal of the designated <code>n</code> by <code>n</code> submatrix in <code>a</code>.</p><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val</span> neg : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></dt><dd><p><code>neg ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the negative of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reci"><a href="#val-reci" class="anchor"></a><code><span class="keyword">val</span> reci : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></dt><dd><p><code>reci ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the reciprocal of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy_diag"><a href="#val-copy_diag" class="anchor"></a><code><span class="keyword">val</span> copy_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>copy_diag ?n ?ofsy ?incy ?y ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the diagonal of the (sub-)matrix <code>a</code> in a (sub-)vector.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greatest <code>n</code> that does not exceed matrix dimensions</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of length <code>n</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span class="keyword">val</span> trace : <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>trace m</code> </p><dl><dt>returns</dt><dd><p>the trace of matrix <code>m</code>. If <code>m</code> is not a square matrix, the sum of the longest possible sequence of diagonal elements will be returned.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-scal"><a href="#val-scal" class="anchor"></a><code><span class="keyword">val</span> scal : <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal ?patt ?m ?n alpha ?ar ?ac a</code> BLAS <code>scal</code> function for (sub-)matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_cols"><a href="#val-scal_cols" class="anchor"></a><code><span class="keyword">val</span> scal_cols : <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;ofs:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_cols ?patt ?m ?n ?ar ?ac a ?ofs alphas</code> column-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_rows"><a href="#val-scal_rows" class="anchor"></a><code><span class="keyword">val</span> scal_rows : <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofs:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_rows ?patt ?m ?n ?ofs alphas ?ar ?ac a</code> row-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-syrk_trace"><a href="#val-syrk_trace" class="anchor"></a><code><span class="keyword">val</span> syrk_trace : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>syrk_trace ?n ?k ?ar ?ac a</code> computes the trace of either <code>a' * a</code> or <code>a * a'</code>, whichever is more efficient (results are identical), of the (sub-)matrix <code>a</code> multiplied by its own transpose. This is the same as the square of the Frobenius norm of a matrix. <code>n</code> is the number of rows to consider in <code>a</code>, and <code>k</code> the number of columns to consider.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syrk_diag"><a href="#val-syrk_diag" class="anchor"></a><code><span class="keyword">val</span> syrk_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>syrk_diag ?n ?k ?beta ?ofsy ?y ?trans ?alpha ?ar ?ac a</code> computes the diagonal of the symmetric rank-k product of the (sub-)matrix <code>a</code>, multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrix will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl></section><section><header><h6 id="operations-on-two-matrices"><a href="#operations-on-two-matrices" class="anchor"></a>Operations on two matrices</h6></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></dt><dd><p><code>add ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the sum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></dt><dd><p><code>sub ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the difference of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val</span> mul : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></dt><dd><p><code>mul ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the element-wise product of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><p>NOTE: please do not confuse this function with matrix multiplication! The LAPACK-function for matrix multiplication is called <code>gemm</code>, e.g. <code>Lacaml.D.gemm</code>.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val</span> div : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></dt><dd><p><code>div ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the division of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-axpy"><a href="#val-axpy" class="anchor"></a><code><span class="keyword">val</span> axpy : <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;xr:int</span> <span>&#45;&gt;</span> <span>?&#8288;xc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;yr:int</span> <span>&#45;&gt;</span> <span>?&#8288;yc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>axpy ?alpha ?patt ?m ?n ?xr ?xc x ?yr ?yc y</code> BLAS <code>axpy</code> function for matrices.</p><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>xr + m - 1 &lt;= dim1 x</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>xc + n - 1 &lt;= dim2 x</code></p></dd></dl><dl><dt>parameter xr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter xc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_diag"><a href="#val-gemm_diag" class="anchor"></a><code><span class="keyword">val</span> gemm_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;transa:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;transb:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>gemm_diag ?n ?k ?beta ?ofsy ?y ?transa ?transb ?alpha ?ar ?ac a ?br ?bc b</code> computes the diagonal of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing), multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrices will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_trace"><a href="#val-gemm_trace" class="anchor"></a><code><span class="keyword">val</span> gemm_trace : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;transa:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;transb:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>gemm_trace ?n ?k ?transa ?ar ?ac a ?transb ?br ?bc b</code> computes the trace of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing). When transposing <code>a</code>, this yields the so-called Frobenius product of <code>a</code> and <code>b</code>. <code>n</code> is the number of rows (columns) to consider in <code>a</code> and the number of columns (rows) in <code>b</code>. <code>k</code> is the inner dimension to use for the product.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-symm2_trace"><a href="#val-symm2_trace" class="anchor"></a><code><span class="keyword">val</span> symm2_trace : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;upa:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;upb:bool</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>symm2_trace ?n ?upa ?ar ?ac a ?upb ?br ?bc b</code> computes the trace of the product of the symmetric (sub-)matrices <code>a</code> and <code>b</code>. <code>n</code> is the number of rows and columns to consider in <code>a</code> and <code>b</code>.</p><dl><dt>parameter n</dt><dd><p>default = dimensions of <code>a</code> and <code>b</code></p></dd></dl><dl><dt>parameter upa</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter upb</dt><dd><p>default = true (upper triangular portion of <code>b</code> is accessed)</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><code><span class="keyword">val</span> ssqr_diff : <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>ssqr_diff ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the sum of squared differences between the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>.</p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="iterators-over-matrices"><a href="#iterators-over-matrices" class="anchor"></a>Iterators over matrices</h6></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(float <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>map f ?m ?n ?br ?bc ?b ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>matrix with <code>f</code> applied to each element of <code>a</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size m by n</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_cols"><a href="#val-fold_cols" class="anchor"></a><code><span class="keyword">val</span> fold_cols : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_cols f ?n ?ac acc a</code></p><dl><dt>returns</dt><dd><p>accumulator resulting from folding over each column vector.</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl></dd></dl></section></div></body></html>