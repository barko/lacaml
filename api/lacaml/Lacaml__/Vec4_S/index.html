<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vec4_S (lacaml.Lacaml__.Vec4_S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">lacaml</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Lacaml__.Vec4_S</span></h1></header><div class="h7">Creation/conversion of vectors and dimension accessor</div><div class="spec val" id="val-create"><a href="#val-create" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create : int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">create n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector with <code class="code">n</code> rows (not initialized).</li></ul></div></div><div class="spec val" id="val-make"><a href="#val-make" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>make : int <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">make n x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector with <code class="code">n</code> rows initialized with value <code class="code">x</code>.</li></ul></div></div><div class="spec val" id="val-make0"><a href="#val-make0" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>make0 : int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">make0 n x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector with <code class="code">n</code> rows initialized with the zero
element.</li></ul></div></div><div class="spec val" id="val-init"><a href="#val-init" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>init : int <span class="keyword">&#8209;&gt;</span> (int <span class="keyword">&#8209;&gt;</span> float) <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">init n f</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector containing <code class="code">n</code> elements, where each
element at position <code class="code">i</code> is initialized by the result of calling
<code class="code">f i</code>.</li></ul></div></div><div class="spec val" id="val-of_array"><a href="#val-of_array" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_array : float array <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">of_array ar</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector initialized from array <code class="code">ar</code>.</li></ul></div></div><div class="spec val" id="val-to_array"><a href="#val-to_array" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_array : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float array</code></div><div class="doc"><p><code class="code">to_array v</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an array initialized from vector <code class="code">v</code>.</li></ul></div></div><div class="spec val" id="val-of_list"><a href="#val-of_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_list : float list <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">of_list l</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector initialized from list <code class="code">l</code>.</li></ul></div></div><div class="spec val" id="val-to_list"><a href="#val-to_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_list : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float list</code></div><div class="doc"><p><code class="code">to_list v</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a list initialized from vector <code class="code">v</code>.</li></ul></div></div><div class="spec val" id="val-append"><a href="#val-append" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>append : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">append v1 v2</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector resulting from appending vector
<code class="code">v2</code> to <code class="code">v1</code>.</li></ul></div></div><div class="spec val" id="val-concat"><a href="#val-concat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>concat : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> list <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">concat vs</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the concatenation of vectors <code class="code">vs</code>.</li></ul></div></div><div class="spec val" id="val-empty"><a href="#val-empty" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>empty : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">empty</code>, the empty vector.</p></div></div><div class="spec val" id="val-linspace"><a href="#val-linspace" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>linspace : ?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">linspace ?z a b n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">y</code> overwritten with <code class="code">n</code>
linearly spaced points between and including <code class="code">a</code> and <code class="code">b</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector of dim <code class="code">n</code></li></ul></div></div><div class="spec val" id="val-logspace"><a href="#val-logspace" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>logspace : ?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> ?&#8288;base:float <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">logspace ?z a b base n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">y</code> overwritten with <code class="code">n</code>
points logarithmically spaced using base <code class="code">b</code> between and including
<code class="code">base</code> ** <code class="code">a</code> and <code class="code">base</code> ** <code class="code">b</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector of dim <code class="code">n</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">base</span>: default = 10.0</li></ul></div></div><div class="spec val" id="val-dim"><a href="#val-dim" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dim : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">dim x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the dimension of vector <code class="code">x</code>.</li></ul></div></div><div class="spec val" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>has_zero_dim : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">has_zero_dim vec</code> checks whether vector <code class="code">vec</code> has a dimension of size
<code class="code">zero</code>. In this case it cannot contain data.</p></div></div><div class="h7">Iterators over vectors</div><div class="spec val" id="val-map"><a href="#val-map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>map : (float <span class="keyword">&#8209;&gt;</span> float) <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">map f ?n ?ofsx ?incx x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a new vector resulting from the
application of <code class="code">f</code> to each element of <code class="code">x</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = new vector with <code class="code">ofsy+(n-1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-iter"><a href="#val-iter" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>iter : (float <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">iter ?n ?ofsx ?incx f x</code> applies function <code class="code">f</code> in turn to all elements
of vector <code class="code">x</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-iteri"><a href="#val-iteri" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>iteri : (int <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">iteri ?n ?ofsx ?incx f x</code> same as <code class="code">iter</code> but additionally passes
the index of the element as first argument and the element itself
as second argument.</p></div></div><div class="spec val" id="val-fold"><a href="#val-fold" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p><code class="code">fold f a ?n ?ofsx ?incx x</code> is
<code class="code">f (... (f (f a x.{ofsx}) x.{ofsx + incx}) ...) x.{ofsx + (n-1)*incx}</code>
if <code class="code">incx &gt; 0</code> and the same in the reverse order of appearance of the
<code class="code">x</code> values if <code class="code">incx &lt; 0</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">Operations on one vector</div><div class="spec val" id="val-rev"><a href="#val-rev" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rev : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">rev x</code> reverses vector <code class="code">x</code> (non-destructive).</p></div></div><div class="spec val" id="val-max"><a href="#val-max" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>max : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">max ?n ?ofsx ?incx x</code> computes the greater of the <code class="code">n</code> elements
in vector <code class="code">x</code> (2-norm), separated by <code class="code">incx</code> incremental steps. NaNs
are ignored. If only NaNs are encountered, the negative <code class="code">infinity</code>
value will be returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-min"><a href="#val-min" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>min : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">min ?n ?ofsx ?incx x</code> computes the smaller of the <code class="code">n</code> elements
in vector <code class="code">x</code> (2-norm), separated by <code class="code">incx</code> incremental steps.
NaNs are ignored. If only NaNs are encountered, the <code class="code">infinity</code> value
will be returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sort"><a href="#val-sort" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sort : ?&#8288;cmp:(float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> int) <span class="keyword">&#8209;&gt;</span> ?&#8288;decr:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsp:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incp:int <span class="keyword">&#8209;&gt;</span> ?&#8288;p:<a href="../../Lacaml/Common/index.html#type-int_vec">Lacaml.Common.int_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">sort ?cmp ?n ?ofsx ?incx x</code> sorts the array <code class="code">x</code> in increasing
order according to the comparison function <code class="code">cmp</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cmp</span>: a function such that <code class="code">cmp a b &lt; 0</code> if <code class="code">a</code> is less than
<code class="code">b</code>, <code class="code">cmp a b = 0</code> if <code class="code">a</code> equal <code class="code">b</code> and <code class="code">cmp a b &gt; 0</code> if <code class="code">a</code> is
greater than <code class="code">b</code> for the desired order. Default: the usual
order on floating point values or the lexicographic order on
complex ones (a special routine makes it fast). Whatever the
order you choose, NaNs (in any component for complex numbers)
are considered larger than any other value (so they will be
last, in no specified order, in the sorted vector). Therefore,
NaN are never passed to <code class="code">cmp</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">p</span>: if you pass a vector of size <code class="code">ofsp+(n - 1)(abs incp)</code>,
the vector <code class="code">x</code> will be unchanged and the permutation to sort it
will be stored in <code class="code">p</code>. Thus <code class="code">x.{p.{ofsp + (i-1) * incp}}</code> will
give the elements of <code class="code">x</code> in increasing order. Default: no
vector is provided.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">decr</span>: sort in decreasing order (stays fast for the default <code class="code">cmp</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater <code class="code">n</code> s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsp</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incp</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-fill"><a href="#val-fill" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fill : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">fill ?n ?ofsx ?incx x a</code> fills vector <code class="code">x</code> with value <code class="code">a</code> in the
designated range.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sum"><a href="#val-sum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sum : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">sum ?n ?ofsx ?incx x</code> computes the sum of the <code class="code">n</code> elements in
vector <code class="code">x</code>, separated by <code class="code">incx</code> incremental steps.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-prod"><a href="#val-prod" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prod : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">prod ?n ?ofsx ?incx x</code> computes the product of the <code class="code">n</code> elements
in vector <code class="code">x</code>, separated by <code class="code">incx</code> incremental steps.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-add_const"><a href="#val-add_const" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>add_const : float <span class="keyword">&#8209;&gt;</span> <a href="../../Lacaml__Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">add_const c ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> adds constant <code class="code">c</code> to the <code class="code">n</code>
elements of vector <code class="code">x</code> and stores the result in <code class="code">y</code>, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">y</code> is given, the result will
be stored in there using increments of <code class="code">incy</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqr_nrm2"><a href="#val-sqr_nrm2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqr_nrm2 : ?&#8288;stable:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">sqr_nrm2 ?stable ?n ?c ?ofsx ?incx x</code> computes the square of
the 2-norm (Euclidean norm) of vector <code class="code">x</code> separated by <code class="code">incx</code>
incremental steps. If <code class="code">stable</code> is true, this is equivalent to
squaring the result of calling the BLAS-function <code class="code">nrm2</code>, which
avoids over- and underflow if possible. If <code class="code">stable</code> is false
(default), <code class="code">dot</code> will be called instead for greatly improved
performance.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">stable</span>: default = <code class="code">false</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ssqr"><a href="#val-ssqr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ssqr : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;c:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">ssqr ?n ?c ?ofsx ?incx x</code> computes the sum of squared differences
of the <code class="code">n</code> elements in vector <code class="code">x</code> from constant <code class="code">c</code>, separated
by <code class="code">incx</code> incremental steps. Please do not confuse with
<a href="index.html#val-sqr_nrm2">sqr_nrm2</a>! The current function behaves differently with
complex numbers when zero is passed in for <code class="code">c</code>. It computes
the square for each entry then, whereas <a href="index.html#val-sqr_nrm2">sqr_nrm2</a> uses the
conjugate transpose in the product. The latter will therefore
always return a real number.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">c</span>: default = zero</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-neg"><a href="#val-neg" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>neg : <a href="../../Lacaml__Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">neg ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> negates <code class="code">n</code> elements of the
vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-reci"><a href="#val-reci" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>reci : <a href="../../Lacaml__Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">reci ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the reciprocal value
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">Operations on two vectors</div><div class="spec val" id="val-add"><a href="#val-add" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>add : <a href="../../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">add ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> adds <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">z</code> is given, the result will
be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sub"><a href="#val-sub" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sub : <a href="../../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">sub ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> subtracts <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">z</code> is given, the result will
be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-mul"><a href="#val-mul" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mul : <a href="../../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">mul ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies
<code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code>
and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the
result will be stored in there using increments of <code class="code">incz</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-div"><a href="#val-div" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>div : <a href="../../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">div ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> divides <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">z</code> is given, the result will
be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-zpxy"><a href="#val-zpxy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>zpxy : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsz:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incz:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">zpxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively, and adds the result to and stores it
in the specified range in <code class="code">z</code>. This function is useful for convolutions.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-zmxy"><a href="#val-zmxy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>zmxy : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsz:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incz:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">zmxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively, and substracts the result from
and stores it in the specified range in <code class="code">z</code>. This function is
useful for convolutions.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ssqr_diff : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">ssqr_diff ?n ?ofsx ?incx x ?ofsy ?incy y</code> returns the sum of
squared differences of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code>, using
<code class="code">incx</code> and <code class="code">incy</code> as incremental steps respectively.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div></body></html>