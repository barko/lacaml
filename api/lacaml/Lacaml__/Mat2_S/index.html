<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mat2_S (lacaml.Lacaml__.Mat2_S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">lacaml</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Lacaml__.Mat2_S</span></h1></header><h6>Matrix operations</h6><div class="h7">Creation of matrices</div><div class="spec val" id="val-hilbert"><a href="#val-hilbert" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>hilbert : int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">hilbert n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an <code class="code">n</code>x<code class="code">n</code> Hilbert matrix.</li></ul></div></div><div class="spec val" id="val-hankel"><a href="#val-hankel" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>hankel : int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">hankel n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an <code class="code">n</code>x<code class="code">n</code> Hankel matrix.</li></ul></div></div><div class="spec val" id="val-pascal"><a href="#val-pascal" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pascal : int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">pascal n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an <code class="code">n</code>x<code class="code">n</code> Pascal matrix.</li></ul></div></div><div class="spec val" id="val-rosser"><a href="#val-rosser" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rosser : unit <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">rosser n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> 8x8 Rosser matrix.</li></ul></div></div><div class="spec val" id="val-toeplitz"><a href="#val-toeplitz" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>toeplitz : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">toeplitz v</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the Toeplitz matrix associated with <code class="code">v</code>.
The constant diagonals are read from left to right from <code class="code">v</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if the length of <code class="code">v</code> is not an odd number.</li></ul></div></div><div class="spec val" id="val-vandermonde"><a href="#val-vandermonde" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>vandermonde : <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">vandermonde v</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the Vandermonde matrix associated with <code class="code">v</code>.</li></ul></div></div><div class="spec val" id="val-wilkinson"><a href="#val-wilkinson" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>wilkinson : int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">wilkinson n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the <code class="code">n</code>x<code class="code">n</code> Wilkinson matrix.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if <code class="code">n</code> is not an odd number &gt;= 3.</li></ul></div></div><div class="spec val" id="val-random"><a href="#val-random" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>random : ?&#8288;rnd_state:Random.State.t <span class="keyword">&#8209;&gt;</span> ?&#8288;from:float <span class="keyword">&#8209;&gt;</span> ?&#8288;range:float <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">random ?rnd_state ?from ?range m n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an <code class="code">m</code>x<code class="code">n</code> matrix
initialized with random elements sampled uniformly from <code class="code">range</code>
starting at <code class="code">from</code>. A random state <code class="code">rnd_state</code> can be passed.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rnd_state</span>: default = Random.get_state ()</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">from</span>: default = -1.0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">range</span>: default = 2.0</li></ul></div></div><div class="h7">Unary matrix operations</div><div class="spec val" id="val-abs"><a href="#val-abs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>abs : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">abs ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the absolute value of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in
row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-signum"><a href="#val-signum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>signum : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">signum ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sign value (<code class="code">-1</code> for
negative numbers, <code class="code">0</code> (or <code class="code">-0</code>) for zero, <code class="code">1</code> for positive numbers,
<code class="code">nan</code> for <code class="code">nan</code>) of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the
matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code>
is given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqr"><a href="#val-sqr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqr : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">sqr ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square of the elements
in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code>
and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result will
be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh matrix
will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqrt : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">sqrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square root of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cbrt"><a href="#val-cbrt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cbrt : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">cbrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cubic root of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-exp"><a href="#val-exp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exp : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">exp ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the exponential of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-exp2"><a href="#val-exp2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exp2 : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">exp2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-2 exponential of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-expm1"><a href="#val-expm1" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>expm1 : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">expm1 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code class="code">exp a -. 1.</code> of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log"><a href="#val-log" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">log ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logarithm of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log10"><a href="#val-log10" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log10 : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">log10 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-10 logarithm of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log2"><a href="#val-log2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log2 : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">log2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes base-2 logarithm of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log1p"><a href="#val-log1p" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log1p : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">log1p ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code class="code">log (1 + a)</code> of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sin"><a href="#val-sin" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sin : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">sin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sine of the elements in
the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column
<code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result will be stored in
there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh matrix will be used.
The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cos"><a href="#val-cos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cos : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">cos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cosine of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-tan"><a href="#val-tan" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tan : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">tan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the tangent of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-asin"><a href="#val-asin" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asin : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">asin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc sine of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-acos"><a href="#val-acos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>acos : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">acos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc cosine of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atan"><a href="#val-atan" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atan : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">atan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc tangent of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sinh"><a href="#val-sinh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sinh : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">sinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic sine of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cosh"><a href="#val-cosh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cosh : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">cosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic cosine of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-tanh"><a href="#val-tanh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tanh : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">tanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic tangent of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-asinh"><a href="#val-asinh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asinh : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">asinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc
sine of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code>
starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is
given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-acosh"><a href="#val-acosh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>acosh : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">acosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc
cosine of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code>
starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is
given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atanh"><a href="#val-atanh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atanh : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">atanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc
tangent of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code>
starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is
given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-floor"><a href="#val-floor" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>floor : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">floor ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the floor of the elements
in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code>
and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result will
be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh matrix
will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ceil"><a href="#val-ceil" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ceil : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">ceil ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the ceiling of the
elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result
will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh
matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-round"><a href="#val-round" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>round : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">round ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> rounds the elements in the <code class="code">m</code>
by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column
<code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the result will be stored in
there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh matrix will be used.
The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-trunc"><a href="#val-trunc" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>trunc : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">trunc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the truncation of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-erf"><a href="#val-erf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>erf : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">erf ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the error function of
the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is given, the
result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise
a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-erfc"><a href="#val-erfc" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>erfc : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">erfc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the complementary error
function of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix
<code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is
given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-logistic"><a href="#val-logistic" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>logistic : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">logistic ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logistic function
<code class="code">1/(1 + exp(-a)</code> of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix
<code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is
given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-relu"><a href="#val-relu" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>relu : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">relu ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the rectified linear unit
function <code class="code">max(a, 0)</code> of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the
matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code>
is given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-softplus"><a href="#val-softplus" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>softplus : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">softplus ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softplus function
<code class="code">log(1 + exp(x)</code> of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix
<code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code> is
given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-softsign"><a href="#val-softsign" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>softsign : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-unop">Lacaml__.Float32.Types.Mat.unop</a></code></div><div class="doc"><p><code class="code">softsign ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softsign function
<code class="code">x / (1 + abs(x))</code> of the elements in the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the
matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code>. If <code class="code">b</code>
is given, the result will be stored in there using offsets <code class="code">br</code> and <code class="code">bc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">b</span>: default = fresh matrix with <code class="code">br + m - 1</code> rows and
<code class="code">bc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="h7">Binary matrix operations</div><div class="spec val" id="val-pow"><a href="#val-pow" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pow : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></div><div class="doc"><p><code class="code">pow ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code class="code">pow(a, b)</code> for
the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code> and
column <code class="code">ac</code> and pattern <code class="code">patt</code> with the corresponding sub-matrix of
the matrix <code class="code">b</code> starting in row <code class="code">br</code> and column <code class="code">bc</code>. If <code class="code">c</code> is given,
the result will be stored in there starting in row <code class="code">cr</code> and column <code class="code">cc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">c</span>: default = fresh matrix with <code class="code">cr + m - 1</code> rows and
<code class="code">cc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atan2"><a href="#val-atan2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atan2 : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></div><div class="doc"><p><code class="code">atan2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes
<code class="code">atan2(a, b)</code> for the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting
in row <code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code> with the corresponding
sub-matrix of the matrix <code class="code">b</code> starting in row <code class="code">br</code> and column <code class="code">bc</code>.
If <code class="code">c</code> is given, the result will be stored in there starting in row <code class="code">cr</code>
and column <code class="code">cc</code>, otherwise a fresh matrix will be used. The resulting
matrix is returned.</p><p>NOTE: WARNING! From a geometric point of view, the <code class="code">atan2</code> function takes
the y-coordinate in <code class="code">a</code> and the x-coordinate in <code class="code">b</code>. This confusion is
a sad consequence of the C99-standard reversing the argument order for
<code class="code">atan2</code> for no good reason.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">c</span>: default = fresh matrix with <code class="code">cr + m - 1</code> rows and
<code class="code">cc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-hypot"><a href="#val-hypot" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>hypot : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></div><div class="doc"><p><code class="code">hypot ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code class="code">sqrt(a*a+b*b)</code>
for the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code>
and column <code class="code">ac</code> and pattern <code class="code">patt</code> with the corresponding sub-matrix of
the matrix <code class="code">b</code> starting in row <code class="code">br</code> and column <code class="code">bc</code>. If <code class="code">c</code> is given,
the result will be stored in there starting in row <code class="code">cr</code> and column <code class="code">cc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">c</span>: default = fresh matrix with <code class="code">cr + m - 1</code> rows and
<code class="code">cc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-min2"><a href="#val-min2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>min2 : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></div><div class="doc"><p><code class="code">min2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise
minimum of the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code> with the corresponding sub-matrix
of the matrix <code class="code">b</code> starting in row <code class="code">br</code> and column <code class="code">bc</code>. If <code class="code">c</code> is given,
the result will be stored in there starting in row <code class="code">cr</code> and column <code class="code">cc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">c</span>: default = fresh matrix with <code class="code">cr + m - 1</code> rows and
<code class="code">cc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-max2"><a href="#val-max2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>max2 : <a href="../../Lacaml__Float32/Types/Mat/index.html#type-binop">Lacaml__.Float32.Types.Mat.binop</a></code></div><div class="doc"><p><code class="code">max2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise
maximum of the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> and pattern <code class="code">patt</code> with the corresponding sub-matrix
of the matrix <code class="code">b</code> starting in row <code class="code">br</code> and column <code class="code">bc</code>. If <code class="code">c</code> is given,
the result will be stored in there starting in row <code class="code">cr</code> and column <code class="code">cc</code>,
otherwise a fresh matrix will be used. The resulting matrix is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">c</span>: default = fresh matrix with <code class="code">cr + m - 1</code> rows and
<code class="code">cc + n - 1</code> columns</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sum_prod"><a href="#val-sum_prod" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sum_prod : ?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">sum_prod ?patt ?m ?n ?ar ?ac a ?br ?bc b</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the sum of elementwise
products between the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
<code class="code">ar</code> and column <code class="code">ac</code> with the corresponding sub-matrix of the matrix <code class="code">b</code>
starting in row <code class="code">br</code> and column <code class="code">bc</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li></ul></div></div><div class="h7">Miscellaneous functions</div><div class="spec val" id="val-log_sum_exp"><a href="#val-log_sum_exp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log_sum_exp : ?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">log_sum_exp ?patt ?m ?n ?ar ?ac a</code> computes the logarithm of the sum of
exponentials of all elements in the <code class="code">m</code>-by-<code class="code">n</code> submatrix using pattern
<code class="code">patt</code>, starting at row <code class="code">ar</code> and column <code class="code">ac</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = number of rows of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = number of columns of <code class="code">a</code></li></ul></div></div><div class="h7">Ternary matrix operations</div><div class="spec val" id="val-cpab"><a href="#val-cpab" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cpab : ?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;cr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;cc:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">cpab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated
<code class="code">m</code>-by-<code class="code">n</code> range of elements of matrices <code class="code">a</code> and <code class="code">b</code> using pattern <code class="code">patt</code>
elementwise and adds the result to and stores it in the specified range
in <code class="code">c</code>. This function is useful for convolutions. Similar to <code class="code">Vec.zpxy</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = number of rows of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = number of columns of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cmab"><a href="#val-cmab" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cmab : ?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;cr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;cc:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">cmab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated
<code class="code">m</code>-by-<code class="code">n</code> range of elements of matrices <code class="code">a</code> and <code class="code">b</code> elementwise using
pattern <code class="code">patt</code> and subtracts the result from and stores it in the
specified range in <code class="code">c</code>. This function is useful for convolutions.
Similar to <code class="code">Vec.zmxy</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">patt</span>: default = <code class="code">`Full</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = number of rows of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = number of columns of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">br</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">bc</span>: default = 1</li></ul></div></div></body></html>