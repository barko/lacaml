<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vec (lacaml.Lacaml__.S.Vec)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../../index.html">lacaml</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Lacaml__.S.Vec</span></h1></header><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="../index.html#type-vec">vec</a></code><code></code></div><div class="doc"></div></div><h6>Vector operations</h6><div class="spec type" id="type-unop"><a href="#type-unop" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>unop</code><code><span class="keyword"> = </span>?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-binop"><a href="#type-binop" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>binop</code><code><span class="keyword"> = </span>?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsz:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incz:int <span class="keyword">&#8209;&gt;</span> ?&#8288;z:<a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code><code></code></div><div class="doc"></div></div><div class="h7">Creation of vectors</div><div class="spec val" id="val-random"><a href="#val-random" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>random : ?&#8288;rnd_state:Random.State.t <span class="keyword">&#8209;&gt;</span> ?&#8288;from:float <span class="keyword">&#8209;&gt;</span> ?&#8288;range:float <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">random ?rnd_state ?from ?range n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector
of size <code class="code">n</code> initialized with random elements sampled uniformly from
<code class="code">range</code> starting at <code class="code">from</code>. A random state <code class="code">rnd_state</code> can be passed.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rnd_state</span>: default = Random.get_state ()</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">from</span>: default = -1.0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">range</span>: default = 2.0</li></ul></div></div><div class="h7">Unary vector operations</div><div class="spec val" id="val-abs"><a href="#val-abs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>abs : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">abs ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the absolute value
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-signum"><a href="#val-signum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>signum : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">signum ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the sign value (<code class="code">-1</code> for
negative numbers, <code class="code">0</code> (or <code class="code">-0</code>) for zero, <code class="code">1</code> for positive numbers,
<code class="code">nan</code> for <code class="code">nan</code>) of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as
incremental steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqr"><a href="#val-sqr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqr : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">sqr ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the square
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqrt : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">sqrt ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the square root
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cbrt"><a href="#val-cbrt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cbrt : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">cbrt ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the cubic root
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-exp"><a href="#val-exp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exp : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">exp ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the exponential
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-exp2"><a href="#val-exp2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exp2 : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">exp2 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-2 exponential
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-expm1"><a href="#val-expm1" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>expm1 : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">expm1 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes <code class="code">exp x -. 1.</code>
for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log"><a href="#val-log" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">log ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the logarithm
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log10"><a href="#val-log10" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log10 : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">log10 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-10 logarithm
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log2"><a href="#val-log2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log2 : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">log2 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-2 logarithm
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log1p"><a href="#val-log1p" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log1p : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">log1p ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes <code class="code">log (1 + x)</code> for <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sin"><a href="#val-sin" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sin : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">sin ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the sine of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cos"><a href="#val-cos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cos : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">cos ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the cosine of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-tan"><a href="#val-tan" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tan : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">tan ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the tangent of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-asin"><a href="#val-asin" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asin : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">asin ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc sine of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-acos"><a href="#val-acos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>acos : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">acos ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc cosine of <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atan"><a href="#val-atan" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atan : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">atan ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc tangent of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sinh"><a href="#val-sinh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sinh : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">sinh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic sine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cosh"><a href="#val-cosh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cosh : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">cosh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic cosine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-tanh"><a href="#val-tanh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tanh : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">tanh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic tangent of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-asinh"><a href="#val-asinh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asinh : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">asinh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc sine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-acosh"><a href="#val-acosh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>acosh : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">cosh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc cosine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atanh"><a href="#val-atanh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atanh : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">atanh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc
tangent of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there using
increments of <code class="code">incy</code>, otherwise a fresh vector will be used. The resulting
vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-floor"><a href="#val-floor" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>floor : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">floor ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the floor of <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ceil"><a href="#val-ceil" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ceil : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">ceil ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the ceiling of <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-round"><a href="#val-round" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>round : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">round ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> rounds the <code class="code">n</code> elements of the
vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given, the
result will be stored in there using increments of <code class="code">incy</code>, otherwise a
fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-trunc"><a href="#val-trunc" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>trunc : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">trunc ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the truncation of the <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-erf"><a href="#val-erf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>erf : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">erf ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the error function for
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-erfc"><a href="#val-erfc" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>erfc : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">erfc ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the complementary error
function for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there using
increments of <code class="code">incy</code>, otherwise a fresh vector will be used. The resulting
vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-logistic"><a href="#val-logistic" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>logistic : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">logistic ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the logistict
function <code class="code">1/(1 + exp(-a)</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-relu"><a href="#val-relu" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>relu : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">relu ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the rectified linear
unit function <code class="code">max(x, 0)</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-softplus"><a href="#val-softplus" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>softplus : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">softplus ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the softplus function
<code class="code">log(1 + exp(x)</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-softsign"><a href="#val-softsign" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>softsign : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">softsign ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the softsign function
<code class="code">x / (1 + abs(x))</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">Binary vector operations</div><div class="spec val" id="val-pow"><a href="#val-pow" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pow : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">pow ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes <code class="code">pow(a, b)</code>
of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and
<code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the result
will be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atan2"><a href="#val-atan2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atan2 : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">atan2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes
<code class="code">atan2(x, y)</code> of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using
<code class="code">incx</code> and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given,
the result will be stored in there using increments of <code class="code">incz</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><p>NOTE: WARNING! From a geometric point of view, the <code class="code">atan2</code> function takes
the y-coordinate in <code class="code">x</code> and the x-coordinate in <code class="code">y</code>. This confusion is
a sad consequence of the C99-standard reversing the argument order for
<code class="code">atan2</code> for no good reason.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-hypot"><a href="#val-hypot" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>hypot : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">hypot ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes
<code class="code">sqrt(x*x + y*y)</code> of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise,
using <code class="code">incx</code> and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is
given, the result will be stored in there using increments of <code class="code">incz</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-min2"><a href="#val-min2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>min2 : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">min2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes the
minimum of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code>
and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the result
will be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-max2"><a href="#val-max2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>max2 : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">max2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes the
maximum of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code>
and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the result
will be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="h7">Miscellaneous functions</div><div class="spec val" id="val-log_sum_exp"><a href="#val-log_sum_exp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log_sum_exp : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">log_sum_exp ?n ?ofsx ?incx x</code> computes the logarithm of the sum of
exponentials of the <code class="code">n</code> elements in vector <code class="code">x</code>, separated by <code class="code">incx</code>
incremental steps.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">Creation/conversion of vectors and dimension accessor</div><div class="spec val" id="val-create"><a href="#val-create" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create : int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">create n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector with <code class="code">n</code> rows (not initialized).</li></ul></div></div><div class="spec val" id="val-make"><a href="#val-make" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>make : int <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">make n x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector with <code class="code">n</code> rows initialized with value <code class="code">x</code>.</li></ul></div></div><div class="spec val" id="val-make0"><a href="#val-make0" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>make0 : int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">make0 n x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector with <code class="code">n</code> rows initialized with the zero
element.</li></ul></div></div><div class="spec val" id="val-init"><a href="#val-init" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>init : int <span class="keyword">&#8209;&gt;</span> (int <span class="keyword">&#8209;&gt;</span> float) <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">init n f</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector containing <code class="code">n</code> elements, where each
element at position <code class="code">i</code> is initialized by the result of calling
<code class="code">f i</code>.</li></ul></div></div><div class="spec val" id="val-of_array"><a href="#val-of_array" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_array : float array <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">of_array ar</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector initialized from array <code class="code">ar</code>.</li></ul></div></div><div class="spec val" id="val-to_array"><a href="#val-to_array" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_array : <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float array</code></div><div class="doc"><p><code class="code">to_array v</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an array initialized from vector <code class="code">v</code>.</li></ul></div></div><div class="spec val" id="val-of_list"><a href="#val-of_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_list : float list <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">of_list l</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector initialized from list <code class="code">l</code>.</li></ul></div></div><div class="spec val" id="val-to_list"><a href="#val-to_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_list : <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float list</code></div><div class="doc"><p><code class="code">to_list v</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a list initialized from vector <code class="code">v</code>.</li></ul></div></div><div class="spec val" id="val-append"><a href="#val-append" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>append : <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">append v1 v2</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector resulting from appending vector
<code class="code">v2</code> to <code class="code">v1</code>.</li></ul></div></div><div class="spec val" id="val-concat"><a href="#val-concat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>concat : <a href="../index.html#type-vec">vec</a> list <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">concat vs</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the concatenation of vectors <code class="code">vs</code>.</li></ul></div></div><div class="spec val" id="val-empty"><a href="#val-empty" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>empty : <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">empty</code>, the empty vector.</p></div></div><div class="spec val" id="val-linspace"><a href="#val-linspace" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>linspace : ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">linspace ?z a b n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">y</code> overwritten with <code class="code">n</code>
linearly spaced points between and including <code class="code">a</code> and <code class="code">b</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector of dim <code class="code">n</code></li></ul></div></div><div class="spec val" id="val-logspace"><a href="#val-logspace" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>logspace : ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> ?&#8288;base:float <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">logspace ?z a b base n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">y</code> overwritten with <code class="code">n</code>
points logarithmically spaced using base <code class="code">b</code> between and including
<code class="code">base</code> ** <code class="code">a</code> and <code class="code">base</code> ** <code class="code">b</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector of dim <code class="code">n</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">base</span>: default = 10.0</li></ul></div></div><div class="spec val" id="val-dim"><a href="#val-dim" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dim : <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">dim x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the dimension of vector <code class="code">x</code>.</li></ul></div></div><div class="spec val" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>has_zero_dim : <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">has_zero_dim vec</code> checks whether vector <code class="code">vec</code> has a dimension of size
<code class="code">zero</code>. In this case it cannot contain data.</p></div></div><div class="h7">Iterators over vectors</div><div class="spec val" id="val-map"><a href="#val-map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>map : (float <span class="keyword">&#8209;&gt;</span> float) <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">map f ?n ?ofsx ?incx x</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a new vector resulting from the
application of <code class="code">f</code> to each element of <code class="code">x</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = new vector with <code class="code">ofsy+(n-1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-iter"><a href="#val-iter" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>iter : (float <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">iter ?n ?ofsx ?incx f x</code> applies function <code class="code">f</code> in turn to all elements
of vector <code class="code">x</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-iteri"><a href="#val-iteri" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>iteri : (int <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">iteri ?n ?ofsx ?incx f x</code> same as <code class="code">iter</code> but additionally passes
the index of the element as first argument and the element itself
as second argument.</p></div></div><div class="spec val" id="val-fold"><a href="#val-fold" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p><code class="code">fold f a ?n ?ofsx ?incx x</code> is
<code class="code">f (... (f (f a x.{ofsx}) x.{ofsx + incx}) ...) x.{ofsx + (n-1)*incx}</code>
if <code class="code">incx &gt; 0</code> and the same in the reverse order of appearance of the
<code class="code">x</code> values if <code class="code">incx &lt; 0</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">Operations on one vector</div><div class="spec val" id="val-rev"><a href="#val-rev" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rev : <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a></code></div><div class="doc"><p><code class="code">rev x</code> reverses vector <code class="code">x</code> (non-destructive).</p></div></div><div class="spec val" id="val-max"><a href="#val-max" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>max : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">max ?n ?ofsx ?incx x</code> computes the greater of the <code class="code">n</code> elements
in vector <code class="code">x</code> (2-norm), separated by <code class="code">incx</code> incremental steps. NaNs
are ignored. If only NaNs are encountered, the negative <code class="code">infinity</code>
value will be returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-min"><a href="#val-min" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>min : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">min ?n ?ofsx ?incx x</code> computes the smaller of the <code class="code">n</code> elements
in vector <code class="code">x</code> (2-norm), separated by <code class="code">incx</code> incremental steps.
NaNs are ignored. If only NaNs are encountered, the <code class="code">infinity</code> value
will be returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sort"><a href="#val-sort" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sort : ?&#8288;cmp:(float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> int) <span class="keyword">&#8209;&gt;</span> ?&#8288;decr:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsp:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incp:int <span class="keyword">&#8209;&gt;</span> ?&#8288;p:<a href="../../../Lacaml/Common/index.html#type-int_vec">Lacaml.Common.int_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">sort ?cmp ?n ?ofsx ?incx x</code> sorts the array <code class="code">x</code> in increasing
order according to the comparison function <code class="code">cmp</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">cmp</span>: a function such that <code class="code">cmp a b &lt; 0</code> if <code class="code">a</code> is less than
<code class="code">b</code>, <code class="code">cmp a b = 0</code> if <code class="code">a</code> equal <code class="code">b</code> and <code class="code">cmp a b &gt; 0</code> if <code class="code">a</code> is
greater than <code class="code">b</code> for the desired order. Default: the usual
order on floating point values or the lexicographic order on
complex ones (a special routine makes it fast). Whatever the
order you choose, NaNs (in any component for complex numbers)
are considered larger than any other value (so they will be
last, in no specified order, in the sorted vector). Therefore,
NaN are never passed to <code class="code">cmp</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">p</span>: if you pass a vector of size <code class="code">ofsp+(n - 1)(abs incp)</code>,
the vector <code class="code">x</code> will be unchanged and the permutation to sort it
will be stored in <code class="code">p</code>. Thus <code class="code">x.{p.{ofsp + (i-1) * incp}}</code> will
give the elements of <code class="code">x</code> in increasing order. Default: no
vector is provided.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">decr</span>: sort in decreasing order (stays fast for the default <code class="code">cmp</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater <code class="code">n</code> s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsp</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incp</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-fill"><a href="#val-fill" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fill : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">fill ?n ?ofsx ?incx x a</code> fills vector <code class="code">x</code> with value <code class="code">a</code> in the
designated range.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sum"><a href="#val-sum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sum : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">sum ?n ?ofsx ?incx x</code> computes the sum of the <code class="code">n</code> elements in
vector <code class="code">x</code>, separated by <code class="code">incx</code> incremental steps.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-prod"><a href="#val-prod" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prod : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">prod ?n ?ofsx ?incx x</code> computes the product of the <code class="code">n</code> elements
in vector <code class="code">x</code>, separated by <code class="code">incx</code> incremental steps.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-add_const"><a href="#val-add_const" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>add_const : float <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">add_const c ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> adds constant <code class="code">c</code> to the <code class="code">n</code>
elements of vector <code class="code">x</code> and stores the result in <code class="code">y</code>, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">y</code> is given, the result will
be stored in there using increments of <code class="code">incy</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqr_nrm2"><a href="#val-sqr_nrm2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqr_nrm2 : ?&#8288;stable:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">sqr_nrm2 ?stable ?n ?c ?ofsx ?incx x</code> computes the square of
the 2-norm (Euclidean norm) of vector <code class="code">x</code> separated by <code class="code">incx</code>
incremental steps. If <code class="code">stable</code> is true, this is equivalent to
squaring the result of calling the BLAS-function <code class="code">nrm2</code>, which
avoids over- and underflow if possible. If <code class="code">stable</code> is false
(default), <code class="code">dot</code> will be called instead for greatly improved
performance.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">stable</span>: default = <code class="code">false</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ssqr"><a href="#val-ssqr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ssqr : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;c:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">ssqr ?n ?c ?ofsx ?incx x</code> computes the sum of squared differences
of the <code class="code">n</code> elements in vector <code class="code">x</code> from constant <code class="code">c</code>, separated
by <code class="code">incx</code> incremental steps. Please do not confuse with
<a href="index.html#val-sqr_nrm2">sqr_nrm2</a>! The current function behaves differently with
complex numbers when zero is passed in for <code class="code">c</code>. It computes
the square for each entry then, whereas <a href="index.html#val-sqr_nrm2">sqr_nrm2</a> uses the
conjugate transpose in the product. The latter will therefore
always return a real number.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">c</span>: default = zero</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-neg"><a href="#val-neg" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>neg : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">neg ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> negates <code class="code">n</code> elements of the
vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-reci"><a href="#val-reci" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>reci : <a href="index.html#type-unop">unop</a></code></div><div class="doc"><p><code class="code">reci ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the reciprocal value
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">Operations on two vectors</div><div class="spec val" id="val-add"><a href="#val-add" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>add : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">add ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> adds <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">z</code> is given, the result will
be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sub"><a href="#val-sub" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sub : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">sub ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> subtracts <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">z</code> is given, the result will
be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-mul"><a href="#val-mul" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mul : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">mul ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies
<code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code>
and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the
result will be stored in there using increments of <code class="code">incz</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-div"><a href="#val-div" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>div : <a href="index.html#type-binop">binop</a></code></div><div class="doc"><p><code class="code">div ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> divides <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively. If <code class="code">z</code> is given, the result will
be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-zpxy"><a href="#val-zpxy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>zpxy : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsz:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incz:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">zpxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively, and adds the result to and stores it
in the specified range in <code class="code">z</code>. This function is useful for convolutions.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-zmxy"><a href="#val-zmxy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>zmxy : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsz:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incz:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">zmxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code class="code">n</code>
elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
as incremental steps respectively, and substracts the result from
and stores it in the specified range in <code class="code">z</code>. This function is
useful for convolutions.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ssqr_diff : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-vec">vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">ssqr_diff ?n ?ofsx ?incx x ?ofsy ?incy y</code> returns the sum of
squared differences of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code>, using
<code class="code">incx</code> and <code class="code">incy</code> as incremental steps respectively.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div></body></html>