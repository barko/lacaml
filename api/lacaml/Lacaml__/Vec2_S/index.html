<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vec2_S (lacaml.Lacaml__.Vec2_S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">lacaml</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Lacaml__.Vec2_S</span></h1></header><h6>Vector operations</h6><div class="h7">Creation of vectors</div><div class="spec val" id="val-random"><a href="#val-random" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>random : ?&#8288;rnd_state:Random.State.t <span class="keyword">&#8209;&gt;</span> ?&#8288;from:float <span class="keyword">&#8209;&gt;</span> ?&#8288;range:float <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">random ?rnd_state ?from ?range n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> a vector
of size <code class="code">n</code> initialized with random elements sampled uniformly from
<code class="code">range</code> starting at <code class="code">from</code>. A random state <code class="code">rnd_state</code> can be passed.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rnd_state</span>: default = Random.get_state ()</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">from</span>: default = -1.0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">range</span>: default = 2.0</li></ul></div></div><div class="h7">Unary vector operations</div><div class="spec val" id="val-abs"><a href="#val-abs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>abs : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">abs ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the absolute value
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-signum"><a href="#val-signum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>signum : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">signum ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the sign value (<code class="code">-1</code> for
negative numbers, <code class="code">0</code> (or <code class="code">-0</code>) for zero, <code class="code">1</code> for positive numbers,
<code class="code">nan</code> for <code class="code">nan</code>) of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as
incremental steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqr"><a href="#val-sqr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqr : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">sqr ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the square
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sqrt : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">sqrt ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the square root
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cbrt"><a href="#val-cbrt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cbrt : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">cbrt ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the cubic root
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-exp"><a href="#val-exp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exp : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">exp ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the exponential
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-exp2"><a href="#val-exp2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exp2 : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">exp2 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-2 exponential
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-expm1"><a href="#val-expm1" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>expm1 : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">expm1 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes <code class="code">exp x -. 1.</code>
for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log"><a href="#val-log" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">log ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the logarithm
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there
using increments of <code class="code">incy</code>, otherwise a fresh vector will be
used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log10"><a href="#val-log10" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log10 : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">log10 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-10 logarithm
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log2"><a href="#val-log2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log2 : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">log2 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-2 logarithm
of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-log1p"><a href="#val-log1p" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log1p : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">log1p ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes <code class="code">log (1 + x)</code> for <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sin"><a href="#val-sin" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sin : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">sin ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the sine of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cos"><a href="#val-cos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cos : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">cos ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the cosine of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-tan"><a href="#val-tan" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tan : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">tan ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the tangent of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-asin"><a href="#val-asin" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asin : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">asin ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc sine of <code class="code">n</code> elements
of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given,
the result will be stored in there using increments of <code class="code">incy</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-acos"><a href="#val-acos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>acos : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">acos ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc cosine of <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atan"><a href="#val-atan" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atan : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">atan ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc tangent of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sinh"><a href="#val-sinh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sinh : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">sinh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic sine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-cosh"><a href="#val-cosh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cosh : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">cosh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic cosine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-tanh"><a href="#val-tanh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tanh : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">tanh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic tangent of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-asinh"><a href="#val-asinh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asinh : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">asinh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc sine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-acosh"><a href="#val-acosh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>acosh : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">cosh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc cosine of
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atanh"><a href="#val-atanh" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atanh : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">atanh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc
tangent of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there using
increments of <code class="code">incy</code>, otherwise a fresh vector will be used. The resulting
vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-floor"><a href="#val-floor" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>floor : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">floor ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the floor of <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ceil"><a href="#val-ceil" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ceil : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">ceil ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the ceiling of <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-round"><a href="#val-round" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>round : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">round ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> rounds the <code class="code">n</code> elements of the
vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code> is given, the
result will be stored in there using increments of <code class="code">incy</code>, otherwise a
fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-trunc"><a href="#val-trunc" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>trunc : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">trunc ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the truncation of the <code class="code">n</code>
elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps. If <code class="code">y</code>
is given, the result will be stored in there using increments of <code class="code">incy</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-erf"><a href="#val-erf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>erf : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">erf ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the error function for
<code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
If <code class="code">y</code> is given, the result will be stored in there using increments of
<code class="code">incy</code>, otherwise a fresh vector will be used. The resulting vector
is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-erfc"><a href="#val-erfc" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>erfc : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">erfc ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the complementary error
function for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental
steps. If <code class="code">y</code> is given, the result will be stored in there using
increments of <code class="code">incy</code>, otherwise a fresh vector will be used. The resulting
vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-logistic"><a href="#val-logistic" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>logistic : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">logistic ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the logistict
function <code class="code">1/(1 + exp(-a)</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-relu"><a href="#val-relu" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>relu : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">relu ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the rectified linear
unit function <code class="code">max(x, 0)</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-softplus"><a href="#val-softplus" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>softplus : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">softplus ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the softplus function
<code class="code">log(1 + exp(x)</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-softsign"><a href="#val-softsign" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>softsign : <a href="../Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></div><div class="doc"><p><code class="code">softsign ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the softsign function
<code class="code">x / (1 + abs(x))</code> for <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code>
as incremental steps. If <code class="code">y</code> is given, the result will be stored in
there using increments of <code class="code">incy</code>, otherwise a fresh vector will be used.
The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = fresh vector with <code class="code">ofsy+(n - 1)(abs incy)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">Binary vector operations</div><div class="spec val" id="val-pow"><a href="#val-pow" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pow : <a href="../Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">pow ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes <code class="code">pow(a, b)</code>
of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and
<code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the result
will be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-atan2"><a href="#val-atan2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atan2 : <a href="../Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">atan2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes
<code class="code">atan2(x, y)</code> of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using
<code class="code">incx</code> and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given,
the result will be stored in there using increments of <code class="code">incz</code>, otherwise
a fresh vector will be used. The resulting vector is returned.</p><p>NOTE: WARNING! From a geometric point of view, the <code class="code">atan2</code> function takes
the y-coordinate in <code class="code">x</code> and the x-coordinate in <code class="code">y</code>. This confusion is
a sad consequence of the C99-standard reversing the argument order for
<code class="code">atan2</code> for no good reason.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-hypot"><a href="#val-hypot" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>hypot : <a href="../Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">hypot ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes
<code class="code">sqrt(x*x + y*y)</code> of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise,
using <code class="code">incx</code> and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is
given, the result will be stored in there using increments of <code class="code">incz</code>,
otherwise a fresh vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-min2"><a href="#val-min2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>min2 : <a href="../Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">min2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes the
minimum of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code>
and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the result
will be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-max2"><a href="#val-max2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>max2 : <a href="../Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></div><div class="doc"><p><code class="code">max2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes the
maximum of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code>
and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the result
will be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
vector will be used. The resulting vector is returned.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incz</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = fresh vector with <code class="code">ofsz+(n - 1)(abs incz)</code> rows</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="h7">Miscellaneous functions</div><div class="spec val" id="val-log_sum_exp"><a href="#val-log_sum_exp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>log_sum_exp : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">log_sum_exp ?n ?ofsx ?incx x</code> computes the logarithm of the sum of
exponentials of the <code class="code">n</code> elements in vector <code class="code">x</code>, separated by <code class="code">incx</code>
incremental steps.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div></body></html>