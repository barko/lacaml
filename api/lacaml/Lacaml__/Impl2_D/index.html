<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Impl2_D (lacaml.Lacaml__.Impl2_D)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">lacaml</a> &#x00BB; <a href="../index.html">Lacaml__</a> &#x00BB; Impl2_D</nav><h1>Module <code>Lacaml__.Impl2_D</code></h1><nav class="toc"><ul><li><a href="#blas-1-interface">BLAS-1 interface</a></li><li><a href="#blas-2-interface">BLAS-2 interface</a></li><li><a href="#lapack-interface">LAPACK interface</a></li><li><a href="#auxiliary-routines">Auxiliary routines</a></li><li><a href="#linear-equations-(computational-routines)">Linear equations (computational routines)</a></li><li><a href="#least-squares-(expert-drivers)">Least squares (expert drivers)</a></li><li><a href="#general-schur-factorization">General Schur factorization</a></li><li><a href="#general-svd-routines">General SVD routines</a></li><li><a href="#general-eigenvalue-problem-(simple-drivers)">General eigenvalue problem (simple drivers)</a></li><li><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(simple-drivers)">Symmetric-matrix eigenvalue and singular value problems (simple drivers)</a></li><li><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(expert-&amp;-rrr-drivers)">Symmetric-matrix eigenvalue and singular value problems (expert &amp; RRR drivers)</a></li></ul></nav></header><section><header><h6 id="blas-1-interface"><a href="#blas-1-interface" class="anchor"></a>BLAS-1 interface</h6></header><dl><dt class="spec value" id="val-dot"><a href="#val-dot" class="anchor"></a><code><span class="keyword">val</span> dot : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>dot ?n ?ofsx ?incx x ?ofsy ?incy y</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asum"><a href="#val-asum" class="anchor"></a><code><span class="keyword">val</span> asum : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>asum ?n ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="blas-2-interface"><a href="#blas-2-interface" class="anchor"></a>BLAS-2 interface</h6></header><dl><dt class="spec value" id="val-sbmv"><a href="#val-sbmv" class="anchor"></a><code><span class="keyword">val</span> sbmv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></code></dt><dd><p><code>sbmv ?n ?k ?ofsy ?incy ?y ?ar ?ac a ?up ?alpha ?beta ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of available columns to the right of <code>ac</code>.</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of available rows in matrix <code>a</code> - 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = uninitialized vector of minimal length (see BLAS)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper band of <code>a</code> is supplied</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = 1.0</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = 0.0</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ger"><a href="#val-ger" class="anchor"></a><code><span class="keyword">val</span> ger : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ger ?m ?n ?alpha ?ofsx ?incx x ?ofsy ?incy y n ?ar ?ac a</code> see BLAS documentation!</p><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = 1.0</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syr"><a href="#val-syr" class="anchor"></a><code><span class="keyword">val</span> syr : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>syr ?n ?alpha ?up ?ofsx ?incx x ?ar ?ac a</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = 1.0</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is supplied</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="lapack-interface"><a href="#lapack-interface" class="anchor"></a>LAPACK interface</h6></header></section><section><header><h6 id="auxiliary-routines"><a href="#auxiliary-routines" class="anchor"></a>Auxiliary routines</h6></header><dl><dt class="spec value" id="val-lansy_min_lwork"><a href="#val-lansy_min_lwork" class="anchor"></a><code><span class="keyword">val</span> lansy_min_lwork : int <span>&#45;&gt;</span> <a href="../../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>lansy_min_lwork m norm</code></p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>lansy</code>-function.</p></dd></dl><dl><dt>parameter norm</dt><dd><p>type of norm that will be computed by <code>lansy</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns (and rows) in the matrix</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lansy"><a href="#val-lansy" class="anchor"></a><code><span class="keyword">val</span> lansy : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;norm:<a href="../../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>lansy ?norm ?up ?n ?ar ?ac ?work a</code> see LAPACK documentation!</p><dl><dt>parameter norm</dt><dd><p>default = `O</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (reference upper triangular part of <code>a</code>)</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = allocated work space for norm `I</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lamch"><a href="#val-lamch" class="anchor"></a><code><span class="keyword">val</span> lamch : <span>[ `E <span>| `S</span> <span>| `B</span> <span>| `P</span> <span>| `N</span> <span>| `R</span> <span>| `M</span> <span>| `U</span> <span>| `L</span> <span>| `O</span> ]</span> <span>&#45;&gt;</span> float</code></dt><dd><p><code>lamch cmach</code> see LAPACK documentation!</p></dd></dl></section><section><header><h6 id="linear-equations-(computational-routines)"><a href="#linear-equations-(computational-routines)" class="anchor"></a>Linear equations (computational routines)</h6></header><dl><dt class="spec value" id="val-orgqr_min_lwork"><a href="#val-orgqr_min_lwork" class="anchor"></a><code><span class="keyword">val</span> orgqr_min_lwork : <span>n:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>orgqr_min_lwork ~n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <code>orgqr</code>-function if the matrix has <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-orgqr_opt_lwork"><a href="#val-orgqr_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> orgqr_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>tau:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>orgqr_opt_lwork ?m ?n ?k ~tau ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <code>orgqr</code>-function given matrix <code>a</code>, optionally its logical dimensions <code>m</code> and <code>n</code>, and the number of reflectors <code>k</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = available number of elements in vector <code>tau</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-orgqr"><a href="#val-orgqr" class="anchor"></a><code><span class="keyword">val</span> orgqr : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>tau:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>orgqr ?m ?n ?k ?work ~tau ?ar ?ac a</code> see LAPACK documentation!</p><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = available number of elements in vector <code>tau</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ormqr_opt_lwork"><a href="#val-ormqr_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> ormqr_opt_lwork : <span>?&#8288;side:<a href="../../Lacaml/Common/index.html#type-side">Lacaml.Common.side</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>tau:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>ormqr_opt_lwork ?side ?trans ?m ?n ?k ~tau ?ar ?ac a ?cr ?cc c</code></p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <code>ormqr</code>-function given matrix <code>a</code> and <code>b</code>, optionally its logical dimensions <code>m</code> and <code>n</code>, and the number of reflectors <code>k</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = available number of elements in vector <code>tau</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ormqr"><a href="#val-ormqr" class="anchor"></a><code><span class="keyword">val</span> ormqr : <span>?&#8288;side:<a href="../../Lacaml/Common/index.html#type-side">Lacaml.Common.side</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>tau:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ormqr ?side ?trans ?m ?n ?k ?work ~tau ?ar ?ac a ?cr ?cc c</code> see LAPACK documentation!</p><dl><dt>parameter side</dt><dd><p>default = <code>`L</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = available number of elements in vector <code>tau</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gecon_min_lwork"><a href="#val-gecon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gecon_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>gecon_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>gecon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to the <code>gecon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gecon_min_liwork"><a href="#val-gecon_min_liwork" class="anchor"></a><code><span class="keyword">val</span> gecon_min_liwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>gecon_min_liwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the iwork array used by the <code>gecon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>gecon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gecon"><a href="#val-gecon" class="anchor"></a><code><span class="keyword">val</span> gecon : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;norm:<a href="../../Lacaml/Common/index.html#type-norm2">Lacaml.Common.norm2</a></span> <span>&#45;&gt;</span> <span>?&#8288;anorm:float</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>gecon ?n ?norm ?anorm ?work ?rwork ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>estimate of the reciprocal of the condition number of matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter norm</dt><dd><p>default = 1-norm</p></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = norm of the matrix <code>a</code> as returned by <code>lange</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sycon_min_lwork"><a href="#val-sycon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sycon_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>sycon_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>sycon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to the <code>sycon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sycon_min_liwork"><a href="#val-sycon_min_liwork" class="anchor"></a><code><span class="keyword">val</span> sycon_min_liwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>sycon_min_liwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the iwork array used by the <code>sycon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>sycon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sycon"><a href="#val-sycon" class="anchor"></a><code><span class="keyword">val</span> sycon : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;anorm:float</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sycon ?n ?up ?ipiv ?anorm ?work ?iwork ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>estimate of the reciprocal of the condition number of symmetric matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = upper triangle of the factorization of <code>a</code> is stored</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = 1-norm of the matrix <code>a</code> as returned by <code>lange</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = automatically allocated workspace</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pocon_min_lwork"><a href="#val-pocon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> pocon_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>pocon_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>pocon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to the <code>pocon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pocon_min_liwork"><a href="#val-pocon_min_liwork" class="anchor"></a><code><span class="keyword">val</span> pocon_min_liwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>pocon_min_liwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the iwork array used by the <code>pocon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>pocon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pocon"><a href="#val-pocon" class="anchor"></a><code><span class="keyword">val</span> pocon : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;anorm:float</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>pocon ?n ?up ?anorm ?work ?iwork ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>estimate of the reciprocal of the condition number of symmetric positive definite matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = upper triangle of Cholesky factorization of <code>a</code> is stored</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = 1-norm of the matrix <code>a</code> as returned by <code>lange</code></p></dd></dl></dd></dl></section><section><header><h6 id="least-squares-(expert-drivers)"><a href="#least-squares-(expert-drivers)" class="anchor"></a>Least squares (expert drivers)</h6></header><dl><dt class="spec value" id="val-gelsy_min_lwork"><a href="#val-gelsy_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsy_min_lwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> <span>nrhs:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsy_min_lwork ~m ~n ~nrhs</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <code>gelsy</code>-function if the logical dimensions of the matrix are <code>m</code> rows and <code>n</code> columns and if there are <code>nrhs</code> right hand side vectors.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsy_opt_lwork"><a href="#val-gelsy_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsy_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsy_opt_lwork ?m ?n ?ar ?ac a ?nrhs ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <code>gelsy</code>-function given matrix <code>a</code>, optionally its logical dimensions <code>m</code> and <code>n</code> and given right hand side matrix <code>b</code> with an optional number <code>nrhs</code> of vectors.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsy"><a href="#val-gelsy" class="anchor"></a><code><span class="keyword">val</span> gelsy : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;rcond:float</span> <span>&#45;&gt;</span> <span>?&#8288;jpvt:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsy ?m ?n ?ar ?ac a ?rcond ?jpvt ?ofswork ?work ?nrhs b</code> see LAPACK documentation! </p><dl><dt>returns</dt><dd><p>the effective rank of <code>a</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter rcond</dt><dd><p>default = (-1) =&gt; machine precision</p></dd></dl><dl><dt>parameter jpvt</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <code>gelsy_opt_lwork</code>)</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsd_min_lwork"><a href="#val-gelsd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsd_min_lwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> <span>nrhs:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsd_min_lwork ~m ~n ~nrhs</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <code>gelsd</code>-function if the logical dimensions of the matrix are <code>m</code> and <code>n</code> and if there are <code>nrhs</code> right hand side vectors.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsd_opt_lwork"><a href="#val-gelsd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsd_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsd_opt_lwork ?m ?n ?ar ?ac a ?nrhs b</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <code>gelsd</code>-function given matrix <code>a</code>, optionally its logical dimensions <code>m</code> and <code>n</code> and given right hand side matrix <code>b</code> with an optional number <code>nrhs</code> of vectors.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsd_min_iwork"><a href="#val-gelsd_min_iwork" class="anchor"></a><code><span class="keyword">val</span> gelsd_min_iwork : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsd_min_iwork m n</code> </p><dl><dt>returns</dt><dd><p>the minimum (= optimum) length of the iwork-array used by the <code>gelsd</code>-function if the logical dimensions of the matrix are <code>m</code> and <code>n</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsd"><a href="#val-gelsd" class="anchor"></a><code><span class="keyword">val</span> gelsd : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;rcond:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofss:int</span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsd ?m ?n ?rcond ?ofss ?s ?ofswork ?work ?ar ?ac a ?nrhs b</code> see LAPACK documentation!</p><dl><dt>returns</dt><dd><p>the effective rank of <code>a</code>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter rcond</dt><dd><p>default = (-1) =&gt; machine precision</p></dd></dl><dl><dt>parameter ofss</dt><dd><p>default = 1 or ignored if <code>s</code> is not given</p></dd></dl><dl><dt>parameter s</dt><dd><p>default = vec of length <code>min rows cols</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <code>gelsd_opt_lwork</code>)</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = vec of optimum (= minimum) length</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelss_min_lwork"><a href="#val-gelss_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gelss_min_lwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> <span>nrhs:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelss_min_lwork ~m ~n ~nrhs</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <code>gelss</code>-function if the logical dimensions of the matrix are <code>m</code> rows and <code>n</code> columns and if there are <code>nrhs</code> right hand side vectors.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelss_opt_lwork"><a href="#val-gelss_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gelss_opt_lwork : <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelss_opt_lwork ?ar ?ac a ?m ?n ?nrhs ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <code>gelss</code>-function given matrix <code>a</code>, optionally its logical dimensions <code>m</code> and <code>n</code> and given right hand side matrix <code>b</code> with an optional number <code>nrhs</code> of vectors.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelss"><a href="#val-gelss" class="anchor"></a><code><span class="keyword">val</span> gelss : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;rcond:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofss:int</span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelss ?m ?n ?rcond ?ofss ?s ?ofswork ?work ?ar ?ac a ?nrhs ?br ?bc b</code> see LAPACK documentation!</p><dl><dt>returns</dt><dd><p>the effective rank of <code>a</code>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter rcond</dt><dd><p>default = (-1) =&gt; machine precision</p></dd></dl><dl><dt>parameter ofss</dt><dd><p>default = 1 or ignored if <code>s</code> is not given</p></dd></dl><dl><dt>parameter s</dt><dd><p>default = vec of length <code>min m n</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <code>gelss_opt_lwork</code>)</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl></dd></dl></section><section><header><h6 id="general-schur-factorization"><a href="#general-schur-factorization" class="anchor"></a>General Schur factorization</h6></header><dl><dt class="spec value" id="val-gees"><a href="#val-gees" class="anchor"></a><code><span class="keyword">val</span> gees : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobvs:<a href="../../Lacaml/Common/index.html#type-schur_vectors">Lacaml.Common.schur_vectors</a></span> <span>&#45;&gt;</span> <span>?&#8288;sort:<a href="../../Lacaml/Common/index.html#type-eigen_value_sort">Lacaml.Common.eigen_value_sort</a></span> <span>&#45;&gt;</span> <span>?&#8288;wr:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;wi:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;vsr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vsc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vs:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int * <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> * <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> * <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>gees ?n ?jobvs ?sort ?w ?vsr ?vsc ?vs ?work ?ar ?ac a</code> See <code>gees</code>-function for details about arguments.</p><dl><dt>returns</dt><dd><p>(sdim, wr, wi, vs)</p></dd></dl></dd></dl></section><section><header><h6 id="general-svd-routines"><a href="#general-svd-routines" class="anchor"></a>General SVD routines</h6></header><dl><dt class="spec value" id="val-gesvd_min_lwork"><a href="#val-gesvd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gesvd_min_lwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gesvd_min_lwork ~m ~n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>gesvd</code>-function for matrices with <code>m</code> rows and <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesvd_opt_lwork"><a href="#val-gesvd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gesvd_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobu:<a href="../../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;jobvt:<a href="../../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ur:int</span> <span>&#45;&gt;</span> <span>?&#8288;uc:int</span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;vtr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vtc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vt:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-gesvd"><a href="#val-gesvd" class="anchor"></a><code><span class="keyword">val</span> gesvd : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobu:<a href="../../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;jobvt:<a href="../../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ur:int</span> <span>&#45;&gt;</span> <span>?&#8288;uc:int</span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;vtr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vtc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vt:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> * <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> * <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dt class="spec value" id="val-gesdd_liwork"><a href="#val-gesdd_liwork" class="anchor"></a><code><span class="keyword">val</span> gesdd_liwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-gesdd_min_lwork"><a href="#val-gesdd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gesdd_min_lwork : <span>?&#8288;jobz:<a href="../../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> int</code></dt><dd><p><code>gesdd_min_lwork ?jobz ~m ~n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>gesdd</code>-function for matrices with <code>m</code> rows and <code>n</code> columns for SVD-job <code>jobz</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesdd_opt_lwork"><a href="#val-gesdd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gesdd_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobz:<a href="../../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ur:int</span> <span>&#45;&gt;</span> <span>?&#8288;uc:int</span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;vtr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vtc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vt:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-gesdd"><a href="#val-gesdd" class="anchor"></a><code><span class="keyword">val</span> gesdd : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobz:<a href="../../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ur:int</span> <span>&#45;&gt;</span> <span>?&#8288;uc:int</span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;vtr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vtc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vt:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> * <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> * <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt></dl></section><section><header><h6 id="general-eigenvalue-problem-(simple-drivers)"><a href="#general-eigenvalue-problem-(simple-drivers)" class="anchor"></a>General eigenvalue problem (simple drivers)</h6></header><dl><dt class="spec value" id="val-geev_min_lwork"><a href="#val-geev_min_lwork" class="anchor"></a><code><span class="keyword">val</span> geev_min_lwork : <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>geev_min_lwork vectors n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>geev</code>-function. <code>vectors</code> indicates whether eigenvectors are supposed to be computed.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>geev</code>-function</p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = true</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geev_opt_lwork"><a href="#val-geev_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> geev_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vlr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vlc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vl:<span><a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;vrr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vrc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vr:<span><a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ofswr:int</span> <span>&#45;&gt;</span> <span>?&#8288;wr:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofswi:int</span> <span>&#45;&gt;</span> <span>?&#8288;wi:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>geev_opt_lwork
       ?n
       ?vlr ?vlc ?vl
       ?vrr ?vrc ?vr
       ?ofswr wr
       ?ofswi wi
       ?ar ?ac a</code> See <code>geev</code>-function for details about arguments.</p><dl><dt>returns</dt><dd><p>&quot;optimal&quot; size of work array.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geev"><a href="#val-geev" class="anchor"></a><code><span class="keyword">val</span> geev : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;vlr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vlc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vl:<span><a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;vrr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vrc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vr:<span><a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ofswr:int</span> <span>&#45;&gt;</span> <span>?&#8288;wr:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofswi:int</span> <span>&#45;&gt;</span> <span>?&#8288;wi:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> * <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> * <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> * <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>geev ?work ?n
      ?vlr ?vlc ?vl
      ?vrr ?vrc ?vr
      ?ofswr ?wr ?ofswi ?wi
      ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>(<code>lv</code>, <code>wr</code>, <code>wi</code>, <code>rv</code>), where <code>wr</code> and <code>wv</code> are the real and imaginary components of the eigenvalues, and <code>lv</code> and <code>rv</code> are the left and right eigenvectors. <code>lv</code> (<code>rv</code>) is the empty matrix if <code>vl</code> (<code>vr</code>) is set to <code>None</code>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter vl</dt><dd><p>default = Automatically allocated left eigenvectors. Pass <code>None</code> if you do not want to compute them, <code>Some lv</code> if you want to provide the storage. You can set <code>vlr</code>, <code>vlc</code> in the last case. (See LAPACK GEEV docs for details about storage of complex eigenvectors)</p></dd></dl><dl><dt>parameter vr</dt><dd><p>default = Automatically allocated right eigenvectors. Pass <code>None</code> if you do not want to compute them, <code>Some rv</code> if you want to provide the storage. You can set <code>vrr</code>, <code>vrc</code> in the last case.</p></dd></dl><dl><dt>parameter wr</dt><dd><p>default = vector of size <code>n</code>; real components of the eigenvalues</p></dd></dl><dl><dt>parameter wi</dt><dd><p>default = vector of size <code>n</code>; imaginary components of the eigenvalues</p></dd></dl><dl><dt>parameter a</dt><dd><p>the matrix whose eigensystem is computed</p></dd></dl></dd></dl></section><section><header><h6 id="symmetric-matrix-eigenvalue-and-singular-value-problems-(simple-drivers)"><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(simple-drivers)" class="anchor"></a>Symmetric-matrix eigenvalue and singular value problems (simple drivers)</h6></header><dl><dt class="spec value" id="val-syev_min_lwork"><a href="#val-syev_min_lwork" class="anchor"></a><code><span class="keyword">val</span> syev_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>syev_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <a href="index.html#val-syev"><code>syev</code></a>-function if the logical dimensions of the matrix are <code>n</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syev_opt_lwork"><a href="#val-syev_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> syev_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>syev_opt_lwork ?n ?vectors ?up ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <a href="index.html#val-syev"><code>syev</code></a>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syev"><a href="#val-syev" class="anchor"></a><code><span class="keyword">val</span> syev : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></code></dt><dd><p><code>syev ?n ?vectors ?up ?ofswork ?work ?ofsw ?w ?ar ?ac a</code> computes all eigenvalues and, optionally, eigenvectors of the real symmetric matrix <code>a</code>.</p><dl><dt>returns</dt><dd><p>the vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false i.e, eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <a href="index.html#val-syev_opt_lwork"><code>syev_opt_lwork</code></a>)</p></dd></dl><dl><dt>parameter ofsw</dt><dd><p>default = 1 or ignored if <code>w</code> is not given</p></dd></dl><dl><dt>parameter w</dt><dd><p>default = vec of length <code>n</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_min_lwork"><a href="#val-syevd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> syevd_min_lwork : <span>vectors:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevd_min_lwork vectors n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <a href="index.html#val-syevd"><code>syevd</code></a>-function if the logical dimensions of the matrix are <code>n</code> and given whether eigenvectors should be computed (<code>vectors</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_min_liwork"><a href="#val-syevd_min_liwork" class="anchor"></a><code><span class="keyword">val</span> syevd_min_liwork : <span>vectors:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevd_min_liwork vectors n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the iwork-array used by the <a href="index.html#val-syevd"><code>syevd</code></a>-function if the logical dimensions of the matrix are <code>n</code> and given whether eigenvectors should be computed (<code>vectors</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_opt_lwork"><a href="#val-syevd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> syevd_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevd_opt_lwork ?n ?vectors ?up ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <a href="index.html#val-syevd"><code>syevd</code></a>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_opt_liwork"><a href="#val-syevd_opt_liwork" class="anchor"></a><code><span class="keyword">val</span> syevd_opt_liwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevd_opt_liwork ?n ?vectors ?up ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the iwork-array used by the <a href="index.html#val-syevd"><code>syevd</code></a>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_opt_l_li_work"><a href="#val-syevd_opt_l_li_work" class="anchor"></a><code><span class="keyword">val</span> syevd_opt_l_li_work : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int * int</code></dt><dd><p><code>syevd_opt_l_li_iwork ?n ?vectors ?up ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the tuple of optimum lengths of the work- and iwork-arrays respectively, used by the <a href="index.html#val-syevd"><code>syevd</code></a>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd"><a href="#val-syevd" class="anchor"></a><code><span class="keyword">val</span> syevd : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></code></dt><dd><p><code>syevd ?n ?vectors ?up ?ofswork ?work ?iwork ?ofsw ?w ?ar ?ac a</code> computes all eigenvalues and, optionally, eigenvectors of the real symmetric matrix <code>a</code>. If eigenvectors are desired, it uses a divide and conquer algorithm.</p><dl><dt>returns</dt><dd><p>the vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false i.e, eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <a href="index.html#val-syev_opt_lwork"><code>syev_opt_lwork</code></a>)</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = int32_vec of optimum length (-&gt; <a href="index.html#val-syevd_opt_liwork"><code>syevd_opt_liwork</code></a>)</p></dd></dl><dl><dt>parameter ofsw</dt><dd><p>default = 1 or ignored if <code>w</code> is not given</p></dd></dl><dl><dt>parameter w</dt><dd><p>default = vec of length <code>n</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sbev_min_lwork"><a href="#val-sbev_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sbev_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>sbev_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <a href="index.html#val-sbev"><code>sbev</code></a>-function if the logical dimensions of the matrix are <code>n</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sbev"><a href="#val-sbev" class="anchor"></a><code><span class="keyword">val</span> sbev : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;kd:int</span> <span>&#45;&gt;</span> <span>?&#8288;zr:int</span> <span>&#45;&gt;</span> <span>?&#8288;zc:int</span> <span>&#45;&gt;</span> <span>?&#8288;z:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;abr:int</span> <span>&#45;&gt;</span> <span>?&#8288;abc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></code></dt><dd><p><code>sbev ?n ?vectors ?zr ?zc ?z ?up ?ofswork ?work ?ofsw ?w ?abr ?abc ab</code> computes all the eigenvalues and, optionally, eigenvectors of the real symmetric <i>band</i> matrix <code>ab</code>.</p><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>returns</dt><dd><p>the vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>ab</code></p></dd></dl><dl><dt>parameter z</dt><dd><p>matrix to contain the orthonormal eigenvectors of <code>ab</code>, the <code>i</code>-th column of <code>z</code> holding the eigenvector associated with <code>w.{i}</code>. default = <code>None</code> i.e, eigenvectors are not computed</p></dd></dl><dl><dt>parameter kd</dt><dd><p>default = number of rows in matrix <code>ab</code> - 1</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of the matrix is stored</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of minimal length (-&gt; <a href="index.html#val-sbev_min_lwork"><code>sbev_min_lwork</code></a>)</p></dd></dl><dl><dt>parameter ofsw</dt><dd><p>default = 1 or ignored if <code>w</code> is not given</p></dd></dl><dl><dt>parameter w</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter abr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter abc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="symmetric-matrix-eigenvalue-and-singular-value-problems-(expert-&amp;-rrr-drivers)"><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(expert-&amp;-rrr-drivers)" class="anchor"></a>Symmetric-matrix eigenvalue and singular value problems (expert &amp; RRR drivers)</h6></header><dl><dt class="spec value" id="val-syevr_min_lwork"><a href="#val-syevr_min_lwork" class="anchor"></a><code><span class="keyword">val</span> syevr_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevr_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <a href="index.html#val-syevr"><code>syevr</code></a>-function if the logical dimensions of the matrix are <code>n</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevr_min_liwork"><a href="#val-syevr_min_liwork" class="anchor"></a><code><span class="keyword">val</span> syevr_min_liwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevr_min_liwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the iwork-array used by the <a href="index.html#val-syevr"><code>syevr</code></a>-function if the logical dimensions of the matrix are <code>n</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevr_opt_lwork"><a href="#val-syevr_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> syevr_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;range:<span>[ `A <span><span>| `V</span> of float * float</span> <span><span>| `I</span> of int * int</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;abstol:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevr_opt_lwork ?n ?vectors ?range ?up ?abstol ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <a href="index.html#val-syevr"><code>syevr</code></a>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevr_opt_liwork"><a href="#val-syevr_opt_liwork" class="anchor"></a><code><span class="keyword">val</span> syevr_opt_liwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;range:<span>[ `A <span><span>| `V</span> of float * float</span> <span><span>| `I</span> of int * int</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;abstol:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>syevr_opt_liwork ?n ?vectors ?range ?up ?abstol ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the iwork-array used by the <a href="index.html#val-syevr"><code>syevr</code></a>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevr_opt_l_li_work"><a href="#val-syevr_opt_l_li_work" class="anchor"></a><code><span class="keyword">val</span> syevr_opt_l_li_work : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;range:<span>[ `A <span><span>| `V</span> of float * float</span> <span><span>| `I</span> of int * int</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;abstol:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int * int</code></dt><dd><p><code>syevr_opt_l_li_iwork ?n ?vectors ?range ?up ?abstol ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>the tuple of optimum lengths of the work- and iwork-arrays respectively, used by the <a href="index.html#val-syevr"><code>syevr</code></a>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevr"><a href="#val-syevr" class="anchor"></a><code><span class="keyword">val</span> syevr : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;range:<span>[ `A <span><span>| `V</span> of float * float</span> <span><span>| `I</span> of int * int</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;abstol:float</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;iwork:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;zr:int</span> <span>&#45;&gt;</span> <span>?&#8288;zc:int</span> <span>&#45;&gt;</span> <span>?&#8288;z:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;isuppz:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int * <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a> * <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> * <a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></code></dt><dd><p><code>syevr
      ?n ?vectors ?range ?up ?abstol ?work ?iwork
      ?ofsw ?w ?zr ?zc ?z ?isuppz ?ar ?ac a</code> <code>range</code> is either <code>`A</code> for computing all eigenpairs, <code>`V (vl, vu)</code> defines the lower and upper range of computed eigenvalues, <code>`I (il,
    iu)</code> defines the indexes of the computed eigenpairs, which are sorted in ascending order.</p><dl><dt>returns</dt><dd><p>the tuple <code>(m, w, z, isuppz)</code>, where <code>m</code> is the number of computed eigenpairs, vector <code>w</code> contains the computed eigenvalues in ascending order, <code>z</code> contains the computed eigenvectors in same order, and <code>isuppz</code> indicates the nonzero elements in <code>z</code>.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false i.e, eigenvectors are not computed</p></dd></dl><dl><dt>parameter range</dt><dd><p>default = `A</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter abstol</dt><dd><p>default = result of calling <code>lamch `S</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <a href="index.html#val-syev_opt_lwork"><code>syev_opt_lwork</code></a>)</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = int32_vec of optimum length (-&gt; <a href="index.html#val-syevr_opt_liwork"><code>syevr_opt_liwork</code></a>)</p></dd></dl><dl><dt>parameter ofsw</dt><dd><p>default = 1 or ignored if <code>w</code> is not given</p></dd></dl><dl><dt>parameter w</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter zr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter zc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = matrix with minimal required dimension</p></dd></dl><dl><dt>parameter isuppz</dt><dd><p>default = <code>int32_vec</code> with minimal required dimension</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sygv_opt_lwork"><a href="#val-sygv_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sygv_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;itype:<span>[ `A_B <span>| `AB</span> <span>| `BA</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>sygv_opt_lwork ?n ?vectors ?up ?ar ?ac a ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <a href="index.html#val-sygv"><code>sygv</code></a>-function for the given matrices <code>a</code> and <code>b</code>, optionally their logical dimension <code>n</code> and whether the eigenvectors must be computed (<code>vectors</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false, i.e. eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true, i.e. upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter itype</dt><dd><p>specifies the problem type to be solved:</p><ul><li><code>`A_B</code> (default): a*x = (lambda)*a*x</li><li><code>`AB</code>: a*b*x = (lambda)*x</li><li><code>`BA</code>: b*a*x = (lambda)*x</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-sygv"><a href="#val-sygv" class="anchor"></a><code><span class="keyword">val</span> sygv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vectors:bool</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;itype:<span>[ `A_B <span>| `AB</span> <span>| `BA</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></code></dt><dd><p><code>sygv ?n ?vectors ?up ?ofswork ?work ?ofsw ?w ?ar ?ac a ?br ?bc b</code> computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form <code>a*x=(lambda)*b*x</code>, <code>a*b*x=(lambda)*x</code>, or <code>b*a*x=(lambda)*x</code>. Here <code>a</code> and <code>b</code> are assumed to be symmetric and <code>b</code> is also positive definite.</p><dl><dt>returns</dt><dd><p>the vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter vectors</dt><dd><p>default = false i.e, eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <a href="index.html#val-sygv_opt_lwork"><code>sygv_opt_lwork</code></a>)</p></dd></dl><dl><dt>parameter ofsw</dt><dd><p>default = 1 or ignored if <code>w</code> is not given</p></dd></dl><dl><dt>parameter w</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter itype</dt><dd><p>specifies the problem type to be solved:</p><ul><li><code>`A_B</code> (default): a*x = (lambda)*a*x</li><li><code>`AB</code>: a*b*x = (lambda)*x</li><li><code>`BA</code>: b*a*x = (lambda)*x</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-sbgv"><a href="#val-sbgv" class="anchor"></a><code><span class="keyword">val</span> sbgv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ka:int</span> <span>&#45;&gt;</span> <span>?&#8288;kb:int</span> <span>&#45;&gt;</span> <span>?&#8288;zr:int</span> <span>&#45;&gt;</span> <span>?&#8288;zc:int</span> <span>&#45;&gt;</span> <span>?&#8288;z:<a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <a href="../Float64/index.html#type-vec">Lacaml__.Float64.vec</a></code></dt><dd><p><code>sbgv ?n ?ka ?kb ?zr ?zc ?z ?up ?work ?ofsw ?w ?ar ?ac a ?br ?bc b</code> computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite banded eigenproblem, of the form <code>a*x=(lambda)*b*x</code>. Here <code>a</code> and <code>b</code> are assumed to be symmetric and banded, and <code>b</code> is also positive definite.</p><dl><dt>returns</dt><dd><p>the vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter ka</dt><dd><p>the number of superdiagonals (or subdiagonals if <code>up = false</code>) of the matrix <code>a</code>. Default = <code>dim1 a - ar</code>.</p></dd></dl><dl><dt>parameter kb</dt><dd><p>same as <code>ka</code> but for the matrix <code>b</code>.</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = <code>None</code> i.e, eigenvectors are not computed</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code> i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (<code>3 * n</code>)</p></dd></dl><dl><dt>parameter ofsw</dt><dd><p>default = 1 or ignored if <code>w</code> is not given</p></dd></dl><dl><dt>parameter w</dt><dd><p>default = vec of length <code>n</code></p></dd></dl></dd></dl></section></div></body></html>