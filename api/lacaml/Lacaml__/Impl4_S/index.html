<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Impl4_S (lacaml.Lacaml__.Impl4_S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">lacaml</a> &#x00BB; <a href="../index.html">Lacaml__</a> &#x00BB; Impl4_S</nav><h1>Module <code>Lacaml__.Impl4_S</code></h1><nav class="toc"><ul><li><a href="#blas-1-interface">BLAS-1 interface</a></li><li><a href="#blas-2-interface">BLAS-2 interface</a></li><li><a href="#blas-3-interface">BLAS-3 interface</a></li><li><a href="#lapack-interface">LAPACK interface</a></li><li><a href="#auxiliary-routines">Auxiliary routines</a></li><li><a href="#linear-equations-(computational-routines)">Linear equations (computational routines)</a></li><li><a href="#linear-equations-(simple-drivers)">Linear equations (simple drivers)</a></li><li><a href="#least-squares-(simple-drivers)">Least squares (simple drivers)</a></li></ul></nav></header><section><header><h6 id="blas-1-interface"><a href="#blas-1-interface" class="anchor"></a>BLAS-1 interface</h6></header><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val</span> swap : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap ?n ?ofsx ?incx x ?ofsy ?incy y</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-scal"><a href="#val-scal" class="anchor"></a><code><span class="keyword">val</span> scal : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal ?n alpha ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>copy ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = new vector with <code>ofsy+(n-1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-nrm2"><a href="#val-nrm2" class="anchor"></a><code><span class="keyword">val</span> nrm2 : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>nrm2 ?n ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-axpy"><a href="#val-axpy" class="anchor"></a><code><span class="keyword">val</span> axpy : <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>axpy ?alpha ?n ?ofsx ?incx x ?ofsy ?incy y</code> see BLAS documentation!</p><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iamax"><a href="#val-iamax" class="anchor"></a><code><span class="keyword">val</span> iamax : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>iamax ?n ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-amax"><a href="#val-amax" class="anchor"></a><code><span class="keyword">val</span> amax : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>amax ?n ?ofsx ?incx x</code> </p><dl><dt>returns</dt><dd><p>the greater of the absolute values of the elements of the vector <code>x</code>.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="blas-2-interface"><a href="#blas-2-interface" class="anchor"></a>BLAS-2 interface</h6></header><dl><dt class="spec value" id="val-gemv"><a href="#val-gemv" class="anchor"></a><code><span class="keyword">val</span> gemv : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>gemv ?m ?n ?beta ?ofsy ?incy ?y ?trans ?alpha ?ar ?ac a ?ofsx ?incx x</code> performs the operation <code>y</code> := <code>alpha</code> * op(<code>a</code>) * <code>x</code> + <code>beta</code> * <code>y</code> where op(<code>a</code>) = <code>a</code> or <code>a</code>ᵀ according to the value of <code>trans</code>. See BLAS documentation for more information. BEWARE that the 1988 BLAS-2 specification mandates that this function has no effect when <code>n=0</code> while the mathematically expected behavior is <code>y ← beta * y</code>.</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of available rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>{ re = 0.; im = 0. }</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = vector with minimal required length (see BLAS)</p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gbmv"><a href="#val-gbmv" class="anchor"></a><code><span class="keyword">val</span> gbmv : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>gbmv
      ?m ?n ?beta ?ofsy ?incy ?y ?trans ?alpha ?ar ?ac a kl ku ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = same as <code>n</code> (i.e., <code>a</code> is a square matrix)</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>{ re = 0.; im = 0. }</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = vector with minimal required length (see BLAS)</p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-symv"><a href="#val-symv" class="anchor"></a><code><span class="keyword">val</span> symv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>symv ?n ?beta ?ofsy ?incy ?y ?up ?alpha ?ar ?ac a ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = dimension of symmetric matrix <code>a</code></p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>{ re = 0.; im = 0. }</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = vector with minimal required length (see BLAS)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trmv"><a href="#val-trmv" class="anchor"></a><code><span class="keyword">val</span> trmv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmv ?n ?trans ?diag ?up ?ar ?ac a ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = dimension of triangular matrix <code>a</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = false (not a unit triangular matrix)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trsv"><a href="#val-trsv" class="anchor"></a><code><span class="keyword">val</span> trsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trsv ?n ?trans ?diag ?up ?ar ?ac a ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = dimension of triangular matrix <code>a</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = false (not a unit triangular matrix)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tpmv"><a href="#val-tpmv" class="anchor"></a><code><span class="keyword">val</span> tpmv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ofsap:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tpmv ?n ?trans ?diag ?up ?ofsap ap ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = dimension of packed triangular matrix <code>ap</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = false (not a unit triangular matrix)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>ap</code> is accessed)</p></dd></dl><dl><dt>parameter ofsap</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tpsv"><a href="#val-tpsv" class="anchor"></a><code><span class="keyword">val</span> tpsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ofsap:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tpsv ?n ?trans ?diag ?up ?ofsap ap ?ofsx ?incx x</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = dimension of packed triangular matrix <code>ap</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = false (not a unit triangular matrix)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>ap</code> is accessed)</p></dd></dl><dl><dt>parameter ofsap</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="blas-3-interface"><a href="#blas-3-interface" class="anchor"></a>BLAS-3 interface</h6></header><dl><dt class="spec value" id="val-gemm"><a href="#val-gemm" class="anchor"></a><code><span class="keyword">val</span> gemm : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <span>?&#8288;c:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;transa:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;transb:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>gemm ?m ?n ?k ?beta ?cr ?cc ?c ?transa ?alpha ?ar ?ac a ?transb ?br ?bc b</code> performs the operation <code>c</code> := <code>alpha</code> * op(<code>a</code>) * op(<code>b</code>) + <code>beta</code> * <code>c</code> where op(<code>x</code>) = <code>x</code> or <code>x</code>ᵀ depending on <code>transx</code>. See BLAS documentation for more information.</p><dl><dt>returns</dt><dd><p>matrix <code>c</code>, which is overwritten.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and <code>c</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>b</code> (or tr <code>b</code>) and <code>c</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>{ re = 0.; im = 0. }</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = matrix with minimal required dimension</p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-symm"><a href="#val-symm" class="anchor"></a><code><span class="keyword">val</span> symm : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;side:<a href="../../Lacaml/Common/index.html#type-side">Lacaml.Common.side</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <span>?&#8288;c:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>symm ?m ?n ?side ?up ?beta ?cr ?cc ?c ?alpha ?ar ?ac a ?br ?bc b</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>matrix <code>c</code>, which is overwritten.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>c</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>c</code></p></dd></dl><dl><dt>parameter side</dt><dd><p>default = `L (left - multiplication is <code>a</code><code>b</code>)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>{ re = 0.; im = 0. }</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = matrix with minimal required dimension</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trmm"><a href="#val-trmm" class="anchor"></a><code><span class="keyword">val</span> trmm : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;side:<a href="../../Lacaml/Common/index.html#type-side">Lacaml.Common.side</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;transa:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmm ?m ?n ?side ?up ?transa ?diag ?alpha ?ar ?ac a ?br ?bc b</code> see BLAS documentation!</p><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>b</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>b</code></p></dd></dl><dl><dt>parameter side</dt><dd><p>default = `L (left - multiplication is <code>a</code><code>b</code>)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = `N (non-unit)</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trsm"><a href="#val-trsm" class="anchor"></a><code><span class="keyword">val</span> trsm : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;side:<a href="../../Lacaml/Common/index.html#type-side">Lacaml.Common.side</a></span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;transa:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trsm ?m ?n ?side ?up ?transa ?diag ?alpha ?ar ?ac ~a ?br ?bc b</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>matrix <code>b</code>, which is overwritten.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>b</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>b</code></p></dd></dl><dl><dt>parameter side</dt><dd><p>default = `L (left - multiplication is <code>a</code><code>b</code>)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = `N (non-unit)</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syrk"><a href="#val-syrk" class="anchor"></a><code><span class="keyword">val</span> syrk : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <span>?&#8288;c:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>syrk ?n ?k ?up ?beta ?cr ?cc ?c ?trans ?alpha ?ar ?ac a</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>matrix <code>c</code>, which is overwritten.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or <code>a</code>'), <code>c</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or <code>a</code>')</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>c</code> is accessed)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>{ re = 0.; im = 0. }</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = matrix with minimal required dimension</p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syr2k"><a href="#val-syr2k" class="anchor"></a><code><span class="keyword">val</span> syr2k : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <span>?&#8288;c:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>syr2k ?n ?k ?up ?beta ?cr ?cc ?c ?trans ?alpha ?ar ?ac a ?br ?bc b</code> see BLAS documentation!</p><dl><dt>returns</dt><dd><p>matrix <code>c</code>, which is overwritten.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or <code>a</code>'), <code>c</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or <code>a</code>')</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangular portion of <code>c</code> is accessed)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>{ re = 0.; im = 0. }</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = matrix with minimal required dimension</p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="lapack-interface"><a href="#lapack-interface" class="anchor"></a>LAPACK interface</h6></header></section><section><header><h6 id="auxiliary-routines"><a href="#auxiliary-routines" class="anchor"></a>Auxiliary routines</h6></header><dl><dt class="spec value" id="val-lacpy"><a href="#val-lacpy" class="anchor"></a><code><span class="keyword">val</span> lacpy : <span>?&#8288;uplo:<span>[ `U <span>| `L</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;patt:<a href="../../Lacaml__Float32/Types/Mat/index.html#type-patt">Lacaml__.Float32.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></dt><dd><p><code>lacpy ?patt ?uplo ?m ?n ?br ?bc ?b ?ar ?ac a</code> copy the (triangular) (sub-)matrix <code>a</code> (to an optional (sub-)matrix <code>b</code>) and return it. <code>patt</code> is more general than <code>uplo</code> and should be used in its place whenever strict BLAS conformance is not required. Only one of <code>patt</code> and <code>uplo</code> can be specified at a time.</p><dl><dt>raises Failure</dt><dd><p>if both <code>patt</code> and <code>uplo</code> are specified simultaneously</p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter uplo</dt><dd><p>default = whole matrix</p></dd></dl><dl><dt>parameter b</dt><dd><p>The target matrix. By default a fresh matrix to accommodate the sizes <code>m</code> and <code>n</code> and the offsets <code>br</code> and <code>bc</code> is created.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-laswp"><a href="#val-laswp" class="anchor"></a><code><span class="keyword">val</span> laswp : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;k1:int</span> <span>&#45;&gt;</span> <span>?&#8288;k2:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>laswp ?n ?ar ?ac a ?k1 ?k2 ?incx ipiv</code> swap rows of <code>a</code> according to <code>ipiv</code>. See LAPACK-documentation for details!</p><dl><dt>parameter n</dt><dd><p>default = number of columns of matrix</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter k1</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter k2</dt><dd><p>default = dimension of ipiv</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>is a vector of sequential row interchanges.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lapmt"><a href="#val-lapmt" class="anchor"></a><code><span class="keyword">val</span> lapmt : <span>?&#8288;forward:bool</span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>lapmt ?forward ?n ?m ?ar ?ac a k</code> swap columns of <code>a</code> according to the permutations in <code>k</code>. See LAPACK-documentation for details!</p><dl><dt>parameter forward</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of matrix</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of matrix</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter k</dt><dd><p>is vector of column permutations and must be of length <code>n</code>. Note that checking for duplicates in <code>k</code> is not performed and this could lead to <b>undefined</b> behavior. Furthermore, LAPACK uses <code>k</code> as a workspace and restore it upon completion, sharing this permutation array is not thread safe.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lassq"><a href="#val-lassq" class="anchor"></a><code><span class="keyword">val</span> lassq : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;scale:float</span> <span>&#45;&gt;</span> <span>?&#8288;sumsq:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float * float</code></dt><dd><p><code>lassq ?n ?ofsx ?incx ?scale ?sumsq</code> </p><dl><dt>returns</dt><dd><p><code>(scl, ssq)</code>, where <code>scl</code> is a scaling factor and <code>ssq</code> the sum of squares of vector <code>x</code> starting at <code>ofs</code> and using increment <code>incx</code> and initial <code>scale</code> and <code>sumsq</code>. The following equality holds: <code>scl**2. *. ssq = x.{1}**2. +. ... +. x.{n}**2. +. scale**2. *. sumsq</code>. See LAPACK-documentation for details!</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter scale</dt><dd><p>default = 0.</p></dd></dl><dl><dt>parameter sumsq</dt><dd><p>default = 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-larnv"><a href="#val-larnv" class="anchor"></a><code><span class="keyword">val</span> larnv : <span>?&#8288;idist:<span>[ `Uniform0 <span>| `Uniform1</span> <span>| `Normal</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;iseed:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;x:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>larnv ?idist ?iseed ?n ?ofsx ?x ()</code> </p><dl><dt>returns</dt><dd><p>a random vector with random distribution as specifified by <code>idist</code>, random seed <code>iseed</code>, vector offset <code>ofsx</code> and optional vector <code>x</code>.</p></dd></dl><dl><dt>parameter idist</dt><dd><p>default = <code>`Normal</code></p></dd></dl><dl><dt>parameter iseed</dt><dd><p>default = integer vector of size 4 with all ones.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>dim x - ofsx + 1</code> if <code>x</code> is provided, <code>1</code> otherwise.</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter x</dt><dd><p>default = vector of length <code>ofsx - 1 + n</code> if <code>n</code> is provided.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lange_min_lwork"><a href="#val-lange_min_lwork" class="anchor"></a><code><span class="keyword">val</span> lange_min_lwork : int <span>&#45;&gt;</span> <a href="../../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>lange_min_lwork m norm</code></p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>lange</code>-function.</p></dd></dl><dl><dt>parameter m</dt><dd><p>the number of rows in the matrix</p></dd></dl><dl><dt>parameter norm</dt><dd><p>type of norm that will be computed by <code>lange</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lange"><a href="#val-lange" class="anchor"></a><code><span class="keyword">val</span> lange : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;norm:<a href="../../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float32/index.html#type-rvec">Lacaml__.Float32.rvec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>lange ?m ?n ?norm ?work ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the value of the one norm (<code>norm = `O</code>), or the Frobenius norm (<code>norm = `F</code>), or the infinity norm (<code>norm = `I</code>), or the element of largest absolute value (<code>norm = `M</code>) of a real matrix <code>a</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter norm</dt><dd><p>default = <code>`O</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = allocated work space for norm <code>`I</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lauum"><a href="#val-lauum" class="anchor"></a><code><span class="keyword">val</span> lauum : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>lauum ?n ?up ?ar ?ac a</code> computes the product U * U**T or L**T * L, where the triangular factor U or L is stored in the upper or lower triangular part of the array <code>a</code>. The upper or lower part of <code>a</code> is overwritten.</p><dl><dt>parameter n</dt><dd><p>default = minimum of available number of rows/columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="linear-equations-(computational-routines)"><a href="#linear-equations-(computational-routines)" class="anchor"></a>Linear equations (computational routines)</h6></header><dl><dt class="spec value" id="val-getrf"><a href="#val-getrf" class="anchor"></a><code><span class="keyword">val</span> getrf : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></code></dt><dd><p><code>getrf ?m ?n ?ipiv ?ar ?ac a</code> computes an LU factorization of a general <code>m</code>-by-<code>n</code> matrix <code>a</code> using partial pivoting with row interchanges. See LAPACK documentation.</p><dl><dt>returns</dt><dd><p><code>ipiv</code>, the pivot indices.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>= vec of length <code>min(m, n)</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getrs"><a href="#val-getrs" class="anchor"></a><code><span class="keyword">val</span> getrs : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>getrs ?n ?ipiv ?trans ?ar ?ac a ?nrhs ?br ?bc b</code> solves a system of linear equations <code>a</code> * X = <code>b</code> or <code>a</code>' * X = <code>b</code> with a general <code>n</code>-by-<code>n</code> matrix <code>a</code> using the LU factorization computed by <a href="index.html#val-getrf"><code>getrf</code></a>. Note that matrix <code>a</code> will be passed to <a href="index.html#val-getrf"><code>getrf</code></a> if <code>ipiv</code> was not provided.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = result from <code>getrf</code> applied to <code>a</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getri_min_lwork"><a href="#val-getri_min_lwork" class="anchor"></a><code><span class="keyword">val</span> getri_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>getri_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <a href="index.html#val-getri"><code>getri</code></a>-function if the matrix has <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getri_opt_lwork"><a href="#val-getri_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> getri_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>getri_opt_lwork ?n ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimal size of the work array used by the <a href="index.html#val-getri"><code>getri</code></a>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getri"><a href="#val-getri" class="anchor"></a><code><span class="keyword">val</span> getri : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>getri ?n ?ipiv ?work ?ar ?ac a</code> computes the inverse of a matrix using the LU factorization computed by <a href="index.html#val-getrf"><code>getrf</code></a>. Note that matrix <code>a</code> will be passed to <a href="index.html#val-getrf"><code>getrf</code></a> if <code>ipiv</code> was not provided.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>m</code> from getri</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrf_min_lwork"><a href="#val-sytrf_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sytrf_min_lwork : unit <span>&#45;&gt;</span> int</code></dt><dd><p><code>sytrf_min_lwork ()</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <a href="index.html#val-sytrf"><code>sytrf</code></a>-function.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrf_opt_lwork"><a href="#val-sytrf_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sytrf_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>sytrf_opt_lwork ?n ?up ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimal size of the work array used by the <a href="index.html#val-sytrf"><code>sytrf</code></a>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (store upper triangle in <code>a</code>)</p></dd></dl><dl><dt>parameter a</dt><dd><p>the matrix <code>a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrf"><a href="#val-sytrf" class="anchor"></a><code><span class="keyword">val</span> sytrf : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></code></dt><dd><p><code>sytrf ?n ?up ?ipiv ?work ?ar ?ac a</code> computes the factorization of the real symmetric matrix <code>a</code> using the Bunch-Kaufman diagonal pivoting method.</p><dl><dt>raises Failure</dt><dd><p>if D in <code>a</code> = U*D*U' or L*D*L' is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (store upper triangle in <code>a</code>)</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>= vec of length n</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrs"><a href="#val-sytrs" class="anchor"></a><code><span class="keyword">val</span> sytrs : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sytrs ?n ?up ?ipiv ?ar ?ac a ?nrhs ?br ?bc b</code> solves a system of linear equations <code>a</code>*X = <code>b</code> with a real symmetric matrix <code>a</code> using the factorization <code>a</code> = U*D*U**T or <code>a</code> = L*D*L**T computed by <a href="index.html#val-sytrf"><code>sytrf</code></a>. Note that matrix <code>a</code> will be passed to <a href="index.html#val-sytrf"><code>sytrf</code></a> if <code>ipiv</code> was not provided.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (store upper triangle in <code>a</code>)</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytri_min_lwork"><a href="#val-sytri_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sytri_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>sytri_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <a href="index.html#val-sytri"><code>sytri</code></a>-function if the matrix has <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytri"><a href="#val-sytri" class="anchor"></a><code><span class="keyword">val</span> sytri : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sytri ?n ?up ?ipiv ?work ?ar ?ac a</code> computes the inverse of the real symmetric indefinite matrix <code>a</code> using the factorization <code>a</code> = U*D*U**T or <code>a</code> = L*D*L**T computed by <a href="index.html#val-sytrf"><code>sytrf</code></a>. Note that matrix <code>a</code> will be passed to <a href="index.html#val-sytrf"><code>sytrf</code></a> if <code>ipiv</code> was not provided.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (store upper triangle in <code>a</code>)</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code> from <a href="index.html#val-sytrf"><code>sytrf</code></a></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potrf"><a href="#val-potrf" class="anchor"></a><code><span class="keyword">val</span> potrf : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrf ?n ?up ?ar ?ac a</code> factorizes symmetric positive definite matrix <code>a</code> (or the designated submatrix) using Cholesky factorization.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (store upper triangle in <code>a</code>)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potrs"><a href="#val-potrs" class="anchor"></a><code><span class="keyword">val</span> potrs : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrs ?n ?up ?ar ?ac a ?nrhs ?br ?bc b</code> solves a system of linear equations <code>a</code>*X = <code>b</code>, where <code>a</code> is symmetric positive definite matrix, using the Cholesky factorization <code>a</code> = U**T*U or <code>a</code> = L*L**T computed by <a href="index.html#val-potrf"><code>potrf</code></a>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potri"><a href="#val-potri" class="anchor"></a><code><span class="keyword">val</span> potri : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potri ?n ?up ?ar ?ac a</code> computes the inverse of the real symmetric positive definite matrix <code>a</code> using the Cholesky factorization <code>a</code> = U**T*U or <code>a</code> = L*L**T computed by <a href="index.html#val-potrf"><code>potrf</code></a>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangle stored in <code>a</code>)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trtrs"><a href="#val-trtrs" class="anchor"></a><code><span class="keyword">val</span> trtrs : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trtrs ?n ?up ?trans ?diag ?ar ?ac a ?nrhs ?br ?bc b</code> solves a triangular system of the form <code>a</code> * X = <code>b</code> or <code>a</code>**T * X = <code>n</code>, where <code>a</code> is a triangular matrix of order <code>n</code>, and <code>b</code> is an <code>n</code>-by-<code>nrhs</code> matrix.</p><dl><dt>raises Failure</dt><dd><p>if the matrix <code>a</code> is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tbtrs"><a href="#val-tbtrs" class="anchor"></a><code><span class="keyword">val</span> tbtrs : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;kd:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../Float32/index.html#type-trans3">Lacaml__.Float32.trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;abr:int</span> <span>&#45;&gt;</span> <span>?&#8288;abc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tbtrs ?n ?kd ?up ?trans ?diag ?abr ?abc ab ?nrhs ?br ?bc b</code> solves a triangular system of the form <code>a</code> * X = <code>b</code> or <code>a</code>**T * X = <code>b</code>, where <code>a</code> is a triangular band matrix of order <code>n</code>, and <code>b</code> is an <code>n</code>-by-<code>nrhs</code> matrix.</p><dl><dt>raises Failure</dt><dd><p>if the matrix <code>a</code> is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>ab</code></p></dd></dl><dl><dt>parameter kd</dt><dd><p>default = number of rows in matrix <code>ab</code> - 1</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter abr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter abc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trtri"><a href="#val-trtri" class="anchor"></a><code><span class="keyword">val</span> trtri : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;diag:<a href="../../Lacaml/Common/index.html#type-diag">Lacaml.Common.diag</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trtri ?n ?up ?diag ?ar ?ac a</code> computes the inverse of a real upper or lower triangular matrix <code>a</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix <code>a</code> is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (upper triangle stored in <code>a</code>)</p></dd></dl><dl><dt>parameter diag</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geqrf_opt_lwork"><a href="#val-geqrf_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> geqrf_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>geqrf_opt_lwork ?m ?n ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <a href="index.html#val-geqrf"><code>geqrf</code></a>-function given matrix <code>a</code> and optionally its logical dimensions <code>m</code> and <code>n</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geqrf_min_lwork"><a href="#val-geqrf_min_lwork" class="anchor"></a><code><span class="keyword">val</span> geqrf_min_lwork : <span>n:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>geqrf_min_lwork ~n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <a href="index.html#val-geqrf"><code>geqrf</code></a>-function if the matrix has <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geqrf"><a href="#val-geqrf" class="anchor"></a><code><span class="keyword">val</span> geqrf : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;tau:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>geqrf ?m ?n ?work ?tau ?ar ?ac a</code> computes a QR factorization of a real <code>m</code>-by-<code>n</code> matrix <code>a</code>. See LAPACK documentation.</p><dl><dt>returns</dt><dd><p><code>tau</code>, the scalar factors of the elementary reflectors.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length</p></dd></dl><dl><dt>parameter tau</dt><dd><p>default = vec of required length</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="linear-equations-(simple-drivers)"><a href="#linear-equations-(simple-drivers)" class="anchor"></a>Linear equations (simple drivers)</h6></header><dl><dt class="spec value" id="val-gesv"><a href="#val-gesv" class="anchor"></a><code><span class="keyword">val</span> gesv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gesv ?n ?ipiv ?ar ?ac a ?nrhs ?br ?bc b</code> computes the solution to a real system of linear equations <code>a</code> * X = <code>b</code>, where <code>a</code> is an <code>n</code>-by-<code>n</code> matrix and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. The LU decomposition with partial pivoting and row interchanges is used to factor <code>a</code> as <code>a</code> = P * L * U, where P is a permutation matrix, L is unit lower triangular, and U is upper triangular. The factored form of <code>a</code> is then used to solve the system of equations <code>a</code> * X = <code>b</code>. On exit, <code>b</code> contains the solution matrix X.</p><dl><dt>raises Failure</dt><dd><p>if the matrix <code>a</code> is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gbsv"><a href="#val-gbsv" class="anchor"></a><code><span class="keyword">val</span> gbsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;abr:int</span> <span>&#45;&gt;</span> <span>?&#8288;abc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gbsv ?n ?ipiv ?abr ?abc ab kl ku ?nrhs ?br ?bc b</code> computes the solution to a real system of linear equations <code>a</code> * X = <code>b</code>, where <code>a</code> is a band matrix of order <code>n</code> with <code>kl</code> subdiagonals and <code>ku</code> superdiagonals, and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. The LU decomposition with partial pivoting and row interchanges is used to factor <code>a</code> as <code>a</code> = L * U, where L is a product of permutation and unit lower triangular matrices with <code>kl</code> subdiagonals, and U is upper triangular with <code>kl+ku</code> superdiagonals. The factored form of <code>a</code> is then used to solve the system of equations <code>a</code> * X = <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix <code>a</code> is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>ab</code></p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter abr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter abc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gtsv"><a href="#val-gtsv" class="anchor"></a><code><span class="keyword">val</span> gtsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsdl:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsd:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsdu:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gtsv ?n ?ofsdl dl ?ofsd d ?ofsdu du ?nrhs ?br ?bc b</code> solves the equation <code>a</code> * X = <code>b</code> where <code>a</code> is an <code>n</code>-by-<code>n</code> tridiagonal matrix, by Gaussian elimination with partial pivoting. Note that the equation <code>A</code>'*X = <code>b</code> may be solved by interchanging the order of the arguments <code>du</code> and <code>dl</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available length of vector <code>d</code></p></dd></dl><dl><dt>parameter ofsdl</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsd</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsdu</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-posv"><a href="#val-posv" class="anchor"></a><code><span class="keyword">val</span> posv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>posv ?n ?up ?ar ?ac a ?nrhs ?br ?bc b</code> computes the solution to a real system of linear equations <code>a</code> * X = <code>b</code>, where <code>a</code> is an <code>n</code>-by-<code>n</code> symmetric positive definite matrix and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. The Cholesky decomposition is used to factor <code>a</code> as <code>a</code> = U**T * U, if <code>up = true</code>, or <code>a</code> = L * L**T, if <code>up = false</code>, where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of <code>a</code> is then used to solve the system of equations <code>a</code> * X = <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ppsv"><a href="#val-ppsv" class="anchor"></a><code><span class="keyword">val</span> ppsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ofsap:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ppsv ?n ?up ?ofsap ap ?nrhs ?br ?bc b</code> computes the solution to the real system of linear equations <code>a</code> * X = <code>b</code>, where <code>a</code> is an <code>n</code>-by-<code>n</code> symmetric positive definite matrix stored in packed format and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. The Cholesky decomposition is used to factor <code>a</code> as <code>a</code> = U**T * U, if <code>up = true</code>, or <code>a</code> = L * L**T, if <code>up = false</code>, where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of <code>a</code> is then used to solve the system of equations <code>a</code> * X = <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = the greater n s.t. n(n+1)/2 &lt;= <code>Vec.dim ap</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>ap</code> is stored</p></dd></dl><dl><dt>parameter ofsap</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pbsv"><a href="#val-pbsv" class="anchor"></a><code><span class="keyword">val</span> pbsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;kd:int</span> <span>&#45;&gt;</span> <span>?&#8288;abr:int</span> <span>&#45;&gt;</span> <span>?&#8288;abc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pbsv ?n ?up ?kd ?abr ?abc ab ?nrhs ?br ?bc b</code> computes the solution to a real system of linear equations <code>a</code> * X = <code>b</code>, where <code>a</code> is an <code>n</code>-by-<code>n</code> symmetric positive definite band matrix and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. The Cholesky decomposition is used to factor <code>a</code> as <code>a</code> = U**T * U, if <code>up = true</code>, or <code>a</code> = L * L**T, if <code>up = false</code>, where U is an upper triangular band matrix, and L is a lower triangular band matrix, with the same number of superdiagonals or subdiagonals as <code>a</code>. The factored form of <code>a</code> is then used to solve the system of equations <code>a</code> * X = <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>ab</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>ab</code> is stored</p></dd></dl><dl><dt>parameter kd</dt><dd><p>default = available number of rows in matrix <code>ab</code> - 1</p></dd></dl><dl><dt>parameter abr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter abc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ptsv"><a href="#val-ptsv" class="anchor"></a><code><span class="keyword">val</span> ptsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsd:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-rvec">Lacaml__.Float32.rvec</a> <span>&#45;&gt;</span> <span>?&#8288;ofse:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ptsv ?n ?ofsd d ?ofse e ?nrhs ?br ?bc b</code> computes the solution to the real system of linear equations <code>a</code>*X = <code>b</code>, where <code>a</code> is an <code>n</code>-by-<code>n</code> symmetric positive definite tridiagonal matrix, and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. A is factored as <code>a</code> = L*D*L**T, and the factored form of <code>a</code> is then used to solve the system of equations.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available length of vector <code>d</code></p></dd></dl><dl><dt>parameter ofsd</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofse</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sysv_opt_lwork"><a href="#val-sysv_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sysv_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>sysv_opt_lwork ?n ?up ?ar ?ac a ?nrhs ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <code>sysv</code>-function given matrix <code>a</code>, optionally its logical dimension <code>n</code> and given right hand side matrix <code>b</code> with an optional number <code>nrhs</code> of vectors.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sysv"><a href="#val-sysv" class="anchor"></a><code><span class="keyword">val</span> sysv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sysv ?n ?up ?ipiv ?work ?ar ?ac a ?nrhs ?br ?bc b</code> computes the solution to a real system of linear equations <code>a</code> * X = <code>b</code>, where <code>a</code> is an N-by-N symmetric matrix and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. The diagonal pivoting method is used to factor <code>a</code> as <code>a</code> = U * D * U**T, if <code>up = true</code>, or <code>a</code> = L * D * L**T, if <code>up = false</code>, where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of <code>a</code> is then used to solve the system of equations <code>a</code> * X = <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>a</code> is stored</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <code>sysv_opt_lwork</code>)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-spsv"><a href="#val-spsv" class="anchor"></a><code><span class="keyword">val</span> spsv : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsap:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>spsv ?n ?up ?ipiv ?ofsap ap ?nrhs ?br ?bc b</code> computes the solution to the real system of linear equations <code>a</code> * X = <code>b</code>, where <code>a</code> is an <code>n</code>-by-<code>n</code> symmetric matrix stored in packed format and X and <code>b</code> are <code>n</code>-by-<code>nrhs</code> matrices. The diagonal pivoting method is used to factor <code>a</code> as <code>a</code> = U * D * U**T, if <code>up = true</code>, or <code>a</code> = L * D * L**T, if <code>up = false</code>, where U (or L) is a product of permutation and unit upper (lower) triangular matrices, D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of <code>a</code> is then used to solve the system of equations <code>a</code> * X = <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = the greater n s.t. n(n+1)/2 &lt;= <code>Vec.dim ap</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true i.e., upper triangle of <code>ap</code> is stored</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter ofsap</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="least-squares-(simple-drivers)"><a href="#least-squares-(simple-drivers)" class="anchor"></a>Least squares (simple drivers)</h6></header><dl><dt class="spec value" id="val-gels_min_lwork"><a href="#val-gels_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gels_min_lwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> <span>nrhs:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gels_min_lwork ~m ~n ~nrhs</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work-array used by the <code>gels</code>-function if the logical dimensions of the matrix are <code>m</code> rows and <code>n</code> columns and if there are <code>nrhs</code> right hand side vectors.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gels_opt_lwork"><a href="#val-gels_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gels_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gels_opt_lwork ?m ?n ?trans ?ar ?ac a ?nrhs ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the optimum length of the work-array used by the <code>gels</code>-function given matrix <code>a</code>, optionally its logical dimensions <code>m</code> and <code>n</code> and given right hand side matrix <code>b</code> with an optional number <code>nrhs</code> of vectors.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns in matrix <code>a</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gels"><a href="#val-gels" class="anchor"></a><code><span class="keyword">val</span> gels : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> <span>?&#8288;nrhs:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gels ?m ?n ?work ?trans ?ar ?ac a ?nrhs ?br ?bc b</code> see LAPACK documentation!</p><dl><dt>parameter m</dt><dd><p>default = available number of rows in matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = vec of optimum length (-&gt; <a href="index.html#val-gels_opt_lwork"><code>gels_opt_lwork</code></a>)</p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = `N</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>default = available number of columns in matrix <code>b</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section></div></body></html>