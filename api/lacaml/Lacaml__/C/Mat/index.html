<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mat (lacaml.Lacaml__.C.Mat)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">lacaml</a> &#x00BB; <a href="../../index.html">Lacaml__</a> &#x00BB; <a href="../index.html">C</a> &#x00BB; Mat</nav><h1>Module <code>C.Mat</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="../index.html#type-mat">mat</a></code></dt></dl><section><header><h4 id="matrix-operations"><a href="#matrix-operations" class="anchor"></a>Matrix operations</h4></header></section><section><header><h4 id="creation-of-matrices"><a href="#creation-of-matrices" class="anchor"></a>Creation of matrices</h4></header><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val </span>random : ?&#8288;rnd_state:Stdlib.Random.State.t <span>&#45;&gt;</span> ?&#8288;re_from:float <span>&#45;&gt;</span> ?&#8288;re_range:float <span>&#45;&gt;</span> ?&#8288;im_from:float <span>&#45;&gt;</span> ?&#8288;im_range:float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>random ?rnd_state ?re_from ?re_range ?im_from ?im_range m n</code></p><dl><dt>returns</dt><dd><p>an <code>m</code>x<code>n</code> matrix initialized with random elements sampled uniformly from <code>re_range</code> and <code>im_range</code> starting at <code>re_from</code> and <code>im_from</code> for real and imaginary numbers respectively. A random state <code>rnd_state</code> can be passed.</p></dd></dl><dl><dt>parameter rnd_state</dt><dd><p>default = Random.get_state ()</p></dd></dl><dl><dt>parameter re_from</dt><dd><p>default = -1.0</p></dd></dl><dl><dt>parameter re_range</dt><dd><p>default = 2.0</p></dd></dl><dl><dt>parameter im_from</dt><dd><p>default = -1.0</p></dd></dl><dl><dt>parameter im_range</dt><dd><p>default = 2.0</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-patt"><a href="#type-patt" class="anchor"></a><code><span class="keyword">type </span>patt</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-patt.Full" class="anchored"><td class="def constructor"><a href="#type-patt.Full" class="anchor"></a><code><span class="keyword">| </span></code><code>`Full</code></td></tr><tr id="type-patt.Utr" class="anchored"><td class="def constructor"><a href="#type-patt.Utr" class="anchor"></a><code><span class="keyword">| </span></code><code>`Utr</code></td></tr><tr id="type-patt.Ltr" class="anchored"><td class="def constructor"><a href="#type-patt.Ltr" class="anchor"></a><code><span class="keyword">| </span></code><code>`Ltr</code></td></tr><tr id="type-patt.Upent" class="anchored"><td class="def constructor"><a href="#type-patt.Upent" class="anchor"></a><code><span class="keyword">| </span></code><code>`Upent<span class="keyword"> of </span>int</code></td></tr><tr id="type-patt.Lpent" class="anchored"><td class="def constructor"><a href="#type-patt.Lpent" class="anchor"></a><code><span class="keyword">| </span></code><code>`Lpent<span class="keyword"> of </span>int</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span class="keyword">type </span>unop</code><code><span class="keyword"> = </span>?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec type" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span class="keyword">type </span>binop</code><code><span class="keyword"> = </span>?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;cr:int <span>&#45;&gt;</span> ?&#8288;cc:int <span>&#45;&gt;</span> ?&#8288;c:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt></dl></section><section><header><h4 id="creation-of-matrices-and-accessors"><a href="#creation-of-matrices-and-accessors" class="anchor"></a>Creation of matrices and accessors</h4></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-make0"><a href="#val-make0" class="anchor"></a><code><span class="keyword">val </span>make0 : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val </span>of_array : Stdlib.Complex.t array array <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t array array</code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : Stdlib.Complex.t list list <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t list list</code></dt><dt class="spec value" id="val-of_col_vecs"><a href="#val-of_col_vecs" class="anchor"></a><code><span class="keyword">val </span>of_col_vecs : <a href="../index.html#type-vec">vec</a> array <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_col_vecs"><a href="#val-to_col_vecs" class="anchor"></a><code><span class="keyword">val </span>to_col_vecs : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> array</code></dt><dt class="spec value" id="val-of_col_vecs_list"><a href="#val-of_col_vecs_list" class="anchor"></a><code><span class="keyword">val </span>of_col_vecs_list : <a href="../index.html#type-vec">vec</a> list <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_col_vecs_list"><a href="#val-to_col_vecs_list" class="anchor"></a><code><span class="keyword">val </span>to_col_vecs_list : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> list</code></dt><dt class="spec value" id="val-as_vec"><a href="#val-as_vec" class="anchor"></a><code><span class="keyword">val </span>as_vec : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-init_rows"><a href="#val-init_rows" class="anchor"></a><code><span class="keyword">val </span>init_rows : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Complex.t) <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-init_cols"><a href="#val-init_cols" class="anchor"></a><code><span class="keyword">val </span>init_cols : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Complex.t) <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-create_mvec"><a href="#val-create_mvec" class="anchor"></a><code><span class="keyword">val </span>create_mvec : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-make_mvec"><a href="#val-make_mvec" class="anchor"></a><code><span class="keyword">val </span>make_mvec : int <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-mvec_of_array"><a href="#val-mvec_of_array" class="anchor"></a><code><span class="keyword">val </span>mvec_of_array : Stdlib.Complex.t array <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-mvec_to_array"><a href="#val-mvec_to_array" class="anchor"></a><code><span class="keyword">val </span>mvec_to_array : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t array</code></dt><dt class="spec value" id="val-from_col_vec"><a href="#val-from_col_vec" class="anchor"></a><code><span class="keyword">val </span>from_col_vec : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-from_row_vec"><a href="#val-from_row_vec" class="anchor"></a><code><span class="keyword">val </span>from_row_vec : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>empty</code>, the empty matrix.</p></dd></dl><dl><dt class="spec value" id="val-identity"><a href="#val-identity" class="anchor"></a><code><span class="keyword">val </span>identity : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-of_diag"><a href="#val-of_diag" class="anchor"></a><code><span class="keyword">val </span>of_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-dim1"><a href="#val-dim1" class="anchor"></a><code><span class="keyword">val </span>dim1 : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-dim2"><a href="#val-dim2" class="anchor"></a><code><span class="keyword">val </span>dim2 : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><code><span class="keyword">val </span>has_zero_dim : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_zero_dim mat</code> checks whether matrix <code>mat</code> has a dimension of size <code>zero</code>. In this case it cannot contain data.</p></dd></dl><dl><dt class="spec value" id="val-col"><a href="#val-col" class="anchor"></a><code><span class="keyword">val </span>col : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-copy_row"><a href="#val-copy_row" class="anchor"></a><code><span class="keyword">val </span>copy_row : ?&#8288;vec:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt></dl></section><section><header><h4 id="matrix-transformations"><a href="#matrix-transformations" class="anchor"></a>Matrix transformations</h4></header><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val </span>swap : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> swaps the contents of (sub-matrices) <code>a</code> and <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-transpose_copy"><a href="#val-transpose_copy" class="anchor"></a><code><span class="keyword">val </span>transpose_copy : ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-detri"><a href="#val-detri" class="anchor"></a><code><span class="keyword">val </span>detri : ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>detri ?up ?n ?ar ?ac a</code> takes a triangular (sub-)matrix <code>a</code>, i.e. one where only the upper (iff <code>up</code> is true) or lower triangle is defined, and makes it a symmetric matrix by mirroring the defined triangle along the diagonal.</p><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-packed"><a href="#val-packed" class="anchor"></a><code><span class="keyword">val </span>packed : ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-unpacked"><a href="#val-unpacked" class="anchor"></a><code><span class="keyword">val </span>unpacked : ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt></dl></section><section><header><h4 id="operations-on-one-matrix"><a href="#operations-on-one-matrix" class="anchor"></a>Operations on one matrix</h4></header><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val </span>fill : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill ?patt ?m ?n ?ar ?ac a x</code> fills the specified sub-matrix in <code>a</code> with value <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val </span>sum : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>sum ?patt ?m ?n ?ar ?ac a</code> computes the sum of all elements in the <code>m</code>-by-<code>n</code> submatrix using pattern <code>patt</code>, starting at row <code>ar</code> and column <code>ac</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_const"><a href="#val-add_const" class="anchor"></a><code><span class="keyword">val </span>add_const : Stdlib.Complex.t <span>&#45;&gt;</span> <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>add_const c ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> adds constant <code>c</code> to the designated <code>m</code> by <code>n</code> submatrix in <code>a</code> using pattern <code>patt</code> and stores the result in the designated submatrix in <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = <code>Mat.dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size <code>m</code> by <code>n</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_const_diag"><a href="#val-add_const_diag" class="anchor"></a><code><span class="keyword">val </span>add_const_diag : Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_const c ?n ?ar ?ac a</code> adds constant <code>c</code> to the diagonal of the designated <code>n</code> by <code>n</code> submatrix in <code>a</code>.</p><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val </span>neg : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>neg ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the negative of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reci"><a href="#val-reci" class="anchor"></a><code><span class="keyword">val </span>reci : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>reci ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the reciprocal of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy_diag"><a href="#val-copy_diag" class="anchor"></a><code><span class="keyword">val </span>copy_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span class="keyword">val </span>trace : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dt class="spec value" id="val-scal"><a href="#val-scal" class="anchor"></a><code><span class="keyword">val </span>scal : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal ?patt ?m ?n alpha ?ar ?ac a</code> BLAS <code>scal</code> function for (sub-)matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_cols"><a href="#val-scal_cols" class="anchor"></a><code><span class="keyword">val </span>scal_cols : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ofs:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_cols ?patt ?m ?n ?ar ?ac a ?ofs alphas</code> column-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_rows"><a href="#val-scal_rows" class="anchor"></a><code><span class="keyword">val </span>scal_rows : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofs:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_rows ?patt ?m ?n ?ofs alphas ?ar ?ac a</code> row-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-syrk_trace"><a href="#val-syrk_trace" class="anchor"></a><code><span class="keyword">val </span>syrk_trace : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>syrk_trace ?n ?k ?ar ?ac a</code> computes the trace of either <code>a' * a</code> or <code>a * a'</code>, whichever is more efficient (results are identical), of the (sub-)matrix <code>a</code> multiplied by its own transpose. This is the same as the square of the Frobenius norm of a matrix. <code>n</code> is the number of rows to consider in <code>a</code>, and <code>k</code> the number of columns to consider.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syrk_diag"><a href="#val-syrk_diag" class="anchor"></a><code><span class="keyword">val </span>syrk_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;beta:Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;trans:<a href="../../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a> <span>&#45;&gt;</span> ?&#8288;alpha:Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>syrk_diag ?n ?k ?beta ?ofsy ?y ?trans ?alpha ?ar ?ac a</code> computes the diagonal of the symmetric rank-k product of the (sub-)matrix <code>a</code>, multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrix will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl></section><section><header><h4 id="operations-on-two-matrices"><a href="#operations-on-two-matrices" class="anchor"></a>Operations on two matrices</h4></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val </span>add : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>add ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the sum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>sub ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the difference of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val </span>mul : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>mul ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the element-wise product of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><p>NOTE: please do not confuse this function with matrix multiplication! The LAPACK-function for matrix multiplication is called <code>gemm</code>, e.g. <code>Lacaml.D.gemm</code>.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val </span>div : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>div ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the division of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-axpy"><a href="#val-axpy" class="anchor"></a><code><span class="keyword">val </span>axpy : ?&#8288;alpha:Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;xr:int <span>&#45;&gt;</span> ?&#8288;xc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;yr:int <span>&#45;&gt;</span> ?&#8288;yc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>axpy ?alpha ?patt ?m ?n ?xr ?xc x ?yr ?yc y</code> BLAS <code>axpy</code> function for matrices.</p><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>xr + m - 1 &lt;= dim1 x</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>xc + n - 1 &lt;= dim2 x</code></p></dd></dl><dl><dt>parameter xr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter xc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_diag"><a href="#val-gemm_diag" class="anchor"></a><code><span class="keyword">val </span>gemm_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;beta:Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;transa:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:Stdlib.Complex.t <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;transb:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>gemm_diag ?n ?k ?beta ?ofsy ?y ?transa ?transb ?alpha ?ar ?ac a ?br ?bc b</code> computes the diagonal of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing), multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrices will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_trace"><a href="#val-gemm_trace" class="anchor"></a><code><span class="keyword">val </span>gemm_trace : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;transa:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;transb:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>gemm_trace ?n ?k ?transa ?ar ?ac a ?transb ?br ?bc b</code> computes the trace of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing). When transposing <code>a</code>, this yields the so-called Frobenius product of <code>a</code> and <code>b</code>. <code>n</code> is the number of rows (columns) to consider in <code>a</code> and the number of columns (rows) in <code>b</code>. <code>k</code> is the inner dimension to use for the product.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-symm2_trace"><a href="#val-symm2_trace" class="anchor"></a><code><span class="keyword">val </span>symm2_trace : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;upa:bool <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;upb:bool <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>symm2_trace ?n ?upa ?ar ?ac a ?upb ?br ?bc b</code> computes the trace of the product of the symmetric (sub-)matrices <code>a</code> and <code>b</code>. <code>n</code> is the number of rows and columns to consider in <code>a</code> and <code>b</code>.</p><dl><dt>parameter n</dt><dd><p>default = dimensions of <code>a</code> and <code>b</code></p></dd></dl><dl><dt>parameter upa</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter upb</dt><dd><p>default = true (upper triangular portion of <code>b</code> is accessed)</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><code><span class="keyword">val </span>ssqr_diff : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt></dl></section><section><header><h4 id="iterators-over-matrices"><a href="#iterators-over-matrices" class="anchor"></a>Iterators over matrices</h4></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (Stdlib.Complex.t <span>&#45;&gt;</span> Stdlib.Complex.t) <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>map f ?m ?n ?br ?bc ?b ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>matrix with <code>f</code> applied to each element of <code>a</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size m by n</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_cols"><a href="#val-fold_cols" class="anchor"></a><code><span class="keyword">val </span>fold_cols : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_cols f ?n ?ac acc a</code></p><dl><dt>returns</dt><dd><p>accumulator resulting from folding over each column vector.</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl></dd></dl></section></div></body></html>