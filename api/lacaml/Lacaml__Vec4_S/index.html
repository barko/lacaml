<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lacaml__Vec4_S (lacaml.Lacaml__Vec4_S)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">lacaml</a> &#x00BB; Lacaml__Vec4_S</nav><h1>Module <code>Lacaml__Vec4_S</code></h1><nav class="toc"><ul><li><a href="#creation/conversion-of-vectors-and-dimension-accessor">Creation/conversion of vectors and dimension accessor</a></li><li><a href="#iterators-over-vectors">Iterators over vectors</a></li><li><a href="#operations-on-one-vector">Operations on one vector</a></li><li><a href="#operations-on-two-vectors">Operations on two vectors</a></li></ul></nav></header><section><header><h6 id="creation/conversion-of-vectors-and-dimension-accessor"><a href="#creation/conversion-of-vectors-and-dimension-accessor" class="anchor"></a>Creation/conversion of vectors and dimension accessor</h6></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>create n</code> </p><dl><dt>returns</dt><dd><p>a vector with <code>n</code> rows (not initialized).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>make n x</code> </p><dl><dt>returns</dt><dd><p>a vector with <code>n</code> rows initialized with value <code>x</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make0"><a href="#val-make0" class="anchor"></a><code><span class="keyword">val</span> make0 : int <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>make0 n x</code> </p><dl><dt>returns</dt><dd><p>a vector with <code>n</code> rows initialized with the zero element.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>init n f</code> </p><dl><dt>returns</dt><dd><p>a vector containing <code>n</code> elements, where each element at position <code>i</code> is initialized by the result of calling <code>f i</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span>float array</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>of_array ar</code> </p><dl><dt>returns</dt><dd><p>a vector initialized from array <code>ar</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>float array</span></code></dt><dd><p><code>to_array v</code> </p><dl><dt>returns</dt><dd><p>an array initialized from vector <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span>float list</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>of_list l</code> </p><dl><dt>returns</dt><dd><p>a vector initialized from list <code>l</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>float list</span></code></dt><dd><p><code>to_list v</code> </p><dl><dt>returns</dt><dd><p>a list initialized from vector <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>append v1 v2</code> </p><dl><dt>returns</dt><dd><p>the vector resulting from appending vector <code>v2</code> to <code>v1</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> list</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>concat vs</code> </p><dl><dt>returns</dt><dd><p>the concatenation of vectors <code>vs</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>empty</code>, the empty vector.</p></dd></dl><dl><dt class="spec value" id="val-linspace"><a href="#val-linspace" class="anchor"></a><code><span class="keyword">val</span> linspace : <span>?&#8288;y:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>linspace ?z a b n</code> </p><dl><dt>returns</dt><dd><p>the vector <code>y</code> overwritten with <code>n</code> linearly spaced points between and including <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of dim <code>n</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-logspace"><a href="#val-logspace" class="anchor"></a><code><span class="keyword">val</span> logspace : <span>?&#8288;y:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span>?&#8288;base:float</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>logspace ?z a b base n</code> </p><dl><dt>returns</dt><dd><p>the vector <code>y</code> overwritten with <code>n</code> points logarithmically spaced using base <code>b</code> between and including <code>base</code> ** <code>a</code> and <code>base</code> ** <code>b</code>.</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of dim <code>n</code></p></dd></dl><dl><dt>parameter base</dt><dd><p>default = 10.0</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-dim"><a href="#val-dim" class="anchor"></a><code><span class="keyword">val</span> dim : <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>dim x</code> </p><dl><dt>returns</dt><dd><p>the dimension of vector <code>x</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><code><span class="keyword">val</span> has_zero_dim : <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_zero_dim vec</code> checks whether vector <code>vec</code> has a dimension of size <code>zero</code>. In this case it cannot contain data.</p></dd></dl></section><section><header><h6 id="iterators-over-vectors"><a href="#iterators-over-vectors" class="anchor"></a>Iterators over vectors</h6></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(float <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>map f ?n ?ofsx ?incx x</code> </p><dl><dt>returns</dt><dd><p>a new vector resulting from the application of <code>f</code> to each element of <code>x</code>.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = new vector with <code>ofsy+(n-1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(float <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter ?n ?ofsx ?incx f x</code> applies function <code>f</code> in turn to all elements of vector <code>x</code>.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>(int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri ?n ?ofsx ?incx f x</code> same as <code>iter</code> but additionally passes the index of the element as first argument and the element itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f a ?n ?ofsx ?incx x</code> is <code>f (... (f (f a x.{ofsx}) x.{ofsx + incx}) ...) x.{ofsx + (n-1)*incx}</code> if <code>incx &gt; 0</code> and the same in the reverse order of appearance of the <code>x</code> values if <code>incx &lt; 0</code>.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="operations-on-one-vector"><a href="#operations-on-one-vector" class="anchor"></a>Operations on one vector</h6></header><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></dt><dd><p><code>rev x</code> reverses vector <code>x</code> (non-destructive).</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>max ?n ?ofsx ?incx x</code> computes the greater of the <code>n</code> elements in vector <code>x</code> (2-norm), separated by <code>incx</code> incremental steps. NaNs are ignored. If only NaNs are encountered, the negative <code>infinity</code> value will be returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>min ?n ?ofsx ?incx x</code> computes the smaller of the <code>n</code> elements in vector <code>x</code> (2-norm), separated by <code>incx</code> incremental steps. NaNs are ignored. If only NaNs are encountered, the <code>infinity</code> value will be returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : <span>?&#8288;cmp:<span>(float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;decr:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsp:int</span> <span>&#45;&gt;</span> <span>?&#8288;incp:int</span> <span>&#45;&gt;</span> <span>?&#8288;p:<a href="../Lacaml/Common/index.html#type-int_vec">Lacaml.Common.int_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sort ?cmp ?n ?ofsx ?incx x</code> sorts the array <code>x</code> in increasing order according to the comparison function <code>cmp</code>.</p><dl><dt>parameter cmp</dt><dd><p>a function such that <code>cmp a b &lt; 0</code> if <code>a</code> is less than <code>b</code>, <code>cmp a b = 0</code> if <code>a</code> equal <code>b</code> and <code>cmp a b &gt; 0</code> if <code>a</code> is greater than <code>b</code> for the desired order. Default: the usual order on floating point values or the lexicographic order on complex ones (a special routine makes it fast). Whatever the order you choose, NaNs (in any component for complex numbers) are considered larger than any other value (so they will be last, in no specified order, in the sorted vector). Therefore, NaN are never passed to <code>cmp</code>.</p></dd></dl><dl><dt>parameter p</dt><dd><p>if you pass a vector of size <code>ofsp+(n - 1)(abs incp)</code>, the vector <code>x</code> will be unchanged and the permutation to sort it will be stored in <code>p</code>. Thus <code>x.{p.{ofsp + (i-1) * incp}}</code> will give the elements of <code>x</code> in increasing order. Default: no vector is provided.</p></dd></dl><dl><dt>parameter decr</dt><dd><p>sort in decreasing order (stays fast for the default <code>cmp</code>).</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater <code>n</code> s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsp</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incp</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill ?n ?ofsx ?incx x a</code> fills vector <code>x</code> with value <code>a</code> in the designated range.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sum ?n ?ofsx ?incx x</code> computes the sum of the <code>n</code> elements in vector <code>x</code>, separated by <code>incx</code> incremental steps.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span class="keyword">val</span> prod : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>prod ?n ?ofsx ?incx x</code> computes the product of the <code>n</code> elements in vector <code>x</code>, separated by <code>incx</code> incremental steps.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_const"><a href="#val-add_const" class="anchor"></a><code><span class="keyword">val</span> add_const : float <span>&#45;&gt;</span> <a href="../Lacaml__Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></dt><dd><p><code>add_const c ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> adds constant <code>c</code> to the <code>n</code> elements of vector <code>x</code> and stores the result in <code>y</code>, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqr_nrm2"><a href="#val-sqr_nrm2" class="anchor"></a><code><span class="keyword">val</span> sqr_nrm2 : <span>?&#8288;stable:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sqr_nrm2 ?stable ?n ?c ?ofsx ?incx x</code> computes the square of the 2-norm (Euclidean norm) of vector <code>x</code> separated by <code>incx</code> incremental steps. If <code>stable</code> is true, this is equivalent to squaring the result of calling the BLAS-function <code>nrm2</code>, which avoids over- and underflow if possible. If <code>stable</code> is false (default), <code>dot</code> will be called instead for greatly improved performance.</p><dl><dt>parameter stable</dt><dd><p>default = <code>false</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr"><a href="#val-ssqr" class="anchor"></a><code><span class="keyword">val</span> ssqr : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;c:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>ssqr ?n ?c ?ofsx ?incx x</code> computes the sum of squared differences of the <code>n</code> elements in vector <code>x</code> from constant <code>c</code>, separated by <code>incx</code> incremental steps. Please do not confuse with <a href="index.html#val-sqr_nrm2"><code>sqr_nrm2</code></a>! The current function behaves differently with complex numbers when zero is passed in for <code>c</code>. It computes the square for each entry then, whereas <a href="index.html#val-sqr_nrm2"><code>sqr_nrm2</code></a> uses the conjugate transpose in the product. The latter will therefore always return a real number.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter c</dt><dd><p>default = zero</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val</span> neg : <a href="../Lacaml__Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></dt><dd><p><code>neg ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> negates <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reci"><a href="#val-reci" class="anchor"></a><code><span class="keyword">val</span> reci : <a href="../Lacaml__Float32/Types/Vec/index.html#type-unop">Lacaml__.Float32.Types.Vec.unop</a></code></dt><dd><p><code>reci ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the reciprocal value of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="operations-on-two-vectors"><a href="#operations-on-two-vectors" class="anchor"></a>Operations on two vectors</h6></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></dt><dd><p><code>add ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> adds <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></dt><dd><p><code>sub ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> subtracts <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val</span> mul : <a href="../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></dt><dd><p><code>mul ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val</span> div : <a href="../Lacaml__Float32/Types/Vec/index.html#type-binop">Lacaml__.Float32.Types.Vec.binop</a></code></dt><dd><p><code>div ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> divides <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-zpxy"><a href="#val-zpxy" class="anchor"></a><code><span class="keyword">val</span> zpxy : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsz:int</span> <span>&#45;&gt;</span> <span>?&#8288;incz:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>zpxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively, and adds the result to and stores it in the specified range in <code>z</code>. This function is useful for convolutions.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-zmxy"><a href="#val-zmxy" class="anchor"></a><code><span class="keyword">val</span> zmxy : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsz:int</span> <span>&#45;&gt;</span> <span>?&#8288;incz:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>zmxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively, and substracts the result from and stores it in the specified range in <code>z</code>. This function is useful for convolutions.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><code><span class="keyword">val</span> ssqr_diff : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>ssqr_diff ?n ?ofsx ?incx x ?ofsy ?incy y</code> returns the sum of squared differences of <code>n</code> elements of vectors <code>x</code> and <code>y</code>, using <code>incx</code> and <code>incy</code> as incremental steps respectively.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl></section></div></body></html>