<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lacaml__Impl2_S (lacaml.Lacaml__Impl2_S)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">lacaml</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Lacaml__Impl2_S</span></h1></header><div class="h7">BLAS-1 interface</div><div class="spec val" id="val-dot"><a href="#val-dot" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dot : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">dot ?n ?ofsx ?incx x ?ofsy ?incy y</code> see BLAS documentation!</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li></ul></div></div><div class="spec val" id="val-asum"><a href="#val-asum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asum : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">asum ?n ?ofsx ?incx x</code> see BLAS documentation!</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="h7">BLAS-2 interface</div><div class="spec val" id="val-sbmv"><a href="#val-sbmv" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sbmv : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;k:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;y:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;alpha:float <span class="keyword">&#8209;&gt;</span> ?&#8288;beta:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">sbmv ?n ?k ?ofsy ?incy ?y ?ar ?ac a ?up ?alpha ?beta ?ofsx ?incx x</code> see
BLAS documentation!</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> vector <code class="code">y</code>, which is overwritten.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = number of available columns to the right of <code class="code">ac</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">k</span>: default = number of available rows in matrix <code class="code">a</code> - 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">y</span>: default = uninitialized vector of minimal length (see BLAS)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true i.e., upper band of <code class="code">a</code> is supplied</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">alpha</span>: default = 1.0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">beta</span>: default = 0.0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li></ul></div></div><div class="spec val" id="val-ger"><a href="#val-ger" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ger : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;alpha:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsy:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incy:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">ger ?m ?n ?alpha ?ofsx ?incx x ?ofsy ?incy y n ?ar ?ac a</code> see
BLAS documentation!</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = number of rows of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = number of columns of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">alpha</span>: default = 1.0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incy</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-syr"><a href="#val-syr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syr : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;alpha:float <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsx:int <span class="keyword">&#8209;&gt;</span> ?&#8288;incx:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">syr ?n ?alpha ?up ?ofsx ?incx x ?ar ?ac a</code> see BLAS documentation!</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = number of rows of <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">alpha</span>: default = 1.0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true i.e., upper triangle of <code class="code">a</code> is supplied</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">incx</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="h7">LAPACK interface</div><div class="h8">Auxiliary routines</div><div class="spec val" id="val-lansy_min_lwork"><a href="#val-lansy_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>lansy_min_lwork : int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">lansy_min_lwork m norm</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the work array used by the <code class="code">lansy</code>-function.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">norm</span>: type of norm that will be computed by <code class="code">lansy</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the number of columns (and rows) in the matrix</li></ul></div></div><div class="spec val" id="val-lansy"><a href="#val-lansy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>lansy : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;norm:<a href="../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">lansy ?norm ?up ?n ?ar ?ac ?work a</code> see LAPACK documentation!</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">norm</span>: default = `O</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true (reference upper triangular part of <code class="code">a</code>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = allocated work space for norm `I</li></ul></div></div><div class="spec val" id="val-lamch"><a href="#val-lamch" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>lamch : [ `E | `S | `B | `P | `N | `R | `M | `U | `L | `O ] <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">lamch cmach</code> see LAPACK documentation!</p></div></div><div class="h8">Linear equations (computational routines)</div><div class="spec val" id="val-orgqr_min_lwork"><a href="#val-orgqr_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>orgqr_min_lwork : n:int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">orgqr_min_lwork ~n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work-array used by the <code class="code">orgqr</code>-function if the matrix has <code class="code">n</code>
columns.</li></ul></div></div><div class="spec val" id="val-orgqr_opt_lwork"><a href="#val-orgqr_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>orgqr_opt_lwork : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;k:int <span class="keyword">&#8209;&gt;</span> tau:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">orgqr_opt_lwork ?m ?n ?k ~tau ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum
length of the work-array used by the <code class="code">orgqr</code>-function given matrix <code class="code">a</code>,
optionally its logical dimensions <code class="code">m</code> and <code class="code">n</code>, and the number of reflectors
<code class="code">k</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">k</span>: default = available number of elements in vector <code class="code">tau</code></li></ul></div></div><div class="spec val" id="val-orgqr"><a href="#val-orgqr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>orgqr : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;k:int <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> tau:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">orgqr ?m ?n ?k ?work ~tau ?ar ?ac a</code> see LAPACK documentation!</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">k</span>: default = available number of elements in vector <code class="code">tau</code></li></ul></div></div><div class="spec val" id="val-ormqr_opt_lwork"><a href="#val-ormqr_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ormqr_opt_lwork : ?&#8288;side:<a href="../Lacaml/Common/index.html#type-side">Lacaml.Common.side</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;trans:<a href="../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;k:int <span class="keyword">&#8209;&gt;</span> tau:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;cr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;cc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">ormqr_opt_lwork ?side ?trans ?m ?n ?k ~tau ?ar ?ac a ?cr ?cc c</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum length of the work-array used by the <code class="code">ormqr</code>-function
given matrix <code class="code">a</code> and <code class="code">b</code>, optionally its logical dimensions <code class="code">m</code> and <code class="code">n</code>,
and the number of reflectors <code class="code">k</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">k</span>: default = available number of elements in vector <code class="code">tau</code></li></ul></div></div><div class="spec val" id="val-ormqr"><a href="#val-ormqr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ormqr : ?&#8288;side:<a href="../Lacaml/Common/index.html#type-side">Lacaml.Common.side</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;trans:<a href="../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;k:int <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> tau:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;cr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;cc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">ormqr ?side ?trans ?m ?n ?k ?work ~tau ?ar ?ac a ?cr ?cc c</code>
see LAPACK documentation!</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">side</span>: default = <code class="code">`L</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">trans</span>: default = <code class="code">`N</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">k</span>: default = available number of elements in vector <code class="code">tau</code></li></ul></div></div><div class="spec val" id="val-gecon_min_lwork"><a href="#val-gecon_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gecon_min_lwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gecon_min_lwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the work array
used by the <code class="code">gecon</code>-function.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the logical dimensions of the matrix given to
the <code class="code">gecon</code>-function</li></ul></div></div><div class="spec val" id="val-gecon_min_liwork"><a href="#val-gecon_min_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gecon_min_liwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gecon_min_liwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the iwork array
used by the <code class="code">gecon</code>-function.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the logical dimensions of the matrix given to <code class="code">gecon</code>-function</li></ul></div></div><div class="spec val" id="val-gecon"><a href="#val-gecon" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gecon : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;norm:<a href="../Lacaml/Common/index.html#type-norm2">Lacaml.Common.norm2</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;anorm:float <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">gecon ?n ?norm ?anorm ?work ?rwork ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> estimate of the reciprocal of the condition number of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">norm</span>: default = 1-norm</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">anorm</span>: default = norm of the matrix <code class="code">a</code> as returned by <code class="code">lange</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = automatically allocated workspace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iwork</span>: default = automatically allocated workspace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sycon_min_lwork"><a href="#val-sycon_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sycon_min_lwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">sycon_min_lwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the work array
used by the <code class="code">sycon</code>-function.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the logical dimensions of the matrix given to
the <code class="code">sycon</code>-function</li></ul></div></div><div class="spec val" id="val-sycon_min_liwork"><a href="#val-sycon_min_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sycon_min_liwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">sycon_min_liwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the iwork array
used by the <code class="code">sycon</code>-function.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the logical dimensions of the matrix given to <code class="code">sycon</code>-function</li></ul></div></div><div class="spec val" id="val-sycon"><a href="#val-sycon" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sycon : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;ipiv:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;anorm:float <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">sycon ?n ?up ?ipiv ?anorm ?work ?iwork ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> estimate of the reciprocal of the condition number
of symmetric matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = upper triangle of the factorization of <code class="code">a</code> is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ipiv</span>: default = vec of length <code class="code">n</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">anorm</span>: default = 1-norm of the matrix <code class="code">a</code> as returned by <code class="code">lange</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = automatically allocated workspace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iwork</span>: default = automatically allocated workspace</li></ul></div></div><div class="spec val" id="val-pocon_min_lwork"><a href="#val-pocon_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pocon_min_lwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">pocon_min_lwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the work array
used by the <code class="code">pocon</code>-function.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the logical dimensions of the matrix given to
the <code class="code">pocon</code>-function</li></ul></div></div><div class="spec val" id="val-pocon_min_liwork"><a href="#val-pocon_min_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pocon_min_liwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">pocon_min_liwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the iwork array
used by the <code class="code">pocon</code>-function.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the logical dimensions of the matrix given to <code class="code">pocon</code>-function</li></ul></div></div><div class="spec val" id="val-pocon"><a href="#val-pocon" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pocon : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;anorm:float <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">pocon ?n ?up ?anorm ?work ?iwork ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> estimate of the reciprocal of the condition number of
symmetric positive definite matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = upper triangle of Cholesky factorization
of <code class="code">a</code> is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = automatically allocated workspace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iwork</span>: default = automatically allocated workspace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">anorm</span>: default = 1-norm of the matrix <code class="code">a</code> as returned by <code class="code">lange</code></li></ul></div></div><div class="h8">Least squares (expert drivers)</div><div class="spec val" id="val-gelsy_min_lwork"><a href="#val-gelsy_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelsy_min_lwork : m:int <span class="keyword">&#8209;&gt;</span> n:int <span class="keyword">&#8209;&gt;</span> nrhs:int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelsy_min_lwork ~m ~n ~nrhs</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work-array used by the <code class="code">gelsy</code>-function if the logical dimensions
of the matrix are <code class="code">m</code> rows and <code class="code">n</code> columns and if there are <code class="code">nrhs</code>
right hand side vectors.</li></ul></div></div><div class="spec val" id="val-gelsy_opt_lwork"><a href="#val-gelsy_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelsy_opt_lwork : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;nrhs:int <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelsy_opt_lwork ?m ?n ?ar ?ac a ?nrhs ?br ?bc b</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum
length of the work-array used by the <code class="code">gelsy</code>-function given matrix
<code class="code">a</code>, optionally its logical dimensions <code class="code">m</code> and <code class="code">n</code> and given right
hand side matrix <code class="code">b</code> with an optional number <code class="code">nrhs</code> of vectors.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">nrhs</span>: default = available number of columns in matrix <code class="code">b</code></li></ul></div></div><div class="spec val" id="val-gelsy"><a href="#val-gelsy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelsy : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;rcond:float <span class="keyword">&#8209;&gt;</span> ?&#8288;jpvt:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;nrhs:int <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelsy ?m ?n ?ar ?ac a ?rcond ?jpvt ?ofswork ?work ?nrhs b</code> see LAPACK
documentation!</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the effective rank of <code class="code">a</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rcond</span>: default = (-1) =&gt; machine precision</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">jpvt</span>: default = vec of length <code class="code">n</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (-&gt; <code class="code">gelsy_opt_lwork</code>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">nrhs</span>: default = available number of columns in matrix <code class="code">b</code></li></ul></div></div><div class="spec val" id="val-gelsd_min_lwork"><a href="#val-gelsd_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelsd_min_lwork : m:int <span class="keyword">&#8209;&gt;</span> n:int <span class="keyword">&#8209;&gt;</span> nrhs:int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelsd_min_lwork ~m ~n ~nrhs</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work-array used by the <code class="code">gelsd</code>-function if the logical dimensions
of the matrix are <code class="code">m</code> and <code class="code">n</code> and if there are <code class="code">nrhs</code> right hand
side vectors.</li></ul></div></div><div class="spec val" id="val-gelsd_opt_lwork"><a href="#val-gelsd_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelsd_opt_lwork : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;nrhs:int <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelsd_opt_lwork ?m ?n ?ar ?ac a ?nrhs b</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum length of
the work-array used by the <code class="code">gelsd</code>-function given matrix <code class="code">a</code>,
optionally its logical dimensions <code class="code">m</code> and <code class="code">n</code> and given right hand
side matrix <code class="code">b</code> with an optional number <code class="code">nrhs</code> of vectors.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">nrhs</span>: default = available number of columns in matrix <code class="code">b</code></li></ul></div></div><div class="spec val" id="val-gelsd_min_iwork"><a href="#val-gelsd_min_iwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelsd_min_iwork : int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelsd_min_iwork m n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum (= optimum) length
of the iwork-array used by the <code class="code">gelsd</code>-function if the logical
dimensions of the matrix are <code class="code">m</code> and <code class="code">n</code>.</li></ul></div></div><div class="spec val" id="val-gelsd"><a href="#val-gelsd" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelsd : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;rcond:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ofss:int <span class="keyword">&#8209;&gt;</span> ?&#8288;s:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;nrhs:int <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelsd ?m ?n ?rcond ?ofss ?s ?ofswork ?work ?ar ?ac a ?nrhs b</code>
see LAPACK documentation!</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the effective rank of <code class="code">a</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rcond</span>: default = (-1) =&gt; machine precision</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofss</span>: default = 1 or ignored if <code class="code">s</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">s</span>: default = vec of length <code class="code">min rows cols</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (-&gt; <code class="code">gelsd_opt_lwork</code>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iwork</span>: default = vec of optimum (= minimum) length</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">nrhs</span>: default = available number of columns in matrix <code class="code">b</code></li></ul></div></div><div class="spec val" id="val-gelss_min_lwork"><a href="#val-gelss_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelss_min_lwork : m:int <span class="keyword">&#8209;&gt;</span> n:int <span class="keyword">&#8209;&gt;</span> nrhs:int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelss_min_lwork ~m ~n ~nrhs</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work-array used by the <code class="code">gelss</code>-function if the logical dimensions
of the matrix are <code class="code">m</code> rows and <code class="code">n</code> columns and if there are <code class="code">nrhs</code>
right hand side vectors.</li></ul></div></div><div class="spec val" id="val-gelss_opt_lwork"><a href="#val-gelss_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelss_opt_lwork : ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;nrhs:int <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelss_opt_lwork ?ar ?ac a ?m ?n ?nrhs ?br ?bc b</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum
length of the work-array used by the <code class="code">gelss</code>-function given matrix
<code class="code">a</code>, optionally its logical dimensions <code class="code">m</code> and <code class="code">n</code> and given right
hand side matrix <code class="code">b</code> with an optional number <code class="code">nrhs</code> of vectors.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">nrhs</span>: default = available number of columns in matrix <code class="code">b</code></li></ul></div></div><div class="spec val" id="val-gelss"><a href="#val-gelss" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gelss : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;rcond:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ofss:int <span class="keyword">&#8209;&gt;</span> ?&#8288;s:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;nrhs:int <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gelss ?m ?n ?rcond ?ofss ?s ?ofswork ?work ?ar ?ac a ?nrhs ?br ?bc b</code>
see LAPACK documentation!</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the effective rank of <code class="code">a</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">m</span>: default = available number of rows in matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rcond</span>: default = (-1) =&gt; machine precision</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofss</span>: default = 1 or ignored if <code class="code">s</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">s</span>: default = vec of length <code class="code">min m n</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (-&gt; <code class="code">gelss_opt_lwork</code>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">nrhs</span>: default = available number of columns in matrix <code class="code">b</code></li></ul></div></div><div class="h8">General Schur factorization</div><div class="spec val" id="val-gees"><a href="#val-gees" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gees : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;jobvs:<a href="../Lacaml/Common/index.html#type-schur_vectors">Lacaml.Common.schur_vectors</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;sort:<a href="../Lacaml/Common/index.html#type-eigen_value_sort">Lacaml.Common.eigen_value_sort</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;wr:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;wi:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;vsr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vsc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vs:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int<span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">gees ?n ?jobvs ?sort ?w ?vsr ?vsc ?vs ?work ?ar ?ac a</code>
See <code class="code">gees</code>-function for details about arguments.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> (sdim, wr, wi, vs)</li></ul></div></div><div class="h8">General SVD routines</div><div class="spec val" id="val-gesvd_min_lwork"><a href="#val-gesvd_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gesvd_min_lwork : m:int <span class="keyword">&#8209;&gt;</span> n:int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gesvd_min_lwork ~m ~n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the work array
used by the <code class="code">gesvd</code>-function for matrices with <code class="code">m</code> rows and <code class="code">n</code>
columns.</li></ul></div></div><div class="spec val" id="val-gesvd_opt_lwork"><a href="#val-gesvd_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gesvd_opt_lwork : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;jobu:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;jobvt:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;s:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ur:int <span class="keyword">&#8209;&gt;</span> ?&#8288;uc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;u:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;vtr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vtc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vt:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div><div class="spec val" id="val-gesvd"><a href="#val-gesvd" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gesvd : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;jobu:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;jobvt:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;s:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ur:int <span class="keyword">&#8209;&gt;</span> ?&#8288;uc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;u:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;vtr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vtc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vt:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"></div></div><div class="spec val" id="val-gesdd_liwork"><a href="#val-gesdd_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gesdd_liwork : m:int <span class="keyword">&#8209;&gt;</span> n:int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div><div class="spec val" id="val-gesdd_min_lwork"><a href="#val-gesdd_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gesdd_min_lwork : ?&#8288;jobz:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a> <span class="keyword">&#8209;&gt;</span> m:int <span class="keyword">&#8209;&gt;</span> n:int <span class="keyword">&#8209;&gt;</span> unit <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">gesdd_min_lwork ?jobz ~m ~n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work array used by the <code class="code">gesdd</code>-function for matrices with <code class="code">m</code> rows
and <code class="code">n</code> columns for SVD-job <code class="code">jobz</code>.</li></ul></div></div><div class="spec val" id="val-gesdd_opt_lwork"><a href="#val-gesdd_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gesdd_opt_lwork : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;jobz:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;s:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ur:int <span class="keyword">&#8209;&gt;</span> ?&#8288;uc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;u:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;vtr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vtc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vt:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div><div class="spec val" id="val-gesdd"><a href="#val-gesdd" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>gesdd : ?&#8288;m:int <span class="keyword">&#8209;&gt;</span> ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;jobz:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;s:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ur:int <span class="keyword">&#8209;&gt;</span> ?&#8288;uc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;u:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;vtr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vtc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vt:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"></div></div><div class="h8">General eigenvalue problem (simple drivers)</div><div class="spec val" id="val-geev_min_lwork"><a href="#val-geev_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>geev_min_lwork : ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">geev_min_lwork vectors n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work array used by the <code class="code">geev</code>-function. <code class="code">vectors</code> indicates whether
eigenvectors are supposed to be computed.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: the logical dimensions of the matrix given to <code class="code">geev</code>-function</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = true</li></ul></div></div><div class="spec val" id="val-geev_opt_lwork"><a href="#val-geev_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>geev_opt_lwork : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vlr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vlc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vl:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> option <span class="keyword">&#8209;&gt;</span> ?&#8288;vrr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vrc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vr:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> option <span class="keyword">&#8209;&gt;</span> ?&#8288;ofswr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;wr:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofswi:int <span class="keyword">&#8209;&gt;</span> ?&#8288;wi:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">geev_opt_lwork
       ?n
       ?vlr ?vlc ?vl
       ?vrr ?vrc ?vr
       ?ofswr wr
       ?ofswi wi
       ?ar ?ac a</code>
See <code class="code">geev</code>-function for details about arguments.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> &quot;optimal&quot; size of work array.</li></ul></div></div><div class="spec val" id="val-geev"><a href="#val-geev" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>geev : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;vlr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vlc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vl:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> option <span class="keyword">&#8209;&gt;</span> ?&#8288;vrr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vrc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vr:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> option <span class="keyword">&#8209;&gt;</span> ?&#8288;ofswr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;wr:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofswi:int <span class="keyword">&#8209;&gt;</span> ?&#8288;wi:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a></code></div><div class="doc"><p><code class="code">geev ?work ?n
      ?vlr ?vlc ?vl
      ?vrr ?vrc ?vr
      ?ofswr ?wr ?ofswi ?wi
      ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> (<code class="code">lv</code>, <code class="code">wr</code>, <code class="code">wi</code>, <code class="code">rv</code>), where <code class="code">wr</code> and <code class="code">wv</code> are the real
and imaginary components of the eigenvalues, and <code class="code">lv</code> and <code class="code">rv</code>
are the left and right eigenvectors. <code class="code">lv</code> (<code class="code">rv</code>) is the empty
matrix if <code class="code">vl</code> (<code class="code">vr</code>) is set to <code class="code">None</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = automatically allocated workspace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vl</span>: default = Automatically allocated left eigenvectors.
Pass <code class="code">None</code> if you do not want to compute them,
<code class="code">Some lv</code> if you want to provide the storage.
You can set <code class="code">vlr</code>, <code class="code">vlc</code> in the last case.
(See LAPACK GEEV docs for details about storage of complex eigenvectors)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vr</span>: default = Automatically allocated right eigenvectors.
Pass <code class="code">None</code> if you do not want to compute them,
<code class="code">Some rv</code> if you want to provide the storage.
You can set <code class="code">vrr</code>, <code class="code">vrc</code> in the last case.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">wr</span>: default = vector of size <code class="code">n</code>; real components of the eigenvalues</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">wi</span>: default = vector of size <code class="code">n</code>;
imaginary components of the eigenvalues</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">a</span>: the matrix whose eigensystem is computed</li></ul></div></div><div class="h8">Symmetric-matrix eigenvalue and singular value problems
(simple drivers)</div><div class="spec val" id="val-syev_min_lwork"><a href="#val-syev_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syev_min_lwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syev_min_lwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the work-array
used by the <a href="index.html#val-syev">syev</a>-function if the logical dimensions of the matrix
are <code class="code">n</code>.</li></ul></div></div><div class="spec val" id="val-syev_opt_lwork"><a href="#val-syev_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syev_opt_lwork : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syev_opt_lwork ?n ?vectors ?up ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum
length of the work-array used by the <a href="index.html#val-syev">syev</a>-function given matrix
<code class="code">a</code>, optionally its logical dimension <code class="code">n</code> and whether the eigenvectors
must be computed (<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li></ul></div></div><div class="spec val" id="val-syev"><a href="#val-syev" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syev : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsw:int <span class="keyword">&#8209;&gt;</span> ?&#8288;w:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">syev ?n ?vectors ?up ?ofswork ?work ?ofsw ?w ?ar ?ac a</code> computes
all eigenvalues and, optionally, eigenvectors of the real symmetric
matrix <code class="code">a</code>.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">w</code> of eigenvalues in ascending order.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false i.e, eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true i.e., upper triangle of <code class="code">a</code> is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (-&gt; <a href="index.html#val-syev_opt_lwork">syev_opt_lwork</a>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsw</span>: default = 1 or ignored if <code class="code">w</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">w</span>: default = vec of length <code class="code">n</code></li></ul></div></div><div class="spec val" id="val-syevd_min_lwork"><a href="#val-syevd_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevd_min_lwork : vectors:bool <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevd_min_lwork vectors n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work-array used by the <a href="index.html#val-syevd">syevd</a>-function if the logical dimensions of
the matrix are <code class="code">n</code> and given whether eigenvectors should be computed
(<code class="code">vectors</code>).</li></ul></div></div><div class="spec val" id="val-syevd_min_liwork"><a href="#val-syevd_min_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevd_min_liwork : vectors:bool <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevd_min_liwork vectors n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
iwork-array used by the <a href="index.html#val-syevd">syevd</a>-function if the logical dimensions of
the matrix are <code class="code">n</code> and given whether eigenvectors should be computed
(<code class="code">vectors</code>).</li></ul></div></div><div class="spec val" id="val-syevd_opt_lwork"><a href="#val-syevd_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevd_opt_lwork : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevd_opt_lwork ?n ?vectors ?up ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum
length of the work-array used by the <a href="index.html#val-syevd">syevd</a>-function given matrix
<code class="code">a</code>, optionally its logical dimension <code class="code">n</code> and whether the eigenvectors
must be computed (<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li></ul></div></div><div class="spec val" id="val-syevd_opt_liwork"><a href="#val-syevd_opt_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevd_opt_liwork : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevd_opt_liwork ?n ?vectors ?up ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum
length of the iwork-array used by the <a href="index.html#val-syevd">syevd</a>-function given matrix
<code class="code">a</code>, optionally its logical dimension <code class="code">n</code> and whether the eigenvectors
must be computed (<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li></ul></div></div><div class="spec val" id="val-syevd_opt_l_li_work"><a href="#val-syevd_opt_l_li_work" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevd_opt_l_li_work : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int<span class="keyword"> * </span>int</code></div><div class="doc"><p><code class="code">syevd_opt_l_li_iwork ?n ?vectors ?up ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the tuple
of optimum lengths of the work- and iwork-arrays respectively,
used by the <a href="index.html#val-syevd">syevd</a>-function given matrix <code class="code">a</code>, optionally its
logical dimension <code class="code">n</code> and whether the eigenvectors must be computed
(<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li></ul></div></div><div class="spec val" id="val-syevd"><a href="#val-syevd" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevd : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsw:int <span class="keyword">&#8209;&gt;</span> ?&#8288;w:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">syevd ?n ?vectors ?up ?ofswork ?work ?iwork ?ofsw ?w ?ar ?ac a</code>
computes all eigenvalues and, optionally, eigenvectors of the real
symmetric matrix <code class="code">a</code>. If eigenvectors are desired, it uses a
divide and conquer algorithm.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">w</code> of eigenvalues in ascending order.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false i.e, eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true i.e., upper triangle of <code class="code">a</code> is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (-&gt; <a href="index.html#val-syev_opt_lwork">syev_opt_lwork</a>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iwork</span>: default = int32_vec of optimum length (-&gt; <a href="index.html#val-syevd_opt_liwork">syevd_opt_liwork</a>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsw</span>: default = 1 or ignored if <code class="code">w</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">w</span>: default = vec of length <code class="code">n</code></li></ul></div></div><div class="spec val" id="val-sbev_min_lwork"><a href="#val-sbev_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sbev_min_lwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">sbev_min_lwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the work-array
used by the <a href="index.html#val-sbev">sbev</a>-function if the logical dimensions of the matrix
are <code class="code">n</code>.</li></ul></div></div><div class="spec val" id="val-sbev"><a href="#val-sbev" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sbev : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;kd:int <span class="keyword">&#8209;&gt;</span> ?&#8288;zr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;zc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;z:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsw:int <span class="keyword">&#8209;&gt;</span> ?&#8288;w:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;abr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;abc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">sbev ?n ?vectors ?zr ?zc ?z ?up ?ofswork ?work ?ofsw ?w ?abr ?abc ab</code>
computes all the eigenvalues and, optionally, eigenvectors of the
real symmetric <i>band</i> matrix <code class="code">ab</code>.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag return">Returns</span> the vector <code class="code">w</code> of eigenvalues in ascending order.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">ab</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: matrix to contain the orthonormal eigenvectors of <code class="code">ab</code>,
the <code class="code">i</code>-th column of <code class="code">z</code> holding the eigenvector associated
with <code class="code">w.{i}</code>.
default = <code class="code">None</code> i.e, eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">kd</span>: default = number of rows in matrix <code class="code">ab</code> - 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true i.e., upper triangle of the matrix is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of minimal length (-&gt; <a href="index.html#val-sbev_min_lwork">sbev_min_lwork</a>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsw</span>: default = 1 or ignored if <code class="code">w</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">w</span>: default = vec of length <code class="code">n</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">abr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">abc</span>: default = 1</li></ul></div></div><div class="h8">Symmetric-matrix eigenvalue and singular value problems (expert &amp;
RRR drivers)</div><div class="spec val" id="val-syevr_min_lwork"><a href="#val-syevr_min_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevr_min_lwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevr_min_lwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
work-array used by the <a href="index.html#val-syevr">syevr</a>-function if the logical dimensions
of the matrix are <code class="code">n</code>.</li></ul></div></div><div class="spec val" id="val-syevr_min_liwork"><a href="#val-syevr_min_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevr_min_liwork : int <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevr_min_liwork n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the minimum length of the
iwork-array used by the <a href="index.html#val-syevr">syevr</a>-function if the logical dimensions
of the matrix are <code class="code">n</code>.</li></ul></div></div><div class="spec val" id="val-syevr_opt_lwork"><a href="#val-syevr_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevr_opt_lwork : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;range:[ `A | `V of float<span class="keyword"> * </span>float | `I of int<span class="keyword"> * </span>int ] <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;abstol:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevr_opt_lwork ?n ?vectors ?range ?up ?abstol ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum length of the work-array used by the <a href="index.html#val-syevr">syevr</a>-function
given matrix <code class="code">a</code>, optionally its logical dimension <code class="code">n</code> and whether
the eigenvectors must be computed (<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li></ul></div></div><div class="spec val" id="val-syevr_opt_liwork"><a href="#val-syevr_opt_liwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevr_opt_liwork : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;range:[ `A | `V of float<span class="keyword"> * </span>float | `I of int<span class="keyword"> * </span>int ] <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;abstol:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">syevr_opt_liwork ?n ?vectors ?range ?up ?abstol ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the optimum length of the iwork-array used by the <a href="index.html#val-syevr">syevr</a>-function
given matrix <code class="code">a</code>, optionally its logical dimension <code class="code">n</code> and whether
the eigenvectors must be computed (<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li></ul></div></div><div class="spec val" id="val-syevr_opt_l_li_work"><a href="#val-syevr_opt_l_li_work" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevr_opt_l_li_work : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;range:[ `A | `V of float<span class="keyword"> * </span>float | `I of int<span class="keyword"> * </span>int ] <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;abstol:float <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int<span class="keyword"> * </span>int</code></div><div class="doc"><p><code class="code">syevr_opt_l_li_iwork ?n ?vectors ?range ?up ?abstol ?ar ?ac a</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the tuple of optimum lengths of the work- and iwork-arrays
respectively, used by the <a href="index.html#val-syevr">syevr</a>-function given matrix <code class="code">a</code>,
optionally its logical dimension <code class="code">n</code> and whether the eigenvectors
must be computed (<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li></ul></div></div><div class="spec val" id="val-syevr"><a href="#val-syevr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>syevr : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;range:[ `A | `V of float<span class="keyword"> * </span>float | `I of int<span class="keyword"> * </span>int ] <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;abstol:float <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;iwork:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsw:int <span class="keyword">&#8209;&gt;</span> ?&#8288;w:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;zr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;zc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;z:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;isuppz:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int<span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a><span class="keyword"> * </span><a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a><span class="keyword"> * </span><a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></code></div><div class="doc"><p><code class="code">syevr
      ?n ?vectors ?range ?up ?abstol ?work ?iwork
      ?ofsw ?w ?zr ?zc ?z ?isuppz ?ar ?ac a</code><code class="code">range</code> is either <code class="code">`A</code> for computing all eigenpairs, <code class="code">`V (vl, vu)</code>
defines the lower and upper range of computed eigenvalues, <code class="code">`I (il,
    iu)</code> defines the indexes of the computed eigenpairs, which are sorted
in ascending order.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the tuple <code class="code">(m, w, z, isuppz)</code>, where <code class="code">m</code> is the number
of computed eigenpairs, vector <code class="code">w</code> contains the computed
eigenvalues in ascending order, <code class="code">z</code> contains the computed
eigenvectors in same order, and <code class="code">isuppz</code> indicates the
nonzero elements in <code class="code">z</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false i.e, eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">range</span>: default = `A</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true i.e., upper triangle of <code class="code">a</code> is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">abstol</span>: default = result of calling <code class="code">lamch `S</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (-&gt; <a href="index.html#val-syev_opt_lwork">syev_opt_lwork</a>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iwork</span>: default = int32_vec of optimum length (-&gt; <a href="index.html#val-syevr_opt_liwork">syevr_opt_liwork</a>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsw</span>: default = 1 or ignored if <code class="code">w</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">w</span>: default = vec of length <code class="code">n</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">zr</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">zc</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = matrix with minimal required dimension</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">isuppz</span>: default = <code class="code">int32_vec</code> with minimal required dimension</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ar</span>: default = 1</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ac</span>: default = 1</li></ul></div></div><div class="spec val" id="val-sygv_opt_lwork"><a href="#val-sygv_opt_lwork" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sygv_opt_lwork : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;itype:[ `A_B | `AB | `BA ] <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">sygv_opt_lwork ?n ?vectors ?up ?ar ?ac a ?br ?bc b</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the
optimum length of the work-array used by the <a href="index.html#val-sygv">sygv</a>-function
for the given matrices <code class="code">a</code> and <code class="code">b</code>, optionally their logical
dimension <code class="code">n</code> and whether the eigenvectors must be computed
(<code class="code">vectors</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false, i.e. eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true, i.e. upper triangle of <code class="code">a</code> is stored</li><li><p><span class="at-tag parameter">Parameter</span> <span class="module-path">itype</span>: specifies the problem type to be solved:
</p><ul><li><code class="code">`A_B</code> (default): a*x = (lambda)*a*x</li><li><code class="code">`AB</code>: a*b*x = (lambda)*x</li><li><code class="code">`BA</code>: b*a*x = (lambda)*x</li></ul></li></ul></div></div><div class="spec val" id="val-sygv"><a href="#val-sygv" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sygv : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;vectors:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsw:int <span class="keyword">&#8209;&gt;</span> ?&#8288;w:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;itype:[ `A_B | `AB | `BA ] <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">sygv ?n ?vectors ?up ?ofswork ?work ?ofsw ?w ?ar ?ac a ?br ?bc b</code>
computes all the eigenvalues, and optionally, the eigenvectors
of a real generalized symmetric-definite eigenproblem, of the
form <code class="code">a*x=(lambda)*b*x</code>, <code class="code">a*b*x=(lambda)*x</code>, or <code class="code">b*a*x=(lambda)*x</code>.
Here <code class="code">a</code> and <code class="code">b</code> are assumed to be symmetric and <code class="code">b</code> is also
positive definite.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">w</code> of eigenvalues in ascending order.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">vectors</span>: default = false i.e, eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = true i.e., upper triangle of <code class="code">a</code> is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (-&gt; <a href="index.html#val-sygv_opt_lwork">sygv_opt_lwork</a>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsw</span>: default = 1 or ignored if <code class="code">w</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">w</span>: default = vec of length <code class="code">n</code></li><li><p><span class="at-tag parameter">Parameter</span> <span class="module-path">itype</span>: specifies the problem type to be solved:
</p><ul><li><code class="code">`A_B</code> (default): a*x = (lambda)*a*x</li><li><code class="code">`AB</code>: a*b*x = (lambda)*x</li><li><code class="code">`BA</code>: b*a*x = (lambda)*x</li></ul></li></ul></div></div><div class="spec val" id="val-sbgv"><a href="#val-sbgv" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sbgv : ?&#8288;n:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ka:int <span class="keyword">&#8209;&gt;</span> ?&#8288;kb:int <span class="keyword">&#8209;&gt;</span> ?&#8288;zr:int <span class="keyword">&#8209;&gt;</span> ?&#8288;zc:int <span class="keyword">&#8209;&gt;</span> ?&#8288;z:<a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;up:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;work:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ofsw:int <span class="keyword">&#8209;&gt;</span> ?&#8288;w:<a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;ar:int <span class="keyword">&#8209;&gt;</span> ?&#8288;ac:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;br:int <span class="keyword">&#8209;&gt;</span> ?&#8288;bc:int <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-mat">Lacaml__.Float32.mat</a> <span class="keyword">&#8209;&gt;</span> <a href="../Lacaml__/Float32/index.html#type-vec">Lacaml__.Float32.vec</a></code></div><div class="doc"><p><code class="code">sbgv ?n ?ka ?kb ?zr ?zc ?z ?up ?work ?ofsw ?w ?ar ?ac a ?br ?bc b</code>
computes all the eigenvalues, and optionally, the eigenvectors of a
real generalized symmetric-definite banded eigenproblem, of the
form <code class="code">a*x=(lambda)*b*x</code>. Here <code class="code">a</code> and <code class="code">b</code> are assumed to be
symmetric and banded, and <code class="code">b</code> is also positive definite.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the vector <code class="code">w</code> of eigenvalues in ascending order.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the function fails to converge.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">n</span>: default = available number of columns of matrix <code class="code">a</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ka</span>: the number of superdiagonals (or subdiagonals if <code class="code">up = false</code>)
of the matrix <code class="code">a</code>. Default = <code class="code">dim1 a - ar</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">kb</span>: same as <code class="code">ka</code> but for the matrix <code class="code">b</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">z</span>: default = <code class="code">None</code> i.e, eigenvectors are not computed</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">up</span>: default = <code class="code">true</code> i.e., upper triangle of <code class="code">a</code> is stored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">work</span>: default = vec of optimum length (<code class="code">3 * n</code>)</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ofsw</span>: default = 1 or ignored if <code class="code">w</code> is not given</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">w</span>: default = vec of length <code class="code">n</code></li></ul></div></div></body></html>