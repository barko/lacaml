<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mat (lacaml.Lacaml__D.Mat)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">lacaml</a> &#x00BB; <a href="../index.html">Lacaml__D</a> &#x00BB; Mat</nav><h1>Module <code>Lacaml__D.Mat</code></h1><nav class="toc"><ul><li><a href="#matrix-operations">Matrix operations</a></li><li><a href="#creation-of-matrices">Creation of matrices</a></li><li><a href="#unary-matrix-operations">Unary matrix operations</a></li><li><a href="#binary-matrix-operations">Binary matrix operations</a></li><li><a href="#miscellaneous-functions">Miscellaneous functions</a></li><li><a href="#ternary-matrix-operations">Ternary matrix operations</a></li><li><a href="#creation-of-matrices-and-accessors">Creation of matrices and accessors</a></li><li><a href="#matrix-transformations">Matrix transformations</a></li><li><a href="#operations-on-one-matrix">Operations on one matrix</a></li><li><a href="#operations-on-two-matrices">Operations on two matrices</a></li><li><a href="#iterators-over-matrices">Iterators over matrices</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../index.html#type-mat">mat</a></code></dt></dl><section><header><h6 id="matrix-operations"><a href="#matrix-operations" class="anchor"></a>Matrix operations</h6></header><dl><dt class="spec type" id="type-patt"><a href="#type-patt" class="anchor"></a><code><span class="keyword">type</span> patt</code> = <code>[ </code><table class="variant"><tr id="type-patt.Full" class="anchored"><td class="def constructor"><a href="#type-patt.Full" class="anchor"></a><code>| </code><code>`Full</code></td></tr><tr id="type-patt.Utr" class="anchored"><td class="def constructor"><a href="#type-patt.Utr" class="anchor"></a><code>| </code><code>`Utr</code></td></tr><tr id="type-patt.Ltr" class="anchored"><td class="def constructor"><a href="#type-patt.Ltr" class="anchor"></a><code>| </code><code>`Ltr</code></td></tr><tr id="type-patt.Upent" class="anchored"><td class="def constructor"><a href="#type-patt.Upent" class="anchor"></a><code>| </code><code>`Upent <span class="keyword">of</span> int</code></td></tr><tr id="type-patt.Lpent" class="anchored"><td class="def constructor"><a href="#type-patt.Lpent" class="anchor"></a><code>| </code><code>`Lpent <span class="keyword">of</span> int</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span class="keyword">type</span> unop</code><code> = <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../index.html#type-mat">mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec type" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span class="keyword">type</span> binop</code><code> = <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <span>?&#8288;c:<a href="../index.html#type-mat">mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt></dl></section><section><header><h6 id="creation-of-matrices"><a href="#creation-of-matrices" class="anchor"></a>Creation of matrices</h6></header><dl><dt class="spec value" id="val-hilbert"><a href="#val-hilbert" class="anchor"></a><code><span class="keyword">val</span> hilbert : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>hilbert n</code> </p><dl><dt>returns</dt><dd><p>an <code>n</code>x<code>n</code> Hilbert matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-hankel"><a href="#val-hankel" class="anchor"></a><code><span class="keyword">val</span> hankel : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>hankel n</code> </p><dl><dt>returns</dt><dd><p>an <code>n</code>x<code>n</code> Hankel matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pascal"><a href="#val-pascal" class="anchor"></a><code><span class="keyword">val</span> pascal : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>pascal n</code> </p><dl><dt>returns</dt><dd><p>an <code>n</code>x<code>n</code> Pascal matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rosser"><a href="#val-rosser" class="anchor"></a><code><span class="keyword">val</span> rosser : unit <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>rosser n</code> </p><dl><dt>returns</dt><dd><p>8x8 Rosser matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-toeplitz"><a href="#val-toeplitz" class="anchor"></a><code><span class="keyword">val</span> toeplitz : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>toeplitz v</code> </p><dl><dt>returns</dt><dd><p>the Toeplitz matrix associated with <code>v</code>. The constant diagonals are read from left to right from <code>v</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the length of <code>v</code> is not an odd number.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-vandermonde"><a href="#val-vandermonde" class="anchor"></a><code><span class="keyword">val</span> vandermonde : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>vandermonde v</code> </p><dl><dt>returns</dt><dd><p>the Vandermonde matrix associated with <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-wilkinson"><a href="#val-wilkinson" class="anchor"></a><code><span class="keyword">val</span> wilkinson : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>wilkinson n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>x<code>n</code> Wilkinson matrix.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> is not an odd number &gt;= 3.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val</span> random : <span>?&#8288;rnd_state:Stdlib.Random.State.t</span> <span>&#45;&gt;</span> <span>?&#8288;from:float</span> <span>&#45;&gt;</span> <span>?&#8288;range:float</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>random ?rnd_state ?from ?range m n</code> </p><dl><dt>returns</dt><dd><p>an <code>m</code>x<code>n</code> matrix initialized with random elements sampled uniformly from <code>range</code> starting at <code>from</code>. A random state <code>rnd_state</code> can be passed.</p></dd></dl><dl><dt>parameter rnd_state</dt><dd><p>default = Random.get_state ()</p></dd></dl><dl><dt>parameter from</dt><dd><p>default = -1.0</p></dd></dl><dl><dt>parameter range</dt><dd><p>default = 2.0</p></dd></dl></dd></dl></section><section><header><h6 id="unary-matrix-operations"><a href="#unary-matrix-operations" class="anchor"></a>Unary matrix operations</h6></header><dl><dt class="spec value" id="val-abs"><a href="#val-abs" class="anchor"></a><code><span class="keyword">val</span> abs : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>abs ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the absolute value of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-signum"><a href="#val-signum" class="anchor"></a><code><span class="keyword">val</span> signum : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>signum ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sign value (<code>-1</code> for negative numbers, <code>0</code> (or <code>-0</code>) for zero, <code>1</code> for positive numbers, <code>nan</code> for <code>nan</code>) of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqr"><a href="#val-sqr" class="anchor"></a><code><span class="keyword">val</span> sqr : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sqr ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><code><span class="keyword">val</span> sqrt : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sqrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square root of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cbrt"><a href="#val-cbrt" class="anchor"></a><code><span class="keyword">val</span> cbrt : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>cbrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cubic root of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp"><a href="#val-exp" class="anchor"></a><code><span class="keyword">val</span> exp : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>exp ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the exponential of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp2"><a href="#val-exp2" class="anchor"></a><code><span class="keyword">val</span> exp2 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>exp2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-2 exponential of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-expm1"><a href="#val-expm1" class="anchor"></a><code><span class="keyword">val</span> expm1 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>expm1 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code>exp a -. 1.</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log"><a href="#val-log" class="anchor"></a><code><span class="keyword">val</span> log : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log10"><a href="#val-log10" class="anchor"></a><code><span class="keyword">val</span> log10 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log10 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-10 logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log2"><a href="#val-log2" class="anchor"></a><code><span class="keyword">val</span> log2 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes base-2 logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log1p"><a href="#val-log1p" class="anchor"></a><code><span class="keyword">val</span> log1p : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log1p ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code>log (1 + a)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sin"><a href="#val-sin" class="anchor"></a><code><span class="keyword">val</span> sin : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cos"><a href="#val-cos" class="anchor"></a><code><span class="keyword">val</span> cos : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>cos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tan"><a href="#val-tan" class="anchor"></a><code><span class="keyword">val</span> tan : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>tan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asin"><a href="#val-asin" class="anchor"></a><code><span class="keyword">val</span> asin : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>asin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acos"><a href="#val-acos" class="anchor"></a><code><span class="keyword">val</span> acos : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>acos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan"><a href="#val-atan" class="anchor"></a><code><span class="keyword">val</span> atan : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>atan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sinh"><a href="#val-sinh" class="anchor"></a><code><span class="keyword">val</span> sinh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cosh"><a href="#val-cosh" class="anchor"></a><code><span class="keyword">val</span> cosh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>cosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tanh"><a href="#val-tanh" class="anchor"></a><code><span class="keyword">val</span> tanh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>tanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asinh"><a href="#val-asinh" class="anchor"></a><code><span class="keyword">val</span> asinh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>asinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acosh"><a href="#val-acosh" class="anchor"></a><code><span class="keyword">val</span> acosh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>acosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atanh"><a href="#val-atanh" class="anchor"></a><code><span class="keyword">val</span> atanh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>atanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-floor"><a href="#val-floor" class="anchor"></a><code><span class="keyword">val</span> floor : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>floor ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the floor of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ceil"><a href="#val-ceil" class="anchor"></a><code><span class="keyword">val</span> ceil : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>ceil ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the ceiling of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-round"><a href="#val-round" class="anchor"></a><code><span class="keyword">val</span> round : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>round ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> rounds the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trunc"><a href="#val-trunc" class="anchor"></a><code><span class="keyword">val</span> trunc : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>trunc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the truncation of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erf"><a href="#val-erf" class="anchor"></a><code><span class="keyword">val</span> erf : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>erf ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the error function of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erfc"><a href="#val-erfc" class="anchor"></a><code><span class="keyword">val</span> erfc : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>erfc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the complementary error function of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-logistic"><a href="#val-logistic" class="anchor"></a><code><span class="keyword">val</span> logistic : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>logistic ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logistic function <code>1/(1 + exp(-a)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-relu"><a href="#val-relu" class="anchor"></a><code><span class="keyword">val</span> relu : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>relu ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the rectified linear unit function <code>max(a, 0)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softplus"><a href="#val-softplus" class="anchor"></a><code><span class="keyword">val</span> softplus : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>softplus ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softplus function <code>log(1 + exp(x)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softsign"><a href="#val-softsign" class="anchor"></a><code><span class="keyword">val</span> softsign : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>softsign ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softsign function <code>x / (1 + abs(x))</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="binary-matrix-operations"><a href="#binary-matrix-operations" class="anchor"></a>Binary matrix operations</h6></header><dl><dt class="spec value" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span class="keyword">val</span> pow : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>pow ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>pow(a, b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan2"><a href="#val-atan2" class="anchor"></a><code><span class="keyword">val</span> atan2 : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>atan2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>atan2(a, b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><p>NOTE: WARNING! From a geometric point of view, the <code>atan2</code> function takes the y-coordinate in <code>a</code> and the x-coordinate in <code>b</code>. This confusion is a sad consequence of the C99-standard reversing the argument order for <code>atan2</code> for no good reason.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-hypot"><a href="#val-hypot" class="anchor"></a><code><span class="keyword">val</span> hypot : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>hypot ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>sqrt(a*a+b*b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min2"><a href="#val-min2" class="anchor"></a><code><span class="keyword">val</span> min2 : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>min2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise minimum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max2"><a href="#val-max2" class="anchor"></a><code><span class="keyword">val</span> max2 : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>max2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise maximum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sum_prod"><a href="#val-sum_prod" class="anchor"></a><code><span class="keyword">val</span> sum_prod : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sum_prod ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the sum of elementwise products between the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>.</p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="miscellaneous-functions"><a href="#miscellaneous-functions" class="anchor"></a>Miscellaneous functions</h6></header><dl><dt class="spec value" id="val-log_sum_exp"><a href="#val-log_sum_exp" class="anchor"></a><code><span class="keyword">val</span> log_sum_exp : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>log_sum_exp ?patt ?m ?n ?ar ?ac a</code> computes the logarithm of the sum of exponentials of all elements in the <code>m</code>-by-<code>n</code> submatrix using pattern <code>patt</code>, starting at row <code>ar</code> and column <code>ac</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl></dd></dl></section><section><header><h6 id="ternary-matrix-operations"><a href="#ternary-matrix-operations" class="anchor"></a>Ternary matrix operations</h6></header><dl><dt class="spec value" id="val-cpab"><a href="#val-cpab" class="anchor"></a><code><span class="keyword">val</span> cpab : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cpab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated <code>m</code>-by-<code>n</code> range of elements of matrices <code>a</code> and <code>b</code> using pattern <code>patt</code> elementwise and adds the result to and stores it in the specified range in <code>c</code>. This function is useful for convolutions. Similar to <code>Vec.zpxy</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cmab"><a href="#val-cmab" class="anchor"></a><code><span class="keyword">val</span> cmab : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cmab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated <code>m</code>-by-<code>n</code> range of elements of matrices <code>a</code> and <code>b</code> elementwise using pattern <code>patt</code> and subtracts the result from and stores it in the specified range in <code>c</code>. This function is useful for convolutions. Similar to <code>Vec.zmxy</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="creation-of-matrices-and-accessors"><a href="#creation-of-matrices-and-accessors" class="anchor"></a>Creation of matrices and accessors</h6></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>create m n</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>make m n x</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns initialized with value <code>x</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make0"><a href="#val-make0" class="anchor"></a><code><span class="keyword">val</span> make0 : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>make0 m n x</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns initialized with the zero element.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span><span>float array</span> array</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>of_array ar</code> </p><dl><dt>returns</dt><dd><p>a matrix initialized from the array of arrays <code>ar</code>. It is assumed that the OCaml matrix is in row major order (standard).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span><span>float array</span> array</span></code></dt><dd><p><code>to_array mat</code> </p><dl><dt>returns</dt><dd><p>an array of arrays initialized from matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><span>float list</span> list</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>of_list ls</code> </p><dl><dt>returns</dt><dd><p>a matrix initialized from the list of lists <code>ls</code>. Each sublist of <code>ls</code> represents a row of the desired matrix, and must be of the same length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span><span>float list</span> list</span></code></dt><dd><p><code>to_array mat</code> </p><dl><dt>returns</dt><dd><p><code>mat</code> in row major order as lists.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_col_vecs"><a href="#val-of_col_vecs" class="anchor"></a><code><span class="keyword">val</span> of_col_vecs : <span><a href="../index.html#type-vec">vec</a> array</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>of_col_vecs ar</code> </p><dl><dt>returns</dt><dd><p>a matrix whose columns are initialized from the array of vectors <code>ar</code>. The vectors must be of same length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_col_vecs"><a href="#val-to_col_vecs" class="anchor"></a><code><span class="keyword">val</span> to_col_vecs : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span><a href="../index.html#type-vec">vec</a> array</span></code></dt><dd><p><code>to_col_vecs mat</code> </p><dl><dt>returns</dt><dd><p>an array of column vectors initialized from matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_col_vecs_list"><a href="#val-of_col_vecs_list" class="anchor"></a><code><span class="keyword">val</span> of_col_vecs_list : <span><a href="../index.html#type-vec">vec</a> list</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>of_col_vecs_list ar</code> </p><dl><dt>returns</dt><dd><p>a matrix whose columns are initialized from the list of vectors <code>ar</code>. The vectors must be of same length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_col_vecs_list"><a href="#val-to_col_vecs_list" class="anchor"></a><code><span class="keyword">val</span> to_col_vecs_list : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span><a href="../index.html#type-vec">vec</a> list</span></code></dt><dd><p><code>to_col_vecs_list mat</code> </p><dl><dt>returns</dt><dd><p>a list of column vectors initialized from matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-as_vec"><a href="#val-as_vec" class="anchor"></a><code><span class="keyword">val</span> as_vec : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>as_vec mat</code> </p><dl><dt>returns</dt><dd><p>a vector containing all elements of the matrix in column-major order. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-init_rows"><a href="#val-init_rows" class="anchor"></a><code><span class="keyword">val</span> init_rows : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>init_cols m n f</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns, where each element at <code>row</code> and <code>col</code> is initialized by the result of calling <code>f row col</code>. The elements are passed row-wise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-init_cols"><a href="#val-init_cols" class="anchor"></a><code><span class="keyword">val</span> init_cols : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>init_cols m n f</code> </p><dl><dt>returns</dt><dd><p>a matrix containing <code>m</code> rows and <code>n</code> columns, where each element at <code>row</code> and <code>col</code> is initialized by the result of calling <code>f row col</code>. The elements are passed column-wise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_mvec"><a href="#val-create_mvec" class="anchor"></a><code><span class="keyword">val</span> create_mvec : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>create_mvec m</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column containing <code>m</code> rows.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make_mvec"><a href="#val-make_mvec" class="anchor"></a><code><span class="keyword">val</span> make_mvec : int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>make_mvec m x</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column containing <code>m</code> rows initialized with value <code>x</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mvec_of_array"><a href="#val-mvec_of_array" class="anchor"></a><code><span class="keyword">val</span> mvec_of_array : <span>float array</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>mvec_of_array ar</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column initialized with values from array <code>ar</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mvec_to_array"><a href="#val-mvec_to_array" class="anchor"></a><code><span class="keyword">val</span> mvec_to_array : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>float array</span></code></dt><dd><p><code>mvec_to_array mat</code> </p><dl><dt>returns</dt><dd><p>an array initialized with values from the first (not necessarily only) column vector of matrix <code>mat</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_col_vec"><a href="#val-from_col_vec" class="anchor"></a><code><span class="keyword">val</span> from_col_vec : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>from_col_vec v</code> </p><dl><dt>returns</dt><dd><p>a matrix with one column representing vector <code>v</code>. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_row_vec"><a href="#val-from_row_vec" class="anchor"></a><code><span class="keyword">val</span> from_row_vec : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>from_row_vec v</code> </p><dl><dt>returns</dt><dd><p>a matrix with one row representing vector <code>v</code>. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>empty</code>, the empty matrix.</p></dd></dl><dl><dt class="spec value" id="val-identity"><a href="#val-identity" class="anchor"></a><code><span class="keyword">val</span> identity : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>identity n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>x<code>n</code> identity matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_diag"><a href="#val-of_diag" class="anchor"></a><code><span class="keyword">val</span> of_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../index.html#type-mat">mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>of_diag ?n ?br ?bc ?b ?ofsx ?incx x</code> </p><dl><dt>returns</dt><dd><p>matrix <code>b</code> with diagonal elements in the designated sub-matrix coming from the designated sub-vector in <code>x</code>.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater <code>n</code> s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = minimal fresh matrix consistent with <code>n</code>, <code>br</code>, and <code>bc</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-dim1"><a href="#val-dim1" class="anchor"></a><code><span class="keyword">val</span> dim1 : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>dim1 m</code> </p><dl><dt>returns</dt><dd><p>the first dimension of matrix <code>m</code> (number of rows).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-dim2"><a href="#val-dim2" class="anchor"></a><code><span class="keyword">val</span> dim2 : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>dim2 m</code> </p><dl><dt>returns</dt><dd><p>the second dimension of matrix <code>m</code> (number of columns).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><code><span class="keyword">val</span> has_zero_dim : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_zero_dim mat</code> checks whether matrix <code>mat</code> has a dimension of size <code>zero</code>. In this case it cannot contain data.</p></dd></dl><dl><dt class="spec value" id="val-col"><a href="#val-col" class="anchor"></a><code><span class="keyword">val</span> col : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>col m n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>th column of matrix <code>m</code> as a vector. The data is shared.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy_row"><a href="#val-copy_row" class="anchor"></a><code><span class="keyword">val</span> copy_row : <span>?&#8288;vec:<a href="../index.html#type-vec">vec</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>copy_row ?vec mat int</code> </p><dl><dt>returns</dt><dd><p>a copy of the <code>n</code>th row of matrix <code>m</code> in vector <code>vec</code>.</p></dd></dl><dl><dt>parameter vec</dt><dd><p>default = fresh vector of length <code>dim2 mat</code></p></dd></dl></dd></dl></section><section><header><h6 id="matrix-transformations"><a href="#matrix-transformations" class="anchor"></a>Matrix transformations</h6></header><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val</span> swap : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> swaps the contents of (sub-matrices) <code>a</code> and <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-transpose_copy"><a href="#val-transpose_copy" class="anchor"></a><code><span class="keyword">val</span> transpose_copy : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../index.html#type-mat">mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>transpose_copy ?m ?n ?br ?bc ?b ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the transpose of (sub-)matrix <code>a</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. NOTE: this operations does _not_ support in-place transposes!</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + n - 1</code> rows and <code>bc + m - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-detri"><a href="#val-detri" class="anchor"></a><code><span class="keyword">val</span> detri : <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>detri ?up ?n ?ar ?ac a</code> takes a triangular (sub-)matrix <code>a</code>, i.e. one where only the upper (iff <code>up</code> is true) or lower triangle is defined, and makes it a symmetric matrix by mirroring the defined triangle along the diagonal.</p><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-packed"><a href="#val-packed" class="anchor"></a><code><span class="keyword">val</span> packed : <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>packed ?up ?n ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>(sub-)matrix <code>a</code> in packed storage format.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-unpacked"><a href="#val-unpacked" class="anchor"></a><code><span class="keyword">val</span> unpacked : <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>unpacked ?up x</code> </p><dl><dt>returns</dt><dd><p>an upper or lower (depending on <code>up</code>) triangular matrix from packed representation <code>vec</code>. The other triangle of the matrix will be filled with zeros.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Vec.dim x</code></p></dd></dl></dd></dl></section><section><header><h6 id="operations-on-one-matrix"><a href="#operations-on-one-matrix" class="anchor"></a>Operations on one matrix</h6></header><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill ?patt ?m ?n ?ar ?ac a x</code> fills the specified sub-matrix in <code>a</code> with value <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sum ?patt ?m ?n ?ar ?ac a</code> computes the sum of all elements in the <code>m</code>-by-<code>n</code> submatrix using pattern <code>patt</code>, starting at row <code>ar</code> and column <code>ac</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_const"><a href="#val-add_const" class="anchor"></a><code><span class="keyword">val</span> add_const : float <span>&#45;&gt;</span> <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>add_const c ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> adds constant <code>c</code> to the designated <code>m</code> by <code>n</code> submatrix in <code>a</code> using pattern <code>patt</code> and stores the result in the designated submatrix in <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = <code>Mat.dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size <code>m</code> by <code>n</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_const_diag"><a href="#val-add_const_diag" class="anchor"></a><code><span class="keyword">val</span> add_const_diag : float <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_const c ?n ?ar ?ac a</code> adds constant <code>c</code> to the diagonal of the designated <code>n</code> by <code>n</code> submatrix in <code>a</code>.</p><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val</span> neg : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>neg ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the negative of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reci"><a href="#val-reci" class="anchor"></a><code><span class="keyword">val</span> reci : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>reci ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the reciprocal of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy_diag"><a href="#val-copy_diag" class="anchor"></a><code><span class="keyword">val</span> copy_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../index.html#type-vec">vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>copy_diag ?n ?ofsy ?incy ?y ?ar ?ac a</code> </p><dl><dt>returns</dt><dd><p>the diagonal of the (sub-)matrix <code>a</code> in a (sub-)vector.</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greatest <code>n</code> that does not exceed matrix dimensions</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of length <code>n</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span class="keyword">val</span> trace : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>trace m</code> </p><dl><dt>returns</dt><dd><p>the trace of matrix <code>m</code>. If <code>m</code> is not a square matrix, the sum of the longest possible sequence of diagonal elements will be returned.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-scal"><a href="#val-scal" class="anchor"></a><code><span class="keyword">val</span> scal : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal ?patt ?m ?n alpha ?ar ?ac a</code> BLAS <code>scal</code> function for (sub-)matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_cols"><a href="#val-scal_cols" class="anchor"></a><code><span class="keyword">val</span> scal_cols : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;ofs:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_cols ?patt ?m ?n ?ar ?ac a ?ofs alphas</code> column-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_rows"><a href="#val-scal_rows" class="anchor"></a><code><span class="keyword">val</span> scal_rows : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofs:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_rows ?patt ?m ?n ?ofs alphas ?ar ?ac a</code> row-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-syrk_trace"><a href="#val-syrk_trace" class="anchor"></a><code><span class="keyword">val</span> syrk_trace : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>syrk_trace ?n ?k ?ar ?ac a</code> computes the trace of either <code>a' * a</code> or <code>a * a'</code>, whichever is more efficient (results are identical), of the (sub-)matrix <code>a</code> multiplied by its own transpose. This is the same as the square of the Frobenius norm of a matrix. <code>n</code> is the number of rows to consider in <code>a</code>, and <code>k</code> the number of columns to consider.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syrk_diag"><a href="#val-syrk_diag" class="anchor"></a><code><span class="keyword">val</span> syrk_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../index.html#type-vec">vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>syrk_diag ?n ?k ?beta ?ofsy ?y ?trans ?alpha ?ar ?ac a</code> computes the diagonal of the symmetric rank-k product of the (sub-)matrix <code>a</code>, multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrix will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl></section><section><header><h6 id="operations-on-two-matrices"><a href="#operations-on-two-matrices" class="anchor"></a>Operations on two matrices</h6></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>add ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the sum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>sub ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the difference of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val</span> mul : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>mul ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the element-wise product of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><p>NOTE: please do not confuse this function with matrix multiplication! The LAPACK-function for matrix multiplication is called <code>gemm</code>, e.g. <code>Lacaml.D.gemm</code>.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val</span> div : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>div ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the division of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-axpy"><a href="#val-axpy" class="anchor"></a><code><span class="keyword">val</span> axpy : <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;xr:int</span> <span>&#45;&gt;</span> <span>?&#8288;xc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;yr:int</span> <span>&#45;&gt;</span> <span>?&#8288;yc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>axpy ?alpha ?patt ?m ?n ?xr ?xc x ?yr ?yc y</code> BLAS <code>axpy</code> function for matrices.</p><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>xr + m - 1 &lt;= dim1 x</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>xc + n - 1 &lt;= dim2 x</code></p></dd></dl><dl><dt>parameter xr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter xc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_diag"><a href="#val-gemm_diag" class="anchor"></a><code><span class="keyword">val</span> gemm_diag : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="../index.html#type-vec">vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;transa:<a href="../index.html#type-trans3">trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;transb:<a href="../index.html#type-trans3">trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>gemm_diag ?n ?k ?beta ?ofsy ?y ?transa ?transb ?alpha ?ar ?ac a ?br ?bc b</code> computes the diagonal of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing), multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrices will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_trace"><a href="#val-gemm_trace" class="anchor"></a><code><span class="keyword">val</span> gemm_trace : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;transa:<a href="../index.html#type-trans3">trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;transb:<a href="../index.html#type-trans3">trans3</a></span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>gemm_trace ?n ?k ?transa ?ar ?ac a ?transb ?br ?bc b</code> computes the trace of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing). When transposing <code>a</code>, this yields the so-called Frobenius product of <code>a</code> and <code>b</code>. <code>n</code> is the number of rows (columns) to consider in <code>a</code> and the number of columns (rows) in <code>b</code>. <code>k</code> is the inner dimension to use for the product.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-symm2_trace"><a href="#val-symm2_trace" class="anchor"></a><code><span class="keyword">val</span> symm2_trace : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;upa:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;upb:bool</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>symm2_trace ?n ?upa ?ar ?ac a ?upb ?br ?bc b</code> computes the trace of the product of the symmetric (sub-)matrices <code>a</code> and <code>b</code>. <code>n</code> is the number of rows and columns to consider in <code>a</code> and <code>b</code>.</p><dl><dt>parameter n</dt><dd><p>default = dimensions of <code>a</code> and <code>b</code></p></dd></dl><dl><dt>parameter upa</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter upb</dt><dd><p>default = true (upper triangular portion of <code>b</code> is accessed)</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><code><span class="keyword">val</span> ssqr_diff : <span>?&#8288;patt:<a href="index.html#type-patt">patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>ssqr_diff ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the sum of squared differences between the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>.</p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="iterators-over-matrices"><a href="#iterators-over-matrices" class="anchor"></a>Iterators over matrices</h6></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(float <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <span>?&#8288;b:<a href="../index.html#type-mat">mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>map f ?m ?n ?br ?bc ?b ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>matrix with <code>f</code> applied to each element of <code>a</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size m by n</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_cols"><a href="#val-fold_cols" class="anchor"></a><code><span class="keyword">val</span> fold_cols : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_cols f ?n ?ac acc a</code></p><dl><dt>returns</dt><dd><p>accumulator resulting from folding over each column vector.</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl></dd></dl></section></div></body></html>