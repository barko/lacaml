<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mat (lacaml.Lacaml__D.Mat)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">lacaml</a> &#x00BB; <a href="../index.html">Lacaml__D</a> &#x00BB; Mat</nav><h1>Module <code>Lacaml__D.Mat</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="../index.html#type-mat">mat</a></code></dt></dl><section><header><h4 id="matrix-operations"><a href="#matrix-operations" class="anchor"></a>Matrix operations</h4></header><dl><dt class="spec type" id="type-patt"><a href="#type-patt" class="anchor"></a><code><span class="keyword">type </span>patt</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-patt.Full" class="anchored"><td class="def constructor"><a href="#type-patt.Full" class="anchor"></a><code><span class="keyword">| </span></code><code>`Full</code></td></tr><tr id="type-patt.Utr" class="anchored"><td class="def constructor"><a href="#type-patt.Utr" class="anchor"></a><code><span class="keyword">| </span></code><code>`Utr</code></td></tr><tr id="type-patt.Ltr" class="anchored"><td class="def constructor"><a href="#type-patt.Ltr" class="anchor"></a><code><span class="keyword">| </span></code><code>`Ltr</code></td></tr><tr id="type-patt.Upent" class="anchored"><td class="def constructor"><a href="#type-patt.Upent" class="anchor"></a><code><span class="keyword">| </span></code><code>`Upent<span class="keyword"> of </span>int</code></td></tr><tr id="type-patt.Lpent" class="anchored"><td class="def constructor"><a href="#type-patt.Lpent" class="anchor"></a><code><span class="keyword">| </span></code><code>`Lpent<span class="keyword"> of </span>int</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span class="keyword">type </span>unop</code><code><span class="keyword"> = </span>?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec type" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span class="keyword">type </span>binop</code><code><span class="keyword"> = </span>?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;cr:int <span>&#45;&gt;</span> ?&#8288;cc:int <span>&#45;&gt;</span> ?&#8288;c:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt></dl></section><section><header><h4 id="creation-of-matrices"><a href="#creation-of-matrices" class="anchor"></a>Creation of matrices</h4></header><dl><dt class="spec value" id="val-hilbert"><a href="#val-hilbert" class="anchor"></a><code><span class="keyword">val </span>hilbert : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-hankel"><a href="#val-hankel" class="anchor"></a><code><span class="keyword">val </span>hankel : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-pascal"><a href="#val-pascal" class="anchor"></a><code><span class="keyword">val </span>pascal : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-rosser"><a href="#val-rosser" class="anchor"></a><code><span class="keyword">val </span>rosser : unit <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-toeplitz"><a href="#val-toeplitz" class="anchor"></a><code><span class="keyword">val </span>toeplitz : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-vandermonde"><a href="#val-vandermonde" class="anchor"></a><code><span class="keyword">val </span>vandermonde : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-wilkinson"><a href="#val-wilkinson" class="anchor"></a><code><span class="keyword">val </span>wilkinson : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val </span>random : ?&#8288;rnd_state:Stdlib.Random.State.t <span>&#45;&gt;</span> ?&#8288;from:float <span>&#45;&gt;</span> ?&#8288;range:float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt></dl></section><section><header><h4 id="unary-matrix-operations"><a href="#unary-matrix-operations" class="anchor"></a>Unary matrix operations</h4></header><dl><dt class="spec value" id="val-abs"><a href="#val-abs" class="anchor"></a><code><span class="keyword">val </span>abs : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>abs ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the absolute value of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-signum"><a href="#val-signum" class="anchor"></a><code><span class="keyword">val </span>signum : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>signum ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sign value (<code>-1</code> for negative numbers, <code>0</code> (or <code>-0</code>) for zero, <code>1</code> for positive numbers, <code>nan</code> for <code>nan</code>) of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqr"><a href="#val-sqr" class="anchor"></a><code><span class="keyword">val </span>sqr : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sqr ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><code><span class="keyword">val </span>sqrt : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sqrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square root of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cbrt"><a href="#val-cbrt" class="anchor"></a><code><span class="keyword">val </span>cbrt : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>cbrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cubic root of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp"><a href="#val-exp" class="anchor"></a><code><span class="keyword">val </span>exp : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>exp ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the exponential of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp2"><a href="#val-exp2" class="anchor"></a><code><span class="keyword">val </span>exp2 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>exp2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-2 exponential of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-expm1"><a href="#val-expm1" class="anchor"></a><code><span class="keyword">val </span>expm1 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>expm1 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code>exp a -. 1.</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log"><a href="#val-log" class="anchor"></a><code><span class="keyword">val </span>log : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log10"><a href="#val-log10" class="anchor"></a><code><span class="keyword">val </span>log10 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log10 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-10 logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log2"><a href="#val-log2" class="anchor"></a><code><span class="keyword">val </span>log2 : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes base-2 logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log1p"><a href="#val-log1p" class="anchor"></a><code><span class="keyword">val </span>log1p : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>log1p ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code>log (1 + a)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sin"><a href="#val-sin" class="anchor"></a><code><span class="keyword">val </span>sin : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cos"><a href="#val-cos" class="anchor"></a><code><span class="keyword">val </span>cos : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>cos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tan"><a href="#val-tan" class="anchor"></a><code><span class="keyword">val </span>tan : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>tan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asin"><a href="#val-asin" class="anchor"></a><code><span class="keyword">val </span>asin : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>asin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acos"><a href="#val-acos" class="anchor"></a><code><span class="keyword">val </span>acos : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>acos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan"><a href="#val-atan" class="anchor"></a><code><span class="keyword">val </span>atan : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>atan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sinh"><a href="#val-sinh" class="anchor"></a><code><span class="keyword">val </span>sinh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>sinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cosh"><a href="#val-cosh" class="anchor"></a><code><span class="keyword">val </span>cosh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>cosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tanh"><a href="#val-tanh" class="anchor"></a><code><span class="keyword">val </span>tanh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>tanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asinh"><a href="#val-asinh" class="anchor"></a><code><span class="keyword">val </span>asinh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>asinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acosh"><a href="#val-acosh" class="anchor"></a><code><span class="keyword">val </span>acosh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>acosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atanh"><a href="#val-atanh" class="anchor"></a><code><span class="keyword">val </span>atanh : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>atanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-floor"><a href="#val-floor" class="anchor"></a><code><span class="keyword">val </span>floor : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>floor ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the floor of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ceil"><a href="#val-ceil" class="anchor"></a><code><span class="keyword">val </span>ceil : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>ceil ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the ceiling of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-round"><a href="#val-round" class="anchor"></a><code><span class="keyword">val </span>round : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>round ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> rounds the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trunc"><a href="#val-trunc" class="anchor"></a><code><span class="keyword">val </span>trunc : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>trunc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the truncation of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erf"><a href="#val-erf" class="anchor"></a><code><span class="keyword">val </span>erf : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>erf ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the error function of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erfc"><a href="#val-erfc" class="anchor"></a><code><span class="keyword">val </span>erfc : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>erfc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the complementary error function of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-logistic"><a href="#val-logistic" class="anchor"></a><code><span class="keyword">val </span>logistic : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>logistic ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logistic function <code>1/(1 + exp(-a)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-relu"><a href="#val-relu" class="anchor"></a><code><span class="keyword">val </span>relu : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>relu ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the rectified linear unit function <code>max(a, 0)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softplus"><a href="#val-softplus" class="anchor"></a><code><span class="keyword">val </span>softplus : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>softplus ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softplus function <code>log(1 + exp(x)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softsign"><a href="#val-softsign" class="anchor"></a><code><span class="keyword">val </span>softsign : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>softsign ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softsign function <code>x / (1 + abs(x))</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h4 id="binary-matrix-operations"><a href="#binary-matrix-operations" class="anchor"></a>Binary matrix operations</h4></header><dl><dt class="spec value" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span class="keyword">val </span>pow : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>pow ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>pow(a, b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan2"><a href="#val-atan2" class="anchor"></a><code><span class="keyword">val </span>atan2 : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>atan2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>atan2(a, b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><p>NOTE: WARNING! From a geometric point of view, the <code>atan2</code> function takes the y-coordinate in <code>a</code> and the x-coordinate in <code>b</code>. This confusion is a sad consequence of the C99-standard reversing the argument order for <code>atan2</code> for no good reason.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-hypot"><a href="#val-hypot" class="anchor"></a><code><span class="keyword">val </span>hypot : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>hypot ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>sqrt(a*a+b*b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min2"><a href="#val-min2" class="anchor"></a><code><span class="keyword">val </span>min2 : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>min2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise minimum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max2"><a href="#val-max2" class="anchor"></a><code><span class="keyword">val </span>max2 : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>max2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise maximum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sum_prod"><a href="#val-sum_prod" class="anchor"></a><code><span class="keyword">val </span>sum_prod : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt></dl></section><section><header><h4 id="miscellaneous-functions"><a href="#miscellaneous-functions" class="anchor"></a>Miscellaneous functions</h4></header><dl><dt class="spec value" id="val-log_sum_exp"><a href="#val-log_sum_exp" class="anchor"></a><code><span class="keyword">val </span>log_sum_exp : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>log_sum_exp ?patt ?m ?n ?ar ?ac a</code> computes the logarithm of the sum of exponentials of all elements in the <code>m</code>-by-<code>n</code> submatrix using pattern <code>patt</code>, starting at row <code>ar</code> and column <code>ac</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl></dd></dl></section><section><header><h4 id="ternary-matrix-operations"><a href="#ternary-matrix-operations" class="anchor"></a>Ternary matrix operations</h4></header><dl><dt class="spec value" id="val-cpab"><a href="#val-cpab" class="anchor"></a><code><span class="keyword">val </span>cpab : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;cr:int <span>&#45;&gt;</span> ?&#8288;cc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cpab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated <code>m</code>-by-<code>n</code> range of elements of matrices <code>a</code> and <code>b</code> using pattern <code>patt</code> elementwise and adds the result to and stores it in the specified range in <code>c</code>. This function is useful for convolutions. Similar to <code>Vec.zpxy</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cmab"><a href="#val-cmab" class="anchor"></a><code><span class="keyword">val </span>cmab : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;cr:int <span>&#45;&gt;</span> ?&#8288;cc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cmab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated <code>m</code>-by-<code>n</code> range of elements of matrices <code>a</code> and <code>b</code> elementwise using pattern <code>patt</code> and subtracts the result from and stores it in the specified range in <code>c</code>. This function is useful for convolutions. Similar to <code>Vec.zmxy</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h4 id="creation-of-matrices-and-accessors"><a href="#creation-of-matrices-and-accessors" class="anchor"></a>Creation of matrices and accessors</h4></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-make0"><a href="#val-make0" class="anchor"></a><code><span class="keyword">val </span>make0 : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val </span>of_array : float array array <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float array array</code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : float list list <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float list list</code></dt><dt class="spec value" id="val-of_col_vecs"><a href="#val-of_col_vecs" class="anchor"></a><code><span class="keyword">val </span>of_col_vecs : <a href="../index.html#type-vec">vec</a> array <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_col_vecs"><a href="#val-to_col_vecs" class="anchor"></a><code><span class="keyword">val </span>to_col_vecs : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> array</code></dt><dt class="spec value" id="val-of_col_vecs_list"><a href="#val-of_col_vecs_list" class="anchor"></a><code><span class="keyword">val </span>of_col_vecs_list : <a href="../index.html#type-vec">vec</a> list <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-to_col_vecs_list"><a href="#val-to_col_vecs_list" class="anchor"></a><code><span class="keyword">val </span>to_col_vecs_list : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> list</code></dt><dt class="spec value" id="val-as_vec"><a href="#val-as_vec" class="anchor"></a><code><span class="keyword">val </span>as_vec : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-init_rows"><a href="#val-init_rows" class="anchor"></a><code><span class="keyword">val </span>init_rows : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float) <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-init_cols"><a href="#val-init_cols" class="anchor"></a><code><span class="keyword">val </span>init_cols : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float) <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-create_mvec"><a href="#val-create_mvec" class="anchor"></a><code><span class="keyword">val </span>create_mvec : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-make_mvec"><a href="#val-make_mvec" class="anchor"></a><code><span class="keyword">val </span>make_mvec : int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-mvec_of_array"><a href="#val-mvec_of_array" class="anchor"></a><code><span class="keyword">val </span>mvec_of_array : float array <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-mvec_to_array"><a href="#val-mvec_to_array" class="anchor"></a><code><span class="keyword">val </span>mvec_to_array : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float array</code></dt><dt class="spec value" id="val-from_col_vec"><a href="#val-from_col_vec" class="anchor"></a><code><span class="keyword">val </span>from_col_vec : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-from_row_vec"><a href="#val-from_row_vec" class="anchor"></a><code><span class="keyword">val </span>from_row_vec : <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>empty</code>, the empty matrix.</p></dd></dl><dl><dt class="spec value" id="val-identity"><a href="#val-identity" class="anchor"></a><code><span class="keyword">val </span>identity : int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-of_diag"><a href="#val-of_diag" class="anchor"></a><code><span class="keyword">val </span>of_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-dim1"><a href="#val-dim1" class="anchor"></a><code><span class="keyword">val </span>dim1 : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-dim2"><a href="#val-dim2" class="anchor"></a><code><span class="keyword">val </span>dim2 : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-has_zero_dim"><a href="#val-has_zero_dim" class="anchor"></a><code><span class="keyword">val </span>has_zero_dim : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_zero_dim mat</code> checks whether matrix <code>mat</code> has a dimension of size <code>zero</code>. In this case it cannot contain data.</p></dd></dl><dl><dt class="spec value" id="val-col"><a href="#val-col" class="anchor"></a><code><span class="keyword">val </span>col : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-copy_row"><a href="#val-copy_row" class="anchor"></a><code><span class="keyword">val </span>copy_row : ?&#8288;vec:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt></dl></section><section><header><h4 id="matrix-transformations"><a href="#matrix-transformations" class="anchor"></a>Matrix transformations</h4></header><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val </span>swap : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> swaps the contents of (sub-matrices) <code>a</code> and <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-transpose_copy"><a href="#val-transpose_copy" class="anchor"></a><code><span class="keyword">val </span>transpose_copy : ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dt class="spec value" id="val-detri"><a href="#val-detri" class="anchor"></a><code><span class="keyword">val </span>detri : ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>detri ?up ?n ?ar ?ac a</code> takes a triangular (sub-)matrix <code>a</code>, i.e. one where only the upper (iff <code>up</code> is true) or lower triangle is defined, and makes it a symmetric matrix by mirroring the defined triangle along the diagonal.</p><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-packed"><a href="#val-packed" class="anchor"></a><code><span class="keyword">val </span>packed : ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-unpacked"><a href="#val-unpacked" class="anchor"></a><code><span class="keyword">val </span>unpacked : ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt></dl></section><section><header><h4 id="operations-on-one-matrix"><a href="#operations-on-one-matrix" class="anchor"></a>Operations on one matrix</h4></header><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val </span>fill : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill ?patt ?m ?n ?ar ?ac a x</code> fills the specified sub-matrix in <code>a</code> with value <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val </span>sum : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sum ?patt ?m ?n ?ar ?ac a</code> computes the sum of all elements in the <code>m</code>-by-<code>n</code> submatrix using pattern <code>patt</code>, starting at row <code>ar</code> and column <code>ac</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_const"><a href="#val-add_const" class="anchor"></a><code><span class="keyword">val </span>add_const : float <span>&#45;&gt;</span> <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>add_const c ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> adds constant <code>c</code> to the designated <code>m</code> by <code>n</code> submatrix in <code>a</code> using pattern <code>patt</code> and stores the result in the designated submatrix in <code>b</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = <code>Mat.dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size <code>m</code> by <code>n</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_const_diag"><a href="#val-add_const_diag" class="anchor"></a><code><span class="keyword">val </span>add_const_diag : float <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_const c ?n ?ar ?ac a</code> adds constant <code>c</code> to the diagonal of the designated <code>n</code> by <code>n</code> submatrix in <code>a</code>.</p><dl><dt>parameter n</dt><dd><p>default = <code>Mat.dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val </span>neg : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>neg ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the negative of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reci"><a href="#val-reci" class="anchor"></a><code><span class="keyword">val </span>reci : <a href="index.html#type-unop">unop</a></code></dt><dd><p><code>reci ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the reciprocal of the elements in the <code>m</code> by <code>n</code> (sub-)matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy_diag"><a href="#val-copy_diag" class="anchor"></a><code><span class="keyword">val </span>copy_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;incy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dt class="spec value" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span class="keyword">val </span>trace : <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dt class="spec value" id="val-scal"><a href="#val-scal" class="anchor"></a><code><span class="keyword">val </span>scal : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal ?patt ?m ?n alpha ?ar ?ac a</code> BLAS <code>scal</code> function for (sub-)matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_cols"><a href="#val-scal_cols" class="anchor"></a><code><span class="keyword">val </span>scal_cols : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ofs:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_cols ?patt ?m ?n ?ar ?ac a ?ofs alphas</code> column-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-scal_rows"><a href="#val-scal_rows" class="anchor"></a><code><span class="keyword">val </span>scal_rows : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofs:int <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal_rows ?patt ?m ?n ?ofs alphas ?ar ?ac a</code> row-wise <code>scal</code> function for matrices.</p></dd></dl><dl><dt class="spec value" id="val-syrk_trace"><a href="#val-syrk_trace" class="anchor"></a><code><span class="keyword">val </span>syrk_trace : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>syrk_trace ?n ?k ?ar ?ac a</code> computes the trace of either <code>a' * a</code> or <code>a * a'</code>, whichever is more efficient (results are identical), of the (sub-)matrix <code>a</code> multiplied by its own transpose. This is the same as the square of the Frobenius norm of a matrix. <code>n</code> is the number of rows to consider in <code>a</code>, and <code>k</code> the number of columns to consider.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syrk_diag"><a href="#val-syrk_diag" class="anchor"></a><code><span class="keyword">val </span>syrk_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;beta:float <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;trans:<a href="../../Lacaml/Common/index.html#type-trans2">Lacaml.Common.trans2</a> <span>&#45;&gt;</span> ?&#8288;alpha:float <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>syrk_diag ?n ?k ?beta ?ofsy ?y ?trans ?alpha ?ar ?ac a</code> computes the diagonal of the symmetric rank-k product of the (sub-)matrix <code>a</code>, multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrix will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr<code>a</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl></section><section><header><h4 id="operations-on-two-matrices"><a href="#operations-on-two-matrices" class="anchor"></a>Operations on two matrices</h4></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val </span>add : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>add ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the sum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>sub ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the difference of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val </span>mul : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>mul ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the element-wise product of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><p>NOTE: please do not confuse this function with matrix multiplication! The LAPACK-function for matrix multiplication is called <code>gemm</code>, e.g. <code>Lacaml.D.gemm</code>.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val </span>div : <a href="index.html#type-binop">binop</a></code></dt><dd><p><code>div ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the division of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-axpy"><a href="#val-axpy" class="anchor"></a><code><span class="keyword">val </span>axpy : ?&#8288;alpha:float <span>&#45;&gt;</span> ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;xr:int <span>&#45;&gt;</span> ?&#8288;xc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;yr:int <span>&#45;&gt;</span> ?&#8288;yc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>axpy ?alpha ?patt ?m ?n ?xr ?xc x ?yr ?yc y</code> BLAS <code>axpy</code> function for matrices.</p><dl><dt>parameter alpha</dt><dd><p>default = <code>{ re = 1.; im = 0. }</code></p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>xr + m - 1 &lt;= dim1 x</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>xc + n - 1 &lt;= dim2 x</code></p></dd></dl><dl><dt>parameter xr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter xc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter yc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_diag"><a href="#val-gemm_diag" class="anchor"></a><code><span class="keyword">val </span>gemm_diag : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;beta:float <span>&#45;&gt;</span> ?&#8288;ofsy:int <span>&#45;&gt;</span> ?&#8288;y:<a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;transa:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:float <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;transb:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a></code></dt><dd><p><code>gemm_diag ?n ?k ?beta ?ofsy ?y ?transa ?transb ?alpha ?ar ?ac a ?br ?bc b</code> computes the diagonal of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing), multiplying it with <code>alpha</code> and adding <code>beta</code> times <code>y</code>, storing the result in <code>y</code> starting at the specified offset. <code>n</code> elements of the diagonal will be computed, and <code>k</code> elements of the matrices will be part of the dot product associated with each diagonal element.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector of size <code>n + ofsy - 1</code></p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gemm_trace"><a href="#val-gemm_trace" class="anchor"></a><code><span class="keyword">val </span>gemm_trace : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;k:int <span>&#45;&gt;</span> ?&#8288;transa:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;transb:<a href="../index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>gemm_trace ?n ?k ?transa ?ar ?ac a ?transb ?br ?bc b</code> computes the trace of the product of the (sub-)matrices <code>a</code> and <code>b</code> (taking into account potential transposing). When transposing <code>a</code>, this yields the so-called Frobenius product of <code>a</code> and <code>b</code>. <code>n</code> is the number of rows (columns) to consider in <code>a</code> and the number of columns (rows) in <code>b</code>. <code>k</code> is the inner dimension to use for the product.</p><dl><dt>parameter n</dt><dd><p>default = number of rows of <code>a</code> (or tr <code>a</code>) and number of columns of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter k</dt><dd><p>default = number of columns of <code>a</code> (or tr <code>a</code>) and number of rows of <code>b</code> (or tr <code>b</code>)</p></dd></dl><dl><dt>parameter transa</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>default = <code>`N</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-symm2_trace"><a href="#val-symm2_trace" class="anchor"></a><code><span class="keyword">val </span>symm2_trace : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;upa:bool <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;upb:bool <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>symm2_trace ?n ?upa ?ar ?ac a ?upb ?br ?bc b</code> computes the trace of the product of the symmetric (sub-)matrices <code>a</code> and <code>b</code>. <code>n</code> is the number of rows and columns to consider in <code>a</code> and <code>b</code>.</p><dl><dt>parameter n</dt><dd><p>default = dimensions of <code>a</code> and <code>b</code></p></dd></dl><dl><dt>parameter upa</dt><dd><p>default = true (upper triangular portion of <code>a</code> is accessed)</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter upb</dt><dd><p>default = true (upper triangular portion of <code>b</code> is accessed)</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = <code>1</code></p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = <code>1</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ssqr_diff"><a href="#val-ssqr_diff" class="anchor"></a><code><span class="keyword">val </span>ssqr_diff : ?&#8288;patt:<a href="index.html#type-patt">patt</a> <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt></dl></section><section><header><h4 id="iterators-over-matrices"><a href="#iterators-over-matrices" class="anchor"></a>Iterators over matrices</h4></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (float <span>&#45;&gt;</span> float) <span>&#45;&gt;</span> ?&#8288;m:int <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;br:int <span>&#45;&gt;</span> ?&#8288;bc:int <span>&#45;&gt;</span> ?&#8288;b:<a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;ar:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a></code></dt><dd><p><code>map f ?m ?n ?br ?bc ?b ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>matrix with <code>f</code> applied to each element of <code>a</code>.</p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix of size m by n</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_cols"><a href="#val-fold_cols" class="anchor"></a><code><span class="keyword">val </span>fold_cols : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../index.html#type-vec">vec</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ac:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_cols f ?n ?ac acc a</code></p><dl><dt>returns</dt><dd><p>accumulator resulting from folding over each column vector.</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl></dd></dl></section></div></body></html>