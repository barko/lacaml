<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lacaml__Impl2_C (lacaml.Lacaml__Impl2_C)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">lacaml</a> &#x00BB; Lacaml__Impl2_C</nav><h1>Module <code>Lacaml__Impl2_C</code></h1><h6 id="blas-1-interface"><a href="#blas-1-interface" class="anchor"></a>BLAS-1 interface</h6><nav class="toc"><ul><li><a href="#lapack-interface">LAPACK interface</a></li><li><a href="#general-schur-factorization">General Schur factorization</a></li><li><a href="#general-svd-routines">General SVD routines</a></li><li><a href="#general-eigenvalue-problem-(simple-drivers)">General eigenvalue problem (simple drivers)</a></li></ul></nav></header><dl><dt class="spec value" id="val-dotu"><a href="#val-dotu" class="anchor"></a><code><span class="keyword">val</span> dotu : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>dotu ?n ?ofsx ?incx x ?ofsy ?incy y</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-dotc"><a href="#val-dotc" class="anchor"></a><code><span class="keyword">val</span> dotc : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ofsx:int</span> <span>&#45;&gt;</span> <span>?&#8288;incx:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a> <span>&#45;&gt;</span> <span>?&#8288;ofsy:int</span> <span>&#45;&gt;</span> <span>?&#8288;incy:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a> <span>&#45;&gt;</span> Stdlib.Complex.t</code></dt><dd><p><code>dotc ?n ?ofsx ?incx x ?ofsy ?incy y</code> see BLAS documentation!</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><section><header><h6 id="lapack-interface"><a href="#lapack-interface" class="anchor"></a>LAPACK interface</h6></header><dl><dt class="spec value" id="val-lansy_min_lwork"><a href="#val-lansy_min_lwork" class="anchor"></a><code><span class="keyword">val</span> lansy_min_lwork : int <span>&#45;&gt;</span> <a href="../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>lansy_min_lwork m norm</code></p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>lansy</code>-function.</p></dd></dl><dl><dt>parameter norm</dt><dd><p>type of norm that will be computed by <code>lansy</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns (and rows) in the matrix</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lansy"><a href="#val-lansy" class="anchor"></a><code><span class="keyword">val</span> lansy : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;norm:<a href="../Lacaml/Common/index.html#type-norm4">Lacaml.Common.norm4</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Lacaml__/Complex32/index.html#type-rvec">Lacaml__.Complex32.rvec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>lansy ?n ?up ?norm ?work ?ar ?ac a</code> see LAPACK documentation!</p><dl><dt>parameter norm</dt><dd><p>default = `O</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = true (reference upper triangular part of <code>a</code>)</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = allocated work space for norm `I</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gecon_min_lwork"><a href="#val-gecon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gecon_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>gecon_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>gecon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to the <code>gecon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gecon_min_lrwork"><a href="#val-gecon_min_lrwork" class="anchor"></a><code><span class="keyword">val</span> gecon_min_lrwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>gecon_min_lrwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the rwork array used by the <code>gecon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>gecon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gecon"><a href="#val-gecon" class="anchor"></a><code><span class="keyword">val</span> gecon : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;norm:<a href="../Lacaml/Common/index.html#type-norm2">Lacaml.Common.norm2</a></span> <span>&#45;&gt;</span> <span>?&#8288;anorm:float</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;rwork:<a href="../Lacaml__/Complex32/index.html#type-rvec">Lacaml__.Complex32.rvec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>gecon ?n ?norm ?anorm ?work ?rwork ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>estimate of the reciprocal of the condition number of matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter norm</dt><dd><p>default = 1-norm</p></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = norm of the matrix <code>a</code> as returned by <code>lange</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter rwork</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sycon_min_lwork"><a href="#val-sycon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sycon_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>sycon_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>sycon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to the <code>sycon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sycon"><a href="#val-sycon" class="anchor"></a><code><span class="keyword">val</span> sycon : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ipiv:<a href="../Lacaml/Common/index.html#type-int32_vec">Lacaml.Common.int32_vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;anorm:float</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sycon ?n ?up ?ipiv ?anorm ?work ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>estimate of the reciprocal of the condition number of symmetric matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = upper triangle of the factorization of <code>a</code> is stored</p></dd></dl><dl><dt>parameter ipiv</dt><dd><p>default = vec of length <code>n</code></p></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = 1-norm of the matrix <code>a</code> as returned by <code>lange</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pocon_min_lwork"><a href="#val-pocon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> pocon_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>pocon_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>pocon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to the <code>pocon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pocon_min_lrwork"><a href="#val-pocon_min_lrwork" class="anchor"></a><code><span class="keyword">val</span> pocon_min_lrwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>pocon_min_lrwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the rwork array used by the <code>pocon</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>pocon</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pocon"><a href="#val-pocon" class="anchor"></a><code><span class="keyword">val</span> pocon : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;up:bool</span> <span>&#45;&gt;</span> <span>?&#8288;anorm:float</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;rwork:<a href="../Lacaml__/Complex32/index.html#type-rvec">Lacaml__.Complex32.rvec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>pocon ?n ?up ?anorm ?work ?rwork ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p>estimate of the reciprocal of the condition number of complex Hermitian positive definite matrix <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = upper triangle of Cholesky factorization of <code>a</code> is stored</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter rwork</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = 1-norm of the matrix <code>a</code> as returned by <code>lange</code></p></dd></dl></dd></dl></section><section><header><h6 id="general-schur-factorization"><a href="#general-schur-factorization" class="anchor"></a>General Schur factorization</h6></header><dl><dt class="spec value" id="val-gees"><a href="#val-gees" class="anchor"></a><code><span class="keyword">val</span> gees : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobvs:<a href="../Lacaml/Common/index.html#type-schur_vectors">Lacaml.Common.schur_vectors</a></span> <span>&#45;&gt;</span> <span>?&#8288;sort:<a href="../Lacaml/Common/index.html#type-eigen_value_sort">Lacaml.Common.eigen_value_sort</a></span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;vsr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vsc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vs:<a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> int * <a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a> * <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></code></dt><dd><p><code>gees ?n ?jobvs ?sort ?w ?vsr ?vsc ?vs ?work ?ar ?ac a</code> See <code>gees</code>-function for details about arguments.</p><dl><dt>returns</dt><dd><p>(sdim, w, vs)</p></dd></dl></dd></dl></section><section><header><h6 id="general-svd-routines"><a href="#general-svd-routines" class="anchor"></a>General SVD routines</h6></header><dl><dt class="spec value" id="val-gesvd_min_lwork"><a href="#val-gesvd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gesvd_min_lwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gesvd_min_lwork ~m ~n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>gesvd</code>-function for matrices with <code>m</code> rows and <code>n</code> columns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesvd_lrwork"><a href="#val-gesvd_lrwork" class="anchor"></a><code><span class="keyword">val</span> gesvd_lrwork : <span>m:int</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gesvd_lrwork m n</code> </p><dl><dt>returns</dt><dd><p>the (minimum) length of the rwork array used by the <code>gesvd</code>-function.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesvd_opt_lwork"><a href="#val-gesvd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gesvd_opt_lwork : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobu:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;jobvt:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Lacaml__/Complex32/index.html#type-rvec">Lacaml__.Complex32.rvec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ur:int</span> <span>&#45;&gt;</span> <span>?&#8288;uc:int</span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;vtr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vtc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vt:<a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-gesvd"><a href="#val-gesvd" class="anchor"></a><code><span class="keyword">val</span> gesvd : <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;jobu:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;jobvt:<a href="../Lacaml/Common/index.html#type-svd_job">Lacaml.Common.svd_job</a></span> <span>&#45;&gt;</span> <span>?&#8288;s:<a href="../Lacaml__/Complex32/index.html#type-rvec">Lacaml__.Complex32.rvec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ur:int</span> <span>&#45;&gt;</span> <span>?&#8288;uc:int</span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;vtr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vtc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vt:<a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;rwork:<a href="../Lacaml__/Complex32/index.html#type-rvec">Lacaml__.Complex32.rvec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-rvec">Lacaml__.Complex32.rvec</a> * <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> * <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></code></dt></dl></section><section><header><h6 id="general-eigenvalue-problem-(simple-drivers)"><a href="#general-eigenvalue-problem-(simple-drivers)" class="anchor"></a>General eigenvalue problem (simple drivers)</h6></header><dl><dt class="spec value" id="val-geev_min_lwork"><a href="#val-geev_min_lwork" class="anchor"></a><code><span class="keyword">val</span> geev_min_lwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>geev_min_lwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the work array used by the <code>geev</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>geev</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geev_min_lrwork"><a href="#val-geev_min_lrwork" class="anchor"></a><code><span class="keyword">val</span> geev_min_lrwork : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>geev_min_lrwork n</code> </p><dl><dt>returns</dt><dd><p>the minimum length of the rwork array used by the <code>geev</code>-function.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the logical dimensions of the matrix given to <code>geev</code>-function</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geev_opt_lwork"><a href="#val-geev_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> geev_opt_lwork : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;vlr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vlc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vl:<span><a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;vrr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vrc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vr:<span><a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>geev ?work ?rwork ?n ?vlr ?vlc ?vl ?vrr ?vrc ?vr ?ofsw w ?ar ?ac a</code> See <code>geev</code>-function for details about arguments.</p><dl><dt>returns</dt><dd><p>&quot;optimal&quot; work size</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geev"><a href="#val-geev" class="anchor"></a><code><span class="keyword">val</span> geev : <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;work:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;rwork:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;vlr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vlc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vl:<span><a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;vrr:int</span> <span>&#45;&gt;</span> <span>?&#8288;vrc:int</span> <span>&#45;&gt;</span> <span>?&#8288;vr:<span><a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ofsw:int</span> <span>&#45;&gt;</span> <span>?&#8288;w:<a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a> * <a href="../Lacaml__/Complex32/index.html#type-vec">Lacaml__.Complex32.vec</a> * <a href="../Lacaml__/Complex32/index.html#type-mat">Lacaml__.Complex32.mat</a></code></dt><dd><p><code>geev ?work ?rwork ?n
      ?vlr ?vlc ?vl
      ?vrr ?vrc ?vr
      ?ofsw w
      ?ar ?ac a</code></p><dl><dt>returns</dt><dd><p><code>(lv, w, rv)</code>, where <code>lv</code> and <code>rv</code> correspond to the left and right eigenvectors respectively, <code>w</code> to the eigenvalues. <code>lv</code> (<code>rv</code>) is the empty matrix if <code>vl</code> (<code>vr</code>) is set to <code>None</code>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge</p></dd></dl><dl><dt>parameter n</dt><dd><p>default = available number of columns of matrix <code>a</code></p></dd></dl><dl><dt>parameter work</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter rwork</dt><dd><p>default = automatically allocated workspace</p></dd></dl><dl><dt>parameter vl</dt><dd><p>default = Automatically allocated left eigenvectors. Pass <code>None</code> if you do not want to compute them, <code>Some lv</code> if you want to provide the storage. You can set <code>vlr</code>, <code>vlc</code> in the last case. (See LAPACK GEEV docs for details about storage of complex eigenvectors)</p></dd></dl><dl><dt>parameter vr</dt><dd><p>default = Automatically allocated right eigenvectors. Pass <code>None</code> if you do not want to compute them, <code>Some rv</code> if you want to provide the storage. You can set <code>vrr</code>, <code>vrc</code> in the last case.</p></dd></dl><dl><dt>parameter w</dt><dd><p>default = automatically allocate eigenvalues</p></dd></dl><dl><dt>parameter a</dt><dd><p>the matrix whose eigensystem is computed</p></dd></dl></dd></dl></section></div></body></html>