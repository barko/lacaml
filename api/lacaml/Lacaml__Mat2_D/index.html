<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lacaml__Mat2_D (lacaml.Lacaml__Mat2_D)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">lacaml</a> &#x00BB; Lacaml__Mat2_D</nav><h1>Module <code>Lacaml__Mat2_D</code></h1><h6 id="matrix-operations"><a href="#matrix-operations" class="anchor"></a>Matrix operations</h6><nav class="toc"><ul><li><a href="#creation-of-matrices">Creation of matrices</a></li><li><a href="#unary-matrix-operations">Unary matrix operations</a></li><li><a href="#binary-matrix-operations">Binary matrix operations</a></li><li><a href="#miscellaneous-functions">Miscellaneous functions</a></li><li><a href="#ternary-matrix-operations">Ternary matrix operations</a></li></ul></nav></header><section><header><h6 id="creation-of-matrices"><a href="#creation-of-matrices" class="anchor"></a>Creation of matrices</h6></header><dl><dt class="spec value" id="val-hilbert"><a href="#val-hilbert" class="anchor"></a><code><span class="keyword">val</span> hilbert : int <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>hilbert n</code> </p><dl><dt>returns</dt><dd><p>an <code>n</code>x<code>n</code> Hilbert matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-hankel"><a href="#val-hankel" class="anchor"></a><code><span class="keyword">val</span> hankel : int <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>hankel n</code> </p><dl><dt>returns</dt><dd><p>an <code>n</code>x<code>n</code> Hankel matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pascal"><a href="#val-pascal" class="anchor"></a><code><span class="keyword">val</span> pascal : int <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>pascal n</code> </p><dl><dt>returns</dt><dd><p>an <code>n</code>x<code>n</code> Pascal matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rosser"><a href="#val-rosser" class="anchor"></a><code><span class="keyword">val</span> rosser : unit <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>rosser n</code> </p><dl><dt>returns</dt><dd><p>8x8 Rosser matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-toeplitz"><a href="#val-toeplitz" class="anchor"></a><code><span class="keyword">val</span> toeplitz : <a href="../Lacaml__/Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>toeplitz v</code> </p><dl><dt>returns</dt><dd><p>the Toeplitz matrix associated with <code>v</code>. The constant diagonals are read from left to right from <code>v</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the length of <code>v</code> is not an odd number.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-vandermonde"><a href="#val-vandermonde" class="anchor"></a><code><span class="keyword">val</span> vandermonde : <a href="../Lacaml__/Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>vandermonde v</code> </p><dl><dt>returns</dt><dd><p>the Vandermonde matrix associated with <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-wilkinson"><a href="#val-wilkinson" class="anchor"></a><code><span class="keyword">val</span> wilkinson : int <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>wilkinson n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>x<code>n</code> Wilkinson matrix.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> is not an odd number &gt;= 3.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val</span> random : <span>?&#8288;rnd_state:Stdlib.Random.State.t</span> <span>&#45;&gt;</span> <span>?&#8288;from:float</span> <span>&#45;&gt;</span> <span>?&#8288;range:float</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a></code></dt><dd><p><code>random ?rnd_state ?from ?range m n</code> </p><dl><dt>returns</dt><dd><p>an <code>m</code>x<code>n</code> matrix initialized with random elements sampled uniformly from <code>range</code> starting at <code>from</code>. A random state <code>rnd_state</code> can be passed.</p></dd></dl><dl><dt>parameter rnd_state</dt><dd><p>default = Random.get_state ()</p></dd></dl><dl><dt>parameter from</dt><dd><p>default = -1.0</p></dd></dl><dl><dt>parameter range</dt><dd><p>default = 2.0</p></dd></dl></dd></dl></section><section><header><h6 id="unary-matrix-operations"><a href="#unary-matrix-operations" class="anchor"></a>Unary matrix operations</h6></header><dl><dt class="spec value" id="val-abs"><a href="#val-abs" class="anchor"></a><code><span class="keyword">val</span> abs : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>abs ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the absolute value of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-signum"><a href="#val-signum" class="anchor"></a><code><span class="keyword">val</span> signum : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>signum ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sign value (<code>-1</code> for negative numbers, <code>0</code> (or <code>-0</code>) for zero, <code>1</code> for positive numbers, <code>nan</code> for <code>nan</code>) of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqr"><a href="#val-sqr" class="anchor"></a><code><span class="keyword">val</span> sqr : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>sqr ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><code><span class="keyword">val</span> sqrt : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>sqrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the square root of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cbrt"><a href="#val-cbrt" class="anchor"></a><code><span class="keyword">val</span> cbrt : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>cbrt ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cubic root of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp"><a href="#val-exp" class="anchor"></a><code><span class="keyword">val</span> exp : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>exp ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the exponential of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp2"><a href="#val-exp2" class="anchor"></a><code><span class="keyword">val</span> exp2 : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>exp2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-2 exponential of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-expm1"><a href="#val-expm1" class="anchor"></a><code><span class="keyword">val</span> expm1 : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>expm1 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code>exp a -. 1.</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log"><a href="#val-log" class="anchor"></a><code><span class="keyword">val</span> log : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>log ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log10"><a href="#val-log10" class="anchor"></a><code><span class="keyword">val</span> log10 : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>log10 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the base-10 logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log2"><a href="#val-log2" class="anchor"></a><code><span class="keyword">val</span> log2 : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>log2 ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes base-2 logarithm of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log1p"><a href="#val-log1p" class="anchor"></a><code><span class="keyword">val</span> log1p : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>log1p ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes <code>log (1 + a)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sin"><a href="#val-sin" class="anchor"></a><code><span class="keyword">val</span> sin : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>sin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cos"><a href="#val-cos" class="anchor"></a><code><span class="keyword">val</span> cos : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>cos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tan"><a href="#val-tan" class="anchor"></a><code><span class="keyword">val</span> tan : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>tan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asin"><a href="#val-asin" class="anchor"></a><code><span class="keyword">val</span> asin : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>asin ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acos"><a href="#val-acos" class="anchor"></a><code><span class="keyword">val</span> acos : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>acos ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan"><a href="#val-atan" class="anchor"></a><code><span class="keyword">val</span> atan : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>atan ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the arc tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sinh"><a href="#val-sinh" class="anchor"></a><code><span class="keyword">val</span> sinh : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>sinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cosh"><a href="#val-cosh" class="anchor"></a><code><span class="keyword">val</span> cosh : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>cosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tanh"><a href="#val-tanh" class="anchor"></a><code><span class="keyword">val</span> tanh : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>tanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asinh"><a href="#val-asinh" class="anchor"></a><code><span class="keyword">val</span> asinh : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>asinh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc sine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acosh"><a href="#val-acosh" class="anchor"></a><code><span class="keyword">val</span> acosh : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>acosh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc cosine of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atanh"><a href="#val-atanh" class="anchor"></a><code><span class="keyword">val</span> atanh : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>atanh ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the hyperbolic arc tangent of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-floor"><a href="#val-floor" class="anchor"></a><code><span class="keyword">val</span> floor : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>floor ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the floor of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ceil"><a href="#val-ceil" class="anchor"></a><code><span class="keyword">val</span> ceil : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>ceil ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the ceiling of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-round"><a href="#val-round" class="anchor"></a><code><span class="keyword">val</span> round : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>round ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> rounds the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trunc"><a href="#val-trunc" class="anchor"></a><code><span class="keyword">val</span> trunc : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>trunc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the truncation of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erf"><a href="#val-erf" class="anchor"></a><code><span class="keyword">val</span> erf : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>erf ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the error function of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erfc"><a href="#val-erfc" class="anchor"></a><code><span class="keyword">val</span> erfc : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>erfc ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the complementary error function of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-logistic"><a href="#val-logistic" class="anchor"></a><code><span class="keyword">val</span> logistic : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>logistic ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the logistic function <code>1/(1 + exp(-a)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-relu"><a href="#val-relu" class="anchor"></a><code><span class="keyword">val</span> relu : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>relu ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the rectified linear unit function <code>max(a, 0)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softplus"><a href="#val-softplus" class="anchor"></a><code><span class="keyword">val</span> softplus : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>softplus ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softplus function <code>log(1 + exp(x)</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softsign"><a href="#val-softsign" class="anchor"></a><code><span class="keyword">val</span> softsign : <a href="../Lacaml__Float64/Types/Mat/index.html#type-unop">Lacaml__.Float64.Types.Mat.unop</a></code></dt><dd><p><code>softsign ?patt ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the softsign function <code>x / (1 + abs(x))</code> of the elements in the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code>. If <code>b</code> is given, the result will be stored in there using offsets <code>br</code> and <code>bc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter b</dt><dd><p>default = fresh matrix with <code>br + m - 1</code> rows and <code>bc + n - 1</code> columns</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="binary-matrix-operations"><a href="#binary-matrix-operations" class="anchor"></a>Binary matrix operations</h6></header><dl><dt class="spec value" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span class="keyword">val</span> pow : <a href="../Lacaml__Float64/Types/Mat/index.html#type-binop">Lacaml__.Float64.Types.Mat.binop</a></code></dt><dd><p><code>pow ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>pow(a, b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan2"><a href="#val-atan2" class="anchor"></a><code><span class="keyword">val</span> atan2 : <a href="../Lacaml__Float64/Types/Mat/index.html#type-binop">Lacaml__.Float64.Types.Mat.binop</a></code></dt><dd><p><code>atan2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>atan2(a, b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><p>NOTE: WARNING! From a geometric point of view, the <code>atan2</code> function takes the y-coordinate in <code>a</code> and the x-coordinate in <code>b</code>. This confusion is a sad consequence of the C99-standard reversing the argument order for <code>atan2</code> for no good reason.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-hypot"><a href="#val-hypot" class="anchor"></a><code><span class="keyword">val</span> hypot : <a href="../Lacaml__Float64/Types/Mat/index.html#type-binop">Lacaml__.Float64.Types.Mat.binop</a></code></dt><dd><p><code>hypot ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes <code>sqrt(a*a+b*b)</code> for the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min2"><a href="#val-min2" class="anchor"></a><code><span class="keyword">val</span> min2 : <a href="../Lacaml__Float64/Types/Mat/index.html#type-binop">Lacaml__.Float64.Types.Mat.binop</a></code></dt><dd><p><code>min2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise minimum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max2"><a href="#val-max2" class="anchor"></a><code><span class="keyword">val</span> max2 : <a href="../Lacaml__Float64/Types/Mat/index.html#type-binop">Lacaml__.Float64.Types.Mat.binop</a></code></dt><dd><p><code>max2 ?patt ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the elementwise maximum of the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> and pattern <code>patt</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>. If <code>c</code> is given, the result will be stored in there starting in row <code>cr</code> and column <code>cc</code>, otherwise a fresh matrix will be used. The resulting matrix is returned.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter c</dt><dd><p>default = fresh matrix with <code>cr + m - 1</code> rows and <code>cc + n - 1</code> columns</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sum_prod"><a href="#val-sum_prod" class="anchor"></a><code><span class="keyword">val</span> sum_prod : <span>?&#8288;patt:<a href="../Lacaml__Float64/Types/Mat/index.html#type-patt">Lacaml__.Float64.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sum_prod ?patt ?m ?n ?ar ?ac a ?br ?bc b</code> </p><dl><dt>returns</dt><dd><p>the sum of elementwise products between the <code>m</code> by <code>n</code> sub-matrix of the matrix <code>a</code> starting in row <code>ar</code> and column <code>ac</code> with the corresponding sub-matrix of the matrix <code>b</code> starting in row <code>br</code> and column <code>bc</code>.</p></dd></dl><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = greater n s.t. <code>ar + m - 1 &lt;= dim1 a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ac + n - 1 &lt;= dim2 a</code></p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h6 id="miscellaneous-functions"><a href="#miscellaneous-functions" class="anchor"></a>Miscellaneous functions</h6></header><dl><dt class="spec value" id="val-log_sum_exp"><a href="#val-log_sum_exp" class="anchor"></a><code><span class="keyword">val</span> log_sum_exp : <span>?&#8288;patt:<a href="../Lacaml__Float64/Types/Mat/index.html#type-patt">Lacaml__.Float64.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>log_sum_exp ?patt ?m ?n ?ar ?ac a</code> computes the logarithm of the sum of exponentials of all elements in the <code>m</code>-by-<code>n</code> submatrix using pattern <code>patt</code>, starting at row <code>ar</code> and column <code>ac</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl></dd></dl></section><section><header><h6 id="ternary-matrix-operations"><a href="#ternary-matrix-operations" class="anchor"></a>Ternary matrix operations</h6></header><dl><dt class="spec value" id="val-cpab"><a href="#val-cpab" class="anchor"></a><code><span class="keyword">val</span> cpab : <span>?&#8288;patt:<a href="../Lacaml__Float64/Types/Mat/index.html#type-patt">Lacaml__.Float64.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cpab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated <code>m</code>-by-<code>n</code> range of elements of matrices <code>a</code> and <code>b</code> using pattern <code>patt</code> elementwise and adds the result to and stores it in the specified range in <code>c</code>. This function is useful for convolutions. Similar to <code>Vec.zpxy</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cmab"><a href="#val-cmab" class="anchor"></a><code><span class="keyword">val</span> cmab : <span>?&#8288;patt:<a href="../Lacaml__Float64/Types/Mat/index.html#type-patt">Lacaml__.Float64.Types.Mat.patt</a></span> <span>&#45;&gt;</span> <span>?&#8288;m:int</span> <span>&#45;&gt;</span> <span>?&#8288;n:int</span> <span>&#45;&gt;</span> <span>?&#8288;cr:int</span> <span>&#45;&gt;</span> <span>?&#8288;cc:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;ar:int</span> <span>&#45;&gt;</span> <span>?&#8288;ac:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> <span>?&#8288;br:int</span> <span>&#45;&gt;</span> <span>?&#8288;bc:int</span> <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-mat">Lacaml__.Float64.mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cmab ?patt ?m ?n ?cr ?cc c ?ar ?ac a ?br ?bc b</code> multiplies designated <code>m</code>-by-<code>n</code> range of elements of matrices <code>a</code> and <code>b</code> elementwise using pattern <code>patt</code> and subtracts the result from and stores it in the specified range in <code>c</code>. This function is useful for convolutions. Similar to <code>Vec.zmxy</code>.</p><dl><dt>parameter patt</dt><dd><p>default = <code>`Full</code></p></dd></dl><dl><dt>parameter m</dt><dd><p>default = number of rows of <code>a</code></p></dd></dl><dl><dt>parameter n</dt><dd><p>default = number of columns of <code>a</code></p></dd></dl><dl><dt>parameter cr</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter cc</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ar</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ac</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter br</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter bc</dt><dd><p>default = 1</p></dd></dl></dd></dl></section></div></body></html>