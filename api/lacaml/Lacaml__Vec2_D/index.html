<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lacaml__Vec2_D (lacaml.Lacaml__Vec2_D)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">lacaml</a> &#x00BB; Lacaml__Vec2_D</nav><h1>Module <code>Lacaml__Vec2_D</code></h1><h4 id="vector-operations"><a href="#vector-operations" class="anchor"></a>Vector operations</h4><nav class="toc"><ul><li><a href="#creation-of-vectors">Creation of vectors</a></li><li><a href="#unary-vector-operations">Unary vector operations</a></li><li><a href="#binary-vector-operations">Binary vector operations</a></li><li><a href="#miscellaneous-functions">Miscellaneous functions</a></li></ul></nav></header><section><header><h4 id="creation-of-vectors"><a href="#creation-of-vectors" class="anchor"></a>Creation of vectors</h4></header><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val </span>random : ?&#8288;rnd_state:Stdlib.Random.State.t <span>&#45;&gt;</span> ?&#8288;from:float <span>&#45;&gt;</span> ?&#8288;range:float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-vec">Lacaml__.Float64.vec</a></code></dt></dl></section><section><header><h4 id="unary-vector-operations"><a href="#unary-vector-operations" class="anchor"></a>Unary vector operations</h4></header><dl><dt class="spec value" id="val-abs"><a href="#val-abs" class="anchor"></a><code><span class="keyword">val </span>abs : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>abs ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the absolute value of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-signum"><a href="#val-signum" class="anchor"></a><code><span class="keyword">val </span>signum : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>signum ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the sign value (<code>-1</code> for negative numbers, <code>0</code> (or <code>-0</code>) for zero, <code>1</code> for positive numbers, <code>nan</code> for <code>nan</code>) of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqr"><a href="#val-sqr" class="anchor"></a><code><span class="keyword">val </span>sqr : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>sqr ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the square of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><code><span class="keyword">val </span>sqrt : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>sqrt ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the square root of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cbrt"><a href="#val-cbrt" class="anchor"></a><code><span class="keyword">val </span>cbrt : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>cbrt ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the cubic root of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp"><a href="#val-exp" class="anchor"></a><code><span class="keyword">val </span>exp : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>exp ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the exponential of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exp2"><a href="#val-exp2" class="anchor"></a><code><span class="keyword">val </span>exp2 : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>exp2 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-2 exponential of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-expm1"><a href="#val-expm1" class="anchor"></a><code><span class="keyword">val </span>expm1 : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>expm1 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes <code>exp x -. 1.</code> for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log"><a href="#val-log" class="anchor"></a><code><span class="keyword">val </span>log : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>log ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the logarithm of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log10"><a href="#val-log10" class="anchor"></a><code><span class="keyword">val </span>log10 : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>log10 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-10 logarithm of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log2"><a href="#val-log2" class="anchor"></a><code><span class="keyword">val </span>log2 : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>log2 ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the base-2 logarithm of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-log1p"><a href="#val-log1p" class="anchor"></a><code><span class="keyword">val </span>log1p : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>log1p ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes <code>log (1 + x)</code> for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sin"><a href="#val-sin" class="anchor"></a><code><span class="keyword">val </span>sin : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>sin ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the sine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cos"><a href="#val-cos" class="anchor"></a><code><span class="keyword">val </span>cos : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>cos ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the cosine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tan"><a href="#val-tan" class="anchor"></a><code><span class="keyword">val </span>tan : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>tan ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the tangent of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asin"><a href="#val-asin" class="anchor"></a><code><span class="keyword">val </span>asin : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>asin ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc sine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acos"><a href="#val-acos" class="anchor"></a><code><span class="keyword">val </span>acos : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>acos ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc cosine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan"><a href="#val-atan" class="anchor"></a><code><span class="keyword">val </span>atan : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>atan ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the arc tangent of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sinh"><a href="#val-sinh" class="anchor"></a><code><span class="keyword">val </span>sinh : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>sinh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic sine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cosh"><a href="#val-cosh" class="anchor"></a><code><span class="keyword">val </span>cosh : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>cosh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic cosine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tanh"><a href="#val-tanh" class="anchor"></a><code><span class="keyword">val </span>tanh : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>tanh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic tangent of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asinh"><a href="#val-asinh" class="anchor"></a><code><span class="keyword">val </span>asinh : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>asinh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc sine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-acosh"><a href="#val-acosh" class="anchor"></a><code><span class="keyword">val </span>acosh : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>cosh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc cosine of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atanh"><a href="#val-atanh" class="anchor"></a><code><span class="keyword">val </span>atanh : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>atanh ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the hyperbolic arc tangent of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-floor"><a href="#val-floor" class="anchor"></a><code><span class="keyword">val </span>floor : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>floor ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the floor of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ceil"><a href="#val-ceil" class="anchor"></a><code><span class="keyword">val </span>ceil : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>ceil ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the ceiling of <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-round"><a href="#val-round" class="anchor"></a><code><span class="keyword">val </span>round : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>round ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> rounds the <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trunc"><a href="#val-trunc" class="anchor"></a><code><span class="keyword">val </span>trunc : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>trunc ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the truncation of the <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erf"><a href="#val-erf" class="anchor"></a><code><span class="keyword">val </span>erf : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>erf ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the error function for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-erfc"><a href="#val-erfc" class="anchor"></a><code><span class="keyword">val </span>erfc : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>erfc ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the complementary error function for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-logistic"><a href="#val-logistic" class="anchor"></a><code><span class="keyword">val </span>logistic : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>logistic ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the logistict function <code>1/(1 + exp(-a)</code> for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-relu"><a href="#val-relu" class="anchor"></a><code><span class="keyword">val </span>relu : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>relu ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the rectified linear unit function <code>max(x, 0)</code> for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softplus"><a href="#val-softplus" class="anchor"></a><code><span class="keyword">val </span>softplus : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>softplus ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the softplus function <code>log(1 + exp(x)</code> for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-softsign"><a href="#val-softsign" class="anchor"></a><code><span class="keyword">val </span>softsign : <a href="../Lacaml__Float64/Types/Vec/index.html#type-unop">Lacaml__.Float64.Types.Vec.unop</a></code></dt><dd><p><code>softsign ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the softsign function <code>x / (1 + abs(x))</code> for <code>n</code> elements of the vector <code>x</code> using <code>incx</code> as incremental steps. If <code>y</code> is given, the result will be stored in there using increments of <code>incy</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter y</dt><dd><p>default = fresh vector with <code>ofsy+(n - 1)(abs incy)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h4 id="binary-vector-operations"><a href="#binary-vector-operations" class="anchor"></a>Binary vector operations</h4></header><dl><dt class="spec value" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span class="keyword">val </span>pow : <a href="../Lacaml__Float64/Types/Vec/index.html#type-binop">Lacaml__.Float64.Types.Vec.binop</a></code></dt><dd><p><code>pow ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes <code>pow(a, b)</code> of <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-atan2"><a href="#val-atan2" class="anchor"></a><code><span class="keyword">val </span>atan2 : <a href="../Lacaml__Float64/Types/Vec/index.html#type-binop">Lacaml__.Float64.Types.Vec.binop</a></code></dt><dd><p><code>atan2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes <code>atan2(x, y)</code> of <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><p>NOTE: WARNING! From a geometric point of view, the <code>atan2</code> function takes the y-coordinate in <code>x</code> and the x-coordinate in <code>y</code>. This confusion is a sad consequence of the C99-standard reversing the argument order for <code>atan2</code> for no good reason.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-hypot"><a href="#val-hypot" class="anchor"></a><code><span class="keyword">val </span>hypot : <a href="../Lacaml__Float64/Types/Vec/index.html#type-binop">Lacaml__.Float64.Types.Vec.binop</a></code></dt><dd><p><code>hypot ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes <code>sqrt(x*x + y*y)</code> of <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min2"><a href="#val-min2" class="anchor"></a><code><span class="keyword">val </span>min2 : <a href="../Lacaml__Float64/Types/Vec/index.html#type-binop">Lacaml__.Float64.Types.Vec.binop</a></code></dt><dd><p><code>min2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes the minimum of <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max2"><a href="#val-max2" class="anchor"></a><code><span class="keyword">val </span>max2 : <a href="../Lacaml__Float64/Types/Vec/index.html#type-binop">Lacaml__.Float64.Types.Vec.binop</a></code></dt><dd><p><code>max2 ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> computes the maximum of <code>n</code> elements of vectors <code>x</code> and <code>y</code> elementwise, using <code>incx</code> and <code>incy</code> as incremental steps respectively. If <code>z</code> is given, the result will be stored in there using increments of <code>incz</code>, otherwise a fresh vector will be used. The resulting vector is returned.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incz</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter z</dt><dd><p>default = fresh vector with <code>ofsz+(n - 1)(abs incz)</code> rows</p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter ofsy</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incy</dt><dd><p>default = 1</p></dd></dl></dd></dl></section><section><header><h4 id="miscellaneous-functions"><a href="#miscellaneous-functions" class="anchor"></a>Miscellaneous functions</h4></header><dl><dt class="spec value" id="val-log_sum_exp"><a href="#val-log_sum_exp" class="anchor"></a><code><span class="keyword">val </span>log_sum_exp : ?&#8288;n:int <span>&#45;&gt;</span> ?&#8288;ofsx:int <span>&#45;&gt;</span> ?&#8288;incx:int <span>&#45;&gt;</span> <a href="../Lacaml__/Float64/index.html#type-vec">Lacaml__.Float64.vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>log_sum_exp ?n ?ofsx ?incx x</code> computes the logarithm of the sum of exponentials of the <code>n</code> elements in vector <code>x</code>, separated by <code>incx</code> incremental steps.</p><dl><dt>parameter n</dt><dd><p>default = greater n s.t. <code>ofsx+(n-1)(abs incx) &lt;= dim x</code></p></dd></dl><dl><dt>parameter ofsx</dt><dd><p>default = 1</p></dd></dl><dl><dt>parameter incx</dt><dd><p>default = 1</p></dd></dl></dd></dl></section></div></body></html>