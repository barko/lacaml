<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="next" href="Lacaml_C.Mat.html">
<link rel="Up" href="Lacaml_C.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Lacaml" rel="Chapter" href="Lacaml.html">
<link title="Lacaml_common" rel="Chapter" href="Lacaml_common.html">
<link title="Lacaml_io" rel="Chapter" href="Lacaml_io.html">
<link title="Lacaml_S" rel="Chapter" href="Lacaml_S.html">
<link title="Lacaml_D" rel="Chapter" href="Lacaml_D.html">
<link title="Lacaml_C" rel="Chapter" href="Lacaml_C.html">
<link title="Lacaml_Z" rel="Chapter" href="Lacaml_Z.html">
<link title="Lacaml_utils" rel="Chapter" href="Lacaml_utils.html">
<link title="Lacaml_version" rel="Chapter" href="Lacaml_version.html">
<link title="Lacaml_float32" rel="Chapter" href="Lacaml_float32.html">
<link title="Lacaml_float64" rel="Chapter" href="Lacaml_float64.html">
<link title="Lacaml_complex32" rel="Chapter" href="Lacaml_complex32.html">
<link title="Lacaml_complex64" rel="Chapter" href="Lacaml_complex64.html"><link title="Vector operations" rel="Section" href="#5_Vectoroperations">
<link title="Creation of vectors" rel="Subsection" href="#6_Creationofvectors">
<link title="Creation/conversion of vectors and dimension accessor" rel="Subsection" href="#6_Creationconversionofvectorsanddimensionaccessor">
<link title="Iterators over vectors" rel="Subsection" href="#6_Iteratorsovervectors">
<link title="Operations on one vector" rel="Subsection" href="#6_Operationsononevector">
<link title="Operations on two vectors" rel="Subsection" href="#6_Operationsontwovectors">
<title>Lacaml_C.Vec</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Lacaml_C.html" title="Lacaml_C">Up</a>
&nbsp;<a class="post" href="Lacaml_C.Mat.html" title="Lacaml_C.Mat">Next</a>
</div>
<h1>Module <a href="type_Lacaml_C.Vec.html">Lacaml_C.Vec</a></h1>

<pre><span class="keyword">module</span> Vec: <code class="code">sig</code> <a href="Lacaml_C.Vec.html">..</a> <code class="code">end</code></pre><hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type"><a href="Lacaml_C.html#TYPEvec">Lacaml_C.vec</a></code> </pre>

<br>
<h5 id="5_Vectoroperations">Vector operations</h5><br>
<br>
<h6 id="6_Creationofvectors">Creation of vectors</h6><br>

<pre><span id="VALrandom"><span class="keyword">val</span> random</span> : <code class="type">?rnd_state:Random.State.t -><br>       ?re_from:float -><br>       ?re_range:float -><br>       ?im_from:float -> ?im_range:float -> int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">random ?rnd_state ?re_from ?re_range ?im_from ?im_range n</code><br>
<b>Returns</b> a vector of size <code class="code">n</code> initialized with random elements sampled
      uniformly from <code class="code">re_range</code> and <code class="code">im_range</code> starting at <code class="code">re_from</code> and
      <code class="code">im_from</code> for real and imaginary numbers respectively.  A random state
      <code class="code">rnd_state</code> can be passed.<br>
</div>
<div class="param_info"><code class="code">rnd_state</code> : default = Random.get_state ()</div>
<div class="param_info"><code class="code">re_from</code> : default = -1.0</div>
<div class="param_info"><code class="code">re_range</code> : default = 2.0</div>
<div class="param_info"><code class="code">im_from</code> : default = -1.0</div>
<div class="param_info"><code class="code">im_range</code> : default = 2.0</div>
<br>
<h6 id="6_Creationconversionofvectorsanddimensionaccessor">Creation/conversion of vectors and dimension accessor</h6><br>

<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">create n</code><br>
<b>Returns</b> a vector with <code class="code">n</code> rows (not initialized).<br>
</div>

<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">int -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">make n x</code><br>
<b>Returns</b> a vector with <code class="code">n</code> rows initialized with value <code class="code">x</code>.<br>
</div>

<pre><span id="VALmake0"><span class="keyword">val</span> make0</span> : <code class="type">int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">make0 n x</code><br>
<b>Returns</b> a vector with <code class="code">n</code> rows initialized with the zero
      element.<br>
</div>

<pre><span id="VALinit"><span class="keyword">val</span> init</span> : <code class="type">int -> (int -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a>) -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">init n f</code><br>
<b>Returns</b> a vector containing <code class="code">n</code> elements, where each
      element at position <code class="code">i</code> is initialized by the result of calling
      <code class="code">f i</code>.<br>
</div>

<pre><span id="VALof_array"><span class="keyword">val</span> of_array</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> array -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">of_array ar</code><br>
<b>Returns</b> a vector initialized from array <code class="code">ar</code>.<br>
</div>

<pre><span id="VALto_array"><span class="keyword">val</span> to_array</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> array</code></pre><div class="info ">
<code class="code">to_array v</code><br>
<b>Returns</b> an array initialized from vector <code class="code">v</code>.<br>
</div>

<pre><span id="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> list -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">of_list l</code><br>
<b>Returns</b> a vector initialized from list <code class="code">l</code>.<br>
</div>

<pre><span id="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> list</code></pre><div class="info ">
<code class="code">to_list v</code><br>
<b>Returns</b> a list initialized from vector <code class="code">v</code>.<br>
</div>

<pre><span id="VALappend"><span class="keyword">val</span> append</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">append v1 v2</code><br>
<b>Returns</b> the vector resulting from appending vector
      <code class="code">v2</code> to <code class="code">v1</code>.<br>
</div>

<pre><span id="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> list -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">concat vs</code><br>
<b>Returns</b> the concatenation of vectors <code class="code">vs</code>.<br>
</div>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">empty</code>, the empty vector.<br>
</div>

<pre><span id="VALlinspace"><span class="keyword">val</span> linspace</span> : <code class="type">?y:<a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -><br>       <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">linspace ?z a b n</code><br>
<b>Returns</b> the vector <code class="code">y</code> overwritten with <code class="code">n</code>
      linearly spaced points between and including <code class="code">a</code> and <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">y</code> : default = fresh vector of dim <code class="code">n</code></div>

<pre><span id="VALlogspace"><span class="keyword">val</span> logspace</span> : <code class="type">?y:<a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -><br>       <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> ?base:float -> int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">logspace ?z a b base n</code><br>
<b>Returns</b> the vector <code class="code">y</code> overwritten with <code class="code">n</code>
      points logarithmically spaced using base <code class="code">b</code> between and including
      <code class="code">base</code> ** <code class="code">a</code> and <code class="code">base</code> ** <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">y</code> : default = fresh vector of dim <code class="code">n</code></div>
<div class="param_info"><code class="code">base</code> : default = 10.0</div>

<pre><span id="VALdim"><span class="keyword">val</span> dim</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> int</code></pre><div class="info ">
<code class="code">dim x</code><br>
<b>Returns</b> the dimension of vector <code class="code">x</code>.<br>
</div>

<pre><span id="VALhas_zero_dim"><span class="keyword">val</span> has_zero_dim</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> bool</code></pre><div class="info ">
<code class="code">has_zero_dim vec</code> checks whether vector <code class="code">vec</code> has a dimension of size
      <code class="code">zero</code>.  In this case it cannot contain data.<br>
</div>
<br>
<h6 id="6_Iteratorsovervectors">Iterators over vectors</h6><br>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(<a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a>) -><br>       ?n:int -><br>       ?ofsy:int -><br>       ?incy:int -><br>       ?y:<a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">map f ?n ?ofsx ?incx x</code><br>
<b>Returns</b> a new vector resulting from the
      application of <code class="code">f</code> to each element of <code class="code">x</code>.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">y</code> : default = new vector with <code class="code">ofsy+(n-1)(abs incy)</code> rows</div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">(<a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> unit) -><br>       ?n:int -> ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> unit</code></pre><div class="info ">
<code class="code">iter ?n ?ofsx ?incx f x</code> applies function <code class="code">f</code> in turn to all elements
      of vector <code class="code">x</code>.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALiteri"><span class="keyword">val</span> iteri</span> : <code class="type">(int -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> unit) -><br>       ?n:int -> ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> unit</code></pre><div class="info ">
<code class="code">iteri ?n ?ofsx ?incx f x</code> same as <code class="code">iter</code> but additionally passes
      the index of the element as first argument and the element itself
      as second argument.<br>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> 'a) -><br>       'a -> ?n:int -> ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> 'a</code></pre><div class="info ">
<code class="code">fold f a ?n ?ofsx ?incx x</code> is
      <code class="code">f (... (f (f a x.{ofsx}) x.{ofsx + incx}) ...) x.{ofsx + (n-1)*incx}</code>
      if <code class="code">incx &gt; 0</code> and the same in the reverse order of appearance of the
      <code class="code">x</code> values if <code class="code">incx &lt; 0</code>.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>
<br>
<h6 id="6_Operationsononevector">Operations on one vector</h6><br>

<pre><span id="VALrev"><span class="keyword">val</span> rev</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a></code></pre><div class="info ">
<code class="code">rev x</code> reverses vector <code class="code">x</code> (non-destructive).<br>
</div>

<pre><span id="VALmax"><span class="keyword">val</span> max</span> : <code class="type">?n:int -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a></code></pre><div class="info ">
<code class="code">max ?n ?ofsx ?incx x</code> computes the greater of the <code class="code">n</code> elements
      in vector <code class="code">x</code> (2-norm), separated by <code class="code">incx</code> incremental steps. NaNs
      are ignored. If only NaNs are encountered, the negative <code class="code">infinity</code>
      value will be returned.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALmin"><span class="keyword">val</span> min</span> : <code class="type">?n:int -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a></code></pre><div class="info ">
<code class="code">min ?n ?ofsx ?incx x</code> computes the smaller of the <code class="code">n</code> elements
      in vector <code class="code">x</code> (2-norm), separated by <code class="code">incx</code> incremental steps.
      NaNs are ignored. If only NaNs are encountered, the <code class="code">infinity</code> value
      will be returned.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALsort"><span class="keyword">val</span> sort</span> : <code class="type">?cmp:(<a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> int) -><br>       ?decr:bool -><br>       ?n:int -><br>       ?ofsp:int -><br>       ?incp:int -><br>       ?p:<a href="Lacaml_common.html#TYPEint_vec">Lacaml_common.int_vec</a> -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> unit</code></pre><div class="info ">
<code class="code">sort ?cmp ?n ?ofsx ?incx x</code> sorts the array <code class="code">x</code> in increasing
      order according to the comparison function <code class="code">cmp</code>.<br>
</div>
<div class="param_info"><code class="code">cmp</code> : a function such that <code class="code">cmp a b &lt; 0</code> if <code class="code">a</code> is less than
        <code class="code">b</code>, <code class="code">cmp a b = 0</code> if <code class="code">a</code> equal <code class="code">b</code> and <code class="code">cmp a b &gt; 0</code> if <code class="code">a</code> is
        greater than <code class="code">b</code> for the desired order.  Default: the usual
        order on floating point values or the lexicographic order on
        complex ones (a special routine makes it fast).  Whatever the
        order you choose, NaNs (in any component for complex numbers)
        are considered larger than any other value (so they will be
        last, in no specified order, in the sorted vector).  Therefore,
        NaN are never passed to <code class="code">cmp</code>.</div>
<div class="param_info"><code class="code">decr</code> : sort in decreasing order (stays fast for the default <code class="code">cmp</code>).</div>
<div class="param_info"><code class="code">n</code> : default = greater <code class="code">n</code> s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsp</code> : default = 1</div>
<div class="param_info"><code class="code">incp</code> : default = 1</div>
<div class="param_info"><code class="code">p</code> : if you pass a vector of size <code class="code">ofsp+(n - 1)(abs incp)</code>,
        the vector <code class="code">x</code> will be unchanged and the permutation to sort it
        will be stored in <code class="code">p</code>.  Thus <code class="code">x.{p.{ofsp + (i-1) * incp}}</code> will
        give the elements of <code class="code">x</code> in increasing order.  Default: no
        vector is provided.</div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALfill"><span class="keyword">val</span> fill</span> : <code class="type">?n:int -><br>       ?ofsx:int -><br>       ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> unit</code></pre><div class="info ">
<code class="code">fill ?n ?ofsx ?incx x a</code> fills vector <code class="code">x</code> with value <code class="code">a</code> in the
      designated range.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type">?n:int -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a></code></pre><div class="info ">
<code class="code">sum ?n ?ofsx ?incx x</code> computes the sum of the <code class="code">n</code> elements in
      vector <code class="code">x</code>, separated by <code class="code">incx</code> incremental steps.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALprod"><span class="keyword">val</span> prod</span> : <code class="type">?n:int -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a></code></pre><div class="info ">
<code class="code">prod ?n ?ofsx ?incx x</code> computes the product of the <code class="code">n</code> elements
      in vector <code class="code">x</code>, separated by <code class="code">incx</code> incremental steps.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALadd_const"><span class="keyword">val</span> add_const</span> : <code class="type"><a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -> <a href="Lacaml_complex32.Types.Vec.html#TYPEunop">Lacaml_complex32.Types.Vec.unop</a></code></pre><div class="info ">
<code class="code">add_const c ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> adds constant <code class="code">c</code> to the <code class="code">n</code>
      elements of vector <code class="code">x</code> and stores the result in <code class="code">y</code>, using <code class="code">incx</code> and <code class="code">incy</code>
      as incremental steps respectively.  If <code class="code">y</code> is given, the result will
      be stored in there using increments of <code class="code">incy</code>, otherwise a fresh
      vector will be used.  The resulting vector is returned.<br>
</div>

<pre><span id="VALsqr_nrm2"><span class="keyword">val</span> sqr_nrm2</span> : <code class="type">?stable:bool -><br>       ?n:int -> ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> float</code></pre><div class="info ">
<code class="code">sqr_nrm2 ?stable ?n ?c ?ofsx ?incx x</code> computes the square of
      the 2-norm (Euclidean norm) of vector <code class="code">x</code> separated by <code class="code">incx</code>
      incremental steps.  If <code class="code">stable</code> is true, this is equivalent to
      squaring the result of calling the BLAS-function <code class="code">nrm2</code>, which
      avoids over- and underflow if possible.  If <code class="code">stable</code> is false
      (default), <code class="code">dot</code> will be called instead for greatly improved
      performance.<br>
</div>
<div class="param_info"><code class="code">stable</code> : default = <code class="code">false</code></div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALssqr"><span class="keyword">val</span> ssqr</span> : <code class="type">?n:int -><br>       ?c:<a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a> -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a></code></pre><div class="info ">
<code class="code">ssqr ?n ?c ?ofsx ?incx x</code> computes the sum of squared differences
      of the <code class="code">n</code> elements in vector <code class="code">x</code> from constant <code class="code">c</code>, separated
      by <code class="code">incx</code> incremental steps.  Please do not confuse with
      <a href="Lacaml_C.Vec.html#VALsqr_nrm2"><code class="code">Lacaml_C.Vec.sqr_nrm2</code></a>!  The current function behaves differently with
      complex numbers when zero is passed in for <code class="code">c</code>.  It computes
      the square for each entry then, whereas <a href="Lacaml_C.Vec.html#VALsqr_nrm2"><code class="code">Lacaml_C.Vec.sqr_nrm2</code></a> uses the
      conjugate transpose in the product.  The latter will therefore
      always return a real number.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">c</code> : default = zero</div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALneg"><span class="keyword">val</span> neg</span> : <code class="type"><a href="Lacaml_complex32.Types.Vec.html#TYPEunop">Lacaml_complex32.Types.Vec.unop</a></code></pre><div class="info ">
<code class="code">neg ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> negates <code class="code">n</code> elements of the
      vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.   If <code class="code">y</code> is given,
      the result will be stored in there using increments of <code class="code">incy</code>,
      otherwise a fresh vector will be used.  The resulting vector is returned.<br>
</div>

<pre><span id="VALreci"><span class="keyword">val</span> reci</span> : <code class="type"><a href="Lacaml_complex32.Types.Vec.html#TYPEunop">Lacaml_complex32.Types.Vec.unop</a></code></pre><div class="info ">
<code class="code">reci ?n ?ofsy ?incy ?y ?ofsx ?incx x</code> computes the reciprocal value
      of <code class="code">n</code> elements of the vector <code class="code">x</code> using <code class="code">incx</code> as incremental steps.
      If <code class="code">y</code> is given, the result will be stored in there using increments of
      <code class="code">incy</code>, otherwise a fresh vector will be used.  The resulting vector
      is returned.<br>
</div>
<br>
<h6 id="6_Operationsontwovectors">Operations on two vectors</h6><br>

<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type"><a href="Lacaml_complex32.Types.Vec.html#TYPEbinop">Lacaml_complex32.Types.Vec.binop</a></code></pre><div class="info ">
<code class="code">add ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> adds <code class="code">n</code>
      elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
      as incremental steps respectively. If <code class="code">z</code> is given, the result will
      be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
      vector will be used. The resulting vector is returned.<br>
</div>

<pre><span id="VALsub"><span class="keyword">val</span> sub</span> : <code class="type"><a href="Lacaml_complex32.Types.Vec.html#TYPEbinop">Lacaml_complex32.Types.Vec.binop</a></code></pre><div class="info ">
<code class="code">sub ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> subtracts <code class="code">n</code>
      elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
      as incremental steps respectively. If <code class="code">z</code> is given, the result will
      be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
      vector will be used. The resulting vector is returned.<br>
</div>

<pre><span id="VALmul"><span class="keyword">val</span> mul</span> : <code class="type"><a href="Lacaml_complex32.Types.Vec.html#TYPEbinop">Lacaml_complex32.Types.Vec.binop</a></code></pre><div class="info ">
<code class="code">mul ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies
      <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code>
      and <code class="code">incy</code> as incremental steps respectively. If <code class="code">z</code> is given, the
      result will be stored in there using increments of <code class="code">incz</code>, otherwise
      a fresh vector will be used. The resulting vector is returned.<br>
</div>

<pre><span id="VALdiv"><span class="keyword">val</span> div</span> : <code class="type"><a href="Lacaml_complex32.Types.Vec.html#TYPEbinop">Lacaml_complex32.Types.Vec.binop</a></code></pre><div class="info ">
<code class="code">div ?n ?ofsz ?incz ?z ?ofsx ?incx x ?ofsy ?incy y</code> divides <code class="code">n</code>
      elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
      as incremental steps respectively. If <code class="code">z</code> is given, the result will
      be stored in there using increments of <code class="code">incz</code>, otherwise a fresh
      vector will be used. The resulting vector is returned.<br>
</div>

<pre><span id="VALzpxy"><span class="keyword">val</span> zpxy</span> : <code class="type">?n:int -><br>       ?ofsz:int -><br>       ?incz:int -><br>       <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       ?ofsx:int -><br>       ?incx:int -><br>       <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       ?ofsy:int -> ?incy:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> unit</code></pre><div class="info ">
<code class="code">zpxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code class="code">n</code>
      elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
      as incremental steps respectively, and adds the result to and stores it
      in the specified range in <code class="code">z</code>.  This function is useful for convolutions.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsz</code> : default = 1</div>
<div class="param_info"><code class="code">incz</code> : default = 1</div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>
<div class="param_info"><code class="code">ofsy</code> : default = 1</div>
<div class="param_info"><code class="code">incy</code> : default = 1</div>

<pre><span id="VALzmxy"><span class="keyword">val</span> zmxy</span> : <code class="type">?n:int -><br>       ?ofsz:int -><br>       ?incz:int -><br>       <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       ?ofsx:int -><br>       ?incx:int -><br>       <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       ?ofsy:int -> ?incy:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> unit</code></pre><div class="info ">
<code class="code">zmxy ?n ?ofsz ?incz z ?ofsx ?incx x ?ofsy ?incy y</code> multiplies <code class="code">n</code>
      elements of vectors <code class="code">x</code> and <code class="code">y</code> elementwise, using <code class="code">incx</code> and <code class="code">incy</code>
      as incremental steps respectively, and substracts the result from
      and stores it in the specified range in <code class="code">z</code>.  This function is
      useful for convolutions.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsz</code> : default = 1</div>
<div class="param_info"><code class="code">incz</code> : default = 1</div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>
<div class="param_info"><code class="code">ofsy</code> : default = 1</div>
<div class="param_info"><code class="code">incy</code> : default = 1</div>

<pre><span id="VALssqr_diff"><span class="keyword">val</span> ssqr_diff</span> : <code class="type">?n:int -><br>       ?ofsx:int -><br>       ?incx:int -><br>       <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -><br>       ?ofsy:int -> ?incy:int -> <a href="Lacaml_complex32.html#TYPEvec">Lacaml_complex32.vec</a> -> <a href="Lacaml_complex32.html#TYPEnum_type">Lacaml_complex32.num_type</a></code></pre><div class="info ">
<code class="code">ssqr_diff ?n ?ofsx ?incx x ?ofsy ?incy y</code> returns the sum of
      squared differences of <code class="code">n</code> elements of vectors <code class="code">x</code> and <code class="code">y</code>, using
      <code class="code">incx</code> and <code class="code">incy</code> as incremental steps respectively.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>
<div class="param_info"><code class="code">ofsy</code> : default = 1</div>
<div class="param_info"><code class="code">incy</code> : default = 1</div>
</body></html>