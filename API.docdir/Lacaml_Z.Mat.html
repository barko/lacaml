<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Lacaml_Z.Vec.html">
<link rel="Up" href="Lacaml_Z.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Lacaml" rel="Chapter" href="Lacaml.html">
<link title="Lacaml_common" rel="Chapter" href="Lacaml_common.html">
<link title="Lacaml_io" rel="Chapter" href="Lacaml_io.html">
<link title="Lacaml_S" rel="Chapter" href="Lacaml_S.html">
<link title="Lacaml_D" rel="Chapter" href="Lacaml_D.html">
<link title="Lacaml_C" rel="Chapter" href="Lacaml_C.html">
<link title="Lacaml_Z" rel="Chapter" href="Lacaml_Z.html">
<link title="Lacaml_utils" rel="Chapter" href="Lacaml_utils.html">
<link title="Lacaml_version" rel="Chapter" href="Lacaml_version.html">
<link title="Lacaml_float32" rel="Chapter" href="Lacaml_float32.html">
<link title="Lacaml_float64" rel="Chapter" href="Lacaml_float64.html">
<link title="Lacaml_complex32" rel="Chapter" href="Lacaml_complex32.html">
<link title="Lacaml_complex64" rel="Chapter" href="Lacaml_complex64.html"><link title="Matrix operations" rel="Section" href="#5_Matrixoperations">
<link title="Creation of matrices" rel="Subsection" href="#6_Creationofmatrices">
<link title="Creation of matrices and accessors" rel="Subsection" href="#6_Creationofmatricesandaccessors">
<link title="Matrix transformations" rel="Subsection" href="#6_Matrixtransformations">
<link title="Operations on one matrix" rel="Subsection" href="#6_Operationsononematrix">
<link title="Operations on two matrices" rel="Subsection" href="#6_Operationsontwomatrices">
<link title="Iterators over matrices" rel="Subsection" href="#6_Iteratorsovermatrices">
<title>Lacaml_Z.Mat</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Lacaml_Z.Vec.html" title="Lacaml_Z.Vec">Previous</a>
&nbsp;<a class="up" href="Lacaml_Z.html" title="Lacaml_Z">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Lacaml_Z.Mat.html">Lacaml_Z.Mat</a></h1>

<pre><span class="keyword">module</span> Mat: <code class="code">sig</code> <a href="Lacaml_Z.Mat.html">..</a> <code class="code">end</code></pre><hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type"><a href="Lacaml_Z.html#TYPEmat">Lacaml_Z.mat</a></code> </pre>

<br>
<h5 id="5_Matrixoperations">Matrix operations</h5><br>
<br>
<h6 id="6_Creationofmatrices">Creation of matrices</h6><br>

<pre><span id="VALrandom"><span class="keyword">val</span> random</span> : <code class="type">?rnd_state:Random.State.t -><br>       ?re_from:float -><br>       ?re_range:float -><br>       ?im_from:float -> ?im_range:float -> int -> int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">random ?rnd_state ?re_from ?re_range ?im_from ?im_range m n</code><br>
<b>Returns</b> an <code class="code">m</code>x<code class="code">n</code> matrix initialized with random elements sampled
      uniformly from <code class="code">re_range</code> and <code class="code">im_range</code> starting at <code class="code">re_from</code> and
      <code class="code">im_from</code> for real and imaginary numbers respectively.  A random state
      <code class="code">rnd_state</code> can be passed.<br>
</div>
<div class="param_info"><code class="code">rnd_state</code> : default = Random.get_state ()</div>
<div class="param_info"><code class="code">re_from</code> : default = -1.0</div>
<div class="param_info"><code class="code">re_range</code> : default = 2.0</div>
<div class="param_info"><code class="code">im_from</code> : default = -1.0</div>
<div class="param_info"><code class="code">im_range</code> : default = 2.0</div>
<br>
<h6 id="6_Creationofmatricesandaccessors">Creation of matrices and accessors</h6><br>

<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">int -> int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">create m n</code><br>
<b>Returns</b> a matrix containing <code class="code">m</code> rows and <code class="code">n</code> columns.<br>
</div>

<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">int -> int -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">make m n x</code><br>
<b>Returns</b> a matrix containing <code class="code">m</code> rows and <code class="code">n</code> columns
      initialized with value <code class="code">x</code>.<br>
</div>

<pre><span id="VALmake0"><span class="keyword">val</span> make0</span> : <code class="type">int -> int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">make0 m n x</code><br>
<b>Returns</b> a matrix containing <code class="code">m</code> rows and <code class="code">n</code> columns
      initialized with the zero element.<br>
</div>

<pre><span id="VALof_array"><span class="keyword">val</span> of_array</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> array array -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">of_array ar</code><br>
<b>Returns</b> a matrix initialized from the array of arrays
      <code class="code">ar</code>.  It is assumed that the OCaml matrix is in row major order
      (standard).<br>
</div>

<pre><span id="VALto_array"><span class="keyword">val</span> to_array</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> array array</code></pre><div class="info ">
<code class="code">to_array mat</code><br>
<b>Returns</b> an array of arrays initialized from matrix
      <code class="code">mat</code>.<br>
</div>

<pre><span id="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> list list -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">of_list ls</code><br>
<b>Returns</b> a matrix initialized from the list of lists
      <code class="code">ls</code>.  Each sublist of <code class="code">ls</code> represents a row of the desired matrix,
      and must be of the same length.<br>
</div>

<pre><span id="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> list list</code></pre><div class="info ">
<code class="code">to_array mat</code><br>
<b>Returns</b> <code class="code">mat</code> in row major order as lists.<br>
</div>

<pre><span id="VALof_col_vecs"><span class="keyword">val</span> of_col_vecs</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> array -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">of_col_vecs ar</code><br>
<b>Returns</b> a matrix whose columns are initialized from
      the array of vectors <code class="code">ar</code>.  The vectors must be of same length.<br>
</div>

<pre><span id="VALto_col_vecs"><span class="keyword">val</span> to_col_vecs</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> array</code></pre><div class="info ">
<code class="code">to_col_vecs mat</code><br>
<b>Returns</b> an array of column vectors initialized
      from matrix <code class="code">mat</code>.<br>
</div>

<pre><span id="VALof_col_vecs_list"><span class="keyword">val</span> of_col_vecs_list</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> list -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">of_col_vecs_list ar</code><br>
<b>Returns</b> a matrix whose columns are initialized from
      the list of vectors <code class="code">ar</code>. The vectors must be of same length.<br>
</div>

<pre><span id="VALto_col_vecs_list"><span class="keyword">val</span> to_col_vecs_list</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> list</code></pre><div class="info ">
<code class="code">to_col_vecs_list mat</code><br>
<b>Returns</b> a list of column vectors initialized
      from matrix <code class="code">mat</code>.<br>
</div>

<pre><span id="VALas_vec"><span class="keyword">val</span> as_vec</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a></code></pre><div class="info ">
<code class="code">as_vec mat</code><br>
<b>Returns</b> a vector containing all elements of the
      matrix in column-major order.  The data is shared.<br>
</div>

<pre><span id="VALinit_rows"><span class="keyword">val</span> init_rows</span> : <code class="type">int -><br>       int -> (int -> int -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a>) -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">init_cols m n f</code><br>
<b>Returns</b> a matrix containing <code class="code">m</code> rows and <code class="code">n</code>
      columns, where each element at <code class="code">row</code> and <code class="code">col</code> is initialized by the
      result of calling <code class="code">f row col</code>. The elements are passed row-wise.<br>
</div>

<pre><span id="VALinit_cols"><span class="keyword">val</span> init_cols</span> : <code class="type">int -><br>       int -> (int -> int -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a>) -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">init_cols m n f</code><br>
<b>Returns</b> a matrix containing <code class="code">m</code> rows and <code class="code">n</code>
      columns, where each element at <code class="code">row</code> and <code class="code">col</code> is initialized by the
      result of calling <code class="code">f row col</code>. The elements are passed column-wise.<br>
</div>

<pre><span id="VALcreate_mvec"><span class="keyword">val</span> create_mvec</span> : <code class="type">int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">create_mvec m</code><br>
<b>Returns</b> a matrix with one column containing <code class="code">m</code> rows.<br>
</div>

<pre><span id="VALmake_mvec"><span class="keyword">val</span> make_mvec</span> : <code class="type">int -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">make_mvec m x</code><br>
<b>Returns</b> a matrix with one column containing <code class="code">m</code> rows
      initialized with value <code class="code">x</code>.<br>
</div>

<pre><span id="VALmvec_of_array"><span class="keyword">val</span> mvec_of_array</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> array -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">mvec_of_array ar</code><br>
<b>Returns</b> a matrix with one column
      initialized with values from array <code class="code">ar</code>.<br>
</div>

<pre><span id="VALmvec_to_array"><span class="keyword">val</span> mvec_to_array</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> array</code></pre><div class="info ">
<code class="code">mvec_to_array mat</code><br>
<b>Returns</b> an array initialized with values from
      the first (not necessarily only) column vector of matrix <code class="code">mat</code>.<br>
</div>

<pre><span id="VALfrom_col_vec"><span class="keyword">val</span> from_col_vec</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">from_col_vec v</code><br>
<b>Returns</b> a matrix with one column representing vector <code class="code">v</code>.
      The data is shared.<br>
</div>

<pre><span id="VALfrom_row_vec"><span class="keyword">val</span> from_row_vec</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">from_row_vec v</code><br>
<b>Returns</b> a matrix with one row representing vector <code class="code">v</code>.
      The data is shared.<br>
</div>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">empty</code>, the empty matrix.<br>
</div>

<pre><span id="VALidentity"><span class="keyword">val</span> identity</span> : <code class="type">int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">identity n</code><br>
<b>Returns</b> the <code class="code">n</code>x<code class="code">n</code> identity matrix.<br>
</div>

<pre><span id="VALof_diag"><span class="keyword">val</span> of_diag</span> : <code class="type">?n:int -><br>       ?br:int -><br>       ?bc:int -><br>       ?b:<a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -><br>       ?ofsx:int -> ?incx:int -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">of_diag ?n ?br ?bc ?b ?ofsx ?incx x</code><br>
<b>Returns</b> matrix <code class="code">b</code> with diagonal
      elements in the designated sub-matrix coming from the designated sub-vector
      in <code class="code">x</code>.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greater <code class="code">n</code> s.t. <code class="code">ofsx+(n-1)(abs incx) &lt;= dim x</code></div>
<div class="param_info"><code class="code">br</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">bc</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">b</code> : default = minimal fresh matrix consistent with <code class="code">n</code>, <code class="code">br</code>, and <code class="code">bc</code></div>
<div class="param_info"><code class="code">ofsx</code> : default = 1</div>
<div class="param_info"><code class="code">incx</code> : default = 1</div>

<pre><span id="VALdim1"><span class="keyword">val</span> dim1</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> int</code></pre><div class="info ">
<code class="code">dim1 m</code><br>
<b>Returns</b> the first dimension of matrix <code class="code">m</code> (number of rows).<br>
</div>

<pre><span id="VALdim2"><span class="keyword">val</span> dim2</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> int</code></pre><div class="info ">
<code class="code">dim2 m</code><br>
<b>Returns</b> the second dimension of matrix <code class="code">m</code> (number of columns).<br>
</div>

<pre><span id="VALcol"><span class="keyword">val</span> col</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> int -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a></code></pre><div class="info ">
<code class="code">col m n</code><br>
<b>Returns</b> the <code class="code">n</code>th column of matrix <code class="code">m</code> as a vector.
      The data is shared.<br>
</div>

<pre><span id="VALcopy_row"><span class="keyword">val</span> copy_row</span> : <code class="type">?vec:<a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -><br>       <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> int -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a></code></pre><div class="info ">
<code class="code">copy_row ?vec mat int</code><br>
<b>Returns</b> a copy of the <code class="code">n</code>th row of matrix <code class="code">m</code>
      in vector <code class="code">vec</code>.<br>
</div>
<div class="param_info"><code class="code">vec</code> : default = fresh vector of length <code class="code">dim2 mat</code></div>
<br>
<h6 id="6_Matrixtransformations">Matrix transformations</h6><br>

<pre><span id="VALswap"><span class="keyword">val</span> swap</span> : <code class="type">?uplo:[ `L | `U ] -><br>       ?m:int -><br>       ?n:int -><br>       ?ar:int -><br>       ?ac:int -><br>       <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> ?br:int -> ?bc:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> unit</code></pre><div class="info ">
<code class="code">swap ?m ?n ?ar ?ac a ?br ?bc b</code> swaps the contents of (sub-matrices)
        <code class="code">a</code> and <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">m</code> : default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">br</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">bc</code> : default = <code class="code">1</code></div>

<pre><span id="VALtranspose_copy"><span class="keyword">val</span> transpose_copy</span> : <code class="type"><a href="Lacaml_complex64.Types.Mat.html#TYPEunop">Lacaml_complex64.Types.Mat.unop</a></code></pre><div class="info ">
<code class="code">transpose_copy ?m ?n ?br ?bc ?b ?ar ?ac a</code><br>
<b>Returns</b> the transpose of
      (sub-)matrix <code class="code">a</code>.  If <code class="code">b</code> is given, the result will be stored in there
      using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh matrix will be used.
      NOTE: this operations does _not_ support in-place transposes!<br>
</div>

<pre><span id="VALdetri"><span class="keyword">val</span> detri</span> : <code class="type">?up:bool -> ?n:int -> ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> unit</code></pre><div class="info ">
<code class="code">detri ?up ?n ?ar ?ac a</code> takes a triangular (sub-)matrix <code class="code">a</code>, i.e. one
      where only the upper (iff <code class="code">up</code> is true) or lower triangle is defined,
      and makes it a symmetric matrix by mirroring the defined triangle
      along the diagonal.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">n</code> : default = <code class="code">Mat.dim1 a</code></div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>

<pre><span id="VALpacked"><span class="keyword">val</span> packed</span> : <code class="type">?up:bool -><br>       ?n:int -> ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a></code></pre><div class="info ">
<code class="code">packed ?up ?n ?ar ?ac a</code><br>
<b>Returns</b> (sub-)matrix <code class="code">a</code> in packed
      storage format.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">n</code> : default = <code class="code">Mat.dim2 a</code></div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>

<pre><span id="VALunpacked"><span class="keyword">val</span> unpacked</span> : <code class="type">?up:bool -> ?n:int -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">unpacked ?up x</code><br>
<b>Returns</b> an upper or lower (depending on <code class="code">up</code>)
      triangular matrix from packed representation <code class="code">vec</code>.  The other
      triangle of the matrix will be filled with zeros.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">n</code> : default = <code class="code">Vec.dim x</code></div>
<br>
<h6 id="6_Operationsononematrix">Operations on one matrix</h6><br>

<pre><span id="VALfill"><span class="keyword">val</span> fill</span> : <code class="type">?m:int -><br>       ?n:int -><br>       ?ar:int -><br>       ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -> unit</code></pre><div class="info ">
<code class="code">fill ?m ?n ?ar ?ac a x</code> fills the specified sub-matrix in <code class="code">a</code> with value
      <code class="code">x</code>.<br>
</div>

<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type">?m:int -><br>       ?n:int -><br>       ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a></code></pre><div class="info ">
<code class="code">sum ?m ?n ?ar ?ac a</code> computes the sum of all elements in
      the <code class="code">m</code>-by-<code class="code">n</code> submatrix starting at row <code class="code">ar</code> and column <code class="code">ac</code>.<br>
</div>

<pre><span id="VALadd_const"><span class="keyword">val</span> add_const</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -> <a href="Lacaml_complex64.Types.Mat.html#TYPEunop">Lacaml_complex64.Types.Mat.unop</a></code></pre><div class="info ">
<code class="code">add_const c ?m ?n ?br ?bc ?b ?ar ?ac a</code> adds constant <code class="code">c</code> to the
      designated <code class="code">m</code> by <code class="code">n</code> submatrix in <code class="code">a</code> and stores the result in the
      designated submatrix in <code class="code">b</code>.<br>
</div>

<pre><span id="VALneg"><span class="keyword">val</span> neg</span> : <code class="type"><a href="Lacaml_complex64.Types.Mat.html#TYPEunop">Lacaml_complex64.Types.Mat.unop</a></code></pre><div class="info ">
<code class="code">neg ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the negative of the elements in
      the <code class="code">m</code> by <code class="code">n</code> (sub-)matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code>
      and column <code class="code">ac</code>.  If <code class="code">b</code> is given, the result will be stored in there
      using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh matrix will be used.
      The resulting matrix is returned.<br>
</div>

<pre><span id="VALreci"><span class="keyword">val</span> reci</span> : <code class="type"><a href="Lacaml_complex64.Types.Mat.html#TYPEunop">Lacaml_complex64.Types.Mat.unop</a></code></pre><div class="info ">
<code class="code">reci ?m ?n ?br ?bc ?b ?ar ?ac a</code> computes the reciprocal of the elements in
      the <code class="code">m</code> by <code class="code">n</code> (sub-)matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code>
      and column <code class="code">ac</code>.  If <code class="code">b</code> is given, the result will be stored in there
      using offsets <code class="code">br</code> and <code class="code">bc</code>, otherwise a fresh matrix will be used.
      The resulting matrix is returned.<br>
</div>

<pre><span id="VALcopy_diag"><span class="keyword">val</span> copy_diag</span> : <code class="type">?n:int -><br>       ?ofsy:int -><br>       ?incy:int -><br>       ?y:<a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -><br>       ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a></code></pre><div class="info ">
<code class="code">copy_diag ?n ?ofsy ?incy ?y ?ar ?ac a</code><br>
<b>Returns</b> the diagonal of the
      (sub-)matrix <code class="code">a</code> in a (sub-)vector.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = greatest <code class="code">n</code> that does not exceed matrix dimensions</div>
<div class="param_info"><code class="code">ofsy</code> : default = 1</div>
<div class="param_info"><code class="code">incy</code> : default = 1</div>
<div class="param_info"><code class="code">y</code> : default = fresh vector of length <code class="code">n</code></div>
<div class="param_info"><code class="code">ar</code> : default = 1</div>
<div class="param_info"><code class="code">ac</code> : default = 1</div>

<pre><span id="VALtrace"><span class="keyword">val</span> trace</span> : <code class="type"><a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a></code></pre><div class="info ">
<code class="code">trace m</code><br>
<b>Returns</b> the trace of matrix <code class="code">m</code>.  If <code class="code">m</code> is not a
      square matrix, the sum of the longest possible sequence of
      diagonal elements will be returned.<br>
</div>

<pre><span id="VALscal"><span class="keyword">val</span> scal</span> : <code class="type">?m:int -><br>       ?n:int -><br>       <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -><br>       ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> unit</code></pre><div class="info ">
<code class="code">scal ?m ?n alpha ?ar ?ac a</code> BLAS <code class="code">scal</code> function for (sub-)matrices.<br>
</div>

<pre><span id="VALscal_cols"><span class="keyword">val</span> scal_cols</span> : <code class="type">?m:int -><br>       ?n:int -><br>       ?ar:int -><br>       ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> ?ofs:int -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -> unit</code></pre><div class="info ">
<code class="code">scal_cols ?m ?n ?ar ?ac a ?ofs alphas</code> column-wise <code class="code">scal</code>
      function for matrices.<br>
</div>

<pre><span id="VALscal_rows"><span class="keyword">val</span> scal_rows</span> : <code class="type">?m:int -><br>       ?n:int -><br>       ?ofs:int -><br>       <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -> ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> unit</code></pre><div class="info ">
<code class="code">scal_rows ?m ?n ?ofs alphas ?ar ?ac a</code> row-wise <code class="code">scal</code>
      function for matrices.<br>
</div>

<pre><span id="VALsyrk_trace"><span class="keyword">val</span> syrk_trace</span> : <code class="type">?n:int -><br>       ?k:int -><br>       ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a></code></pre><div class="info ">
<code class="code">syrk_trace ?n ?k ?ar ?ac a</code> computes the trace of either <code class="code">a' * a</code>
      or <code class="code">a * a'</code>, whichever is more efficient (results are identical), of the
      (sub-)matrix <code class="code">a</code> multiplied by its own transpose.  This is the same as
      the square of the Frobenius norm of a matrix.  <code class="code">n</code> is the number of rows
      to consider in <code class="code">a</code>, and <code class="code">k</code> the number of columns to consider.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = number of rows of <code class="code">a</code></div>
<div class="param_info"><code class="code">k</code> : default = number of columns of <code class="code">a</code></div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>

<pre><span id="VALsyrk_diag"><span class="keyword">val</span> syrk_diag</span> : <code class="type">?n:int -><br>       ?k:int -><br>       ?beta:<a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -><br>       ?ofsy:int -><br>       ?y:<a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -><br>       ?trans:<a href="Lacaml_common.html#TYPEtrans2">Lacaml_common.trans2</a> -><br>       ?alpha:<a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -><br>       ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a></code></pre><div class="info ">
<code class="code">syrk_diag ?n ?k ?beta ?ofsy ?y ?trans ?alpha ?ar ?ac a</code>
      computes the diagonal of the symmetric rank-k product of the
      (sub-)matrix <code class="code">a</code>, multiplying it with <code class="code">alpha</code> and adding <code class="code">beta</code>
      times <code class="code">y</code>, storing the result in <code class="code">y</code> starting at the specified
      offset.  <code class="code">n</code> elements of the diagonal will be computed, and <code class="code">k</code>
      elements of the matrix will be part of the dot product associated
      with each diagonal element.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = number of rows of <code class="code">a</code> (or tr<code class="code">a</code>)</div>
<div class="param_info"><code class="code">k</code> : default = number of columns of <code class="code">a</code> (or tr<code class="code">a</code>)</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0</code></div>
<div class="param_info"><code class="code">ofsy</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">y</code> : default = fresh vector of size <code class="code">n + ofsy - 1</code></div>
<div class="param_info"><code class="code">trans</code> : default = <code class="code">`N</code></div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>
<br>
<h6 id="6_Operationsontwomatrices">Operations on two matrices</h6><br>

<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type"><a href="Lacaml_complex64.Types.Mat.html#TYPEbinop">Lacaml_complex64.Types.Mat.binop</a></code></pre><div class="info ">
<code class="code">add ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the sum of the <code class="code">m</code>
      by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code>
      with the corresponding sub-matrix of the matrix <code class="code">b</code> starting in row
      <code class="code">br</code> and column <code class="code">bc</code>.  If <code class="code">c</code> is given, the result will be stored in
      there starting in row <code class="code">cr</code> and column <code class="code">cc</code>, otherwise a fresh matrix
      will be used.  The resulting matrix is returned.<br>
</div>

<pre><span id="VALsub"><span class="keyword">val</span> sub</span> : <code class="type"><a href="Lacaml_complex64.Types.Mat.html#TYPEbinop">Lacaml_complex64.Types.Mat.binop</a></code></pre><div class="info ">
<code class="code">sub ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the difference of the
      <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column
      <code class="code">ac</code> with the corresponding sub-matrix of the matrix <code class="code">b</code> starting in row
      <code class="code">br</code> and column <code class="code">bc</code>.  If <code class="code">c</code> is given, the result will be stored in
      there starting in row <code class="code">cr</code> and column <code class="code">cc</code>, otherwise a fresh matrix
      will be used.  The resulting matrix is returned.<br>
</div>

<pre><span id="VALmul"><span class="keyword">val</span> mul</span> : <code class="type"><a href="Lacaml_complex64.Types.Mat.html#TYPEbinop">Lacaml_complex64.Types.Mat.binop</a></code></pre><div class="info ">
<code class="code">mul ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the element-wise
      product of the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row
      <code class="code">ar</code> and column <code class="code">ac</code> with the corresponding sub-matrix of the matrix
      <code class="code">b</code> starting in row <code class="code">br</code> and column <code class="code">bc</code>.  If <code class="code">c</code> is given, the result
      will be stored in there starting in row <code class="code">cr</code> and column <code class="code">cc</code>, otherwise
      a fresh matrix will be used.  The resulting matrix is returned.
<p>

      NOTE: please do not confuse this function with matrix multiplication!
      The LAPACK-function for matrix multiplication is called <code class="code">gemm</code>,
      e.g. <code class="code">Lacaml.D.gemm</code>.<br>
</div>

<pre><span id="VALdiv"><span class="keyword">val</span> div</span> : <code class="type"><a href="Lacaml_complex64.Types.Mat.html#TYPEbinop">Lacaml_complex64.Types.Mat.binop</a></code></pre><div class="info ">
<code class="code">div ?m ?n ?cr ?cc ?c ?ar ?ac a ?br ?bc b</code> computes the division of the
      <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix <code class="code">a</code> starting in row <code class="code">ar</code> and column
      <code class="code">ac</code> with the corresponding sub-matrix of the matrix <code class="code">b</code> starting in row
      <code class="code">br</code> and column <code class="code">bc</code>.  If <code class="code">c</code> is given, the result will be stored in
      there starting in row <code class="code">cr</code> and column <code class="code">cc</code>, otherwise a fresh matrix
      will be used.  The resulting matrix is returned.<br>
</div>

<pre><span id="VALaxpy"><span class="keyword">val</span> axpy</span> : <code class="type">?alpha:<a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -><br>       ?m:int -><br>       ?n:int -><br>       ?xr:int -><br>       ?xc:int -><br>       <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> ?yr:int -> ?yc:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> unit</code></pre><div class="info ">
<code class="code">axpy ?alpha ?m ?n ?xr ?xc x ?yr ?yc y</code> BLAS <code class="code">axpy</code> function for
      matrices.<br>
</div>

<pre><span id="VALgemm_diag"><span class="keyword">val</span> gemm_diag</span> : <code class="type">?n:int -><br>       ?k:int -><br>       ?beta:<a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -><br>       ?ofsy:int -><br>       ?y:<a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -><br>       ?transa:<a href="Lacaml_complex64.html#TYPEtrans3">Lacaml_complex64.trans3</a> -><br>       ?alpha:<a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -><br>       ?ar:int -><br>       ?ac:int -><br>       <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -><br>       ?transb:<a href="Lacaml_complex64.html#TYPEtrans3">Lacaml_complex64.trans3</a> -><br>       ?br:int -> ?bc:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a></code></pre><div class="info ">
<code class="code">gemm_diag ?n ?k ?beta ?ofsy ?y ?transa ?transb ?alpha ?ar ?ac a ?br ?bc b</code>
      computes the diagonal of the product of the (sub-)matrices <code class="code">a</code>
      and <code class="code">b</code> (taking into account potential transposing), multiplying
      it with <code class="code">alpha</code> and adding <code class="code">beta</code> times <code class="code">y</code>, storing the result in
      <code class="code">y</code> starting at the specified offset.  <code class="code">n</code> elements of the diagonal
      will be computed, and <code class="code">k</code> elements of the matrices will be part of
      the dot product associated with each diagonal element.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = number of rows of <code class="code">a</code> (or tr <code class="code">a</code>) and
                         number of columns of <code class="code">b</code> (or tr <code class="code">b</code>)</div>
<div class="param_info"><code class="code">k</code> : default = number of columns of <code class="code">a</code> (or tr <code class="code">a</code>) and
                         number of rows of <code class="code">b</code> (or tr <code class="code">b</code>)</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0</code></div>
<div class="param_info"><code class="code">ofsy</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">y</code> : default = fresh vector of size <code class="code">n + ofsy - 1</code></div>
<div class="param_info"><code class="code">transa</code> : default = <code class="code">`N</code></div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">transb</code> : default = <code class="code">`N</code></div>
<div class="param_info"><code class="code">br</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">bc</code> : default = <code class="code">1</code></div>

<pre><span id="VALgemm_trace"><span class="keyword">val</span> gemm_trace</span> : <code class="type">?n:int -><br>       ?k:int -><br>       ?transa:<a href="Lacaml_complex64.html#TYPEtrans3">Lacaml_complex64.trans3</a> -><br>       ?ar:int -><br>       ?ac:int -><br>       <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -><br>       ?transb:<a href="Lacaml_complex64.html#TYPEtrans3">Lacaml_complex64.trans3</a> -><br>       ?br:int -> ?bc:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a></code></pre><div class="info ">
<code class="code">gemm_trace ?n ?k ?transa ?ar ?ac a ?transb ?br ?bc b</code> computes
      the trace of the product of the (sub-)matrices <code class="code">a</code> and <code class="code">b</code> (taking
      into account potential transposing).  When transposing <code class="code">a</code>, this
      yields the so-called Frobenius product of <code class="code">a</code> and <code class="code">b</code>.  <code class="code">n</code> is the
      number of rows (columns) to consider in <code class="code">a</code> and the number of columns
      (rows) in <code class="code">b</code>.  <code class="code">k</code> is the inner dimension to use for the product.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = number of rows of <code class="code">a</code> (or tr <code class="code">a</code>) and
                         number of columns of <code class="code">b</code> (or tr <code class="code">b</code>)</div>
<div class="param_info"><code class="code">k</code> : default = number of columns of <code class="code">a</code> (or tr <code class="code">a</code>) and
                         number of rows of <code class="code">b</code> (or tr <code class="code">b</code>)</div>
<div class="param_info"><code class="code">transa</code> : default = <code class="code">`N</code></div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">transb</code> : default = <code class="code">`N</code></div>
<div class="param_info"><code class="code">br</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">bc</code> : default = <code class="code">1</code></div>

<pre><span id="VALsymm2_trace"><span class="keyword">val</span> symm2_trace</span> : <code class="type">?n:int -><br>       ?upa:bool -><br>       ?ar:int -><br>       ?ac:int -><br>       <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -><br>       ?upb:bool -><br>       ?br:int -> ?bc:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a></code></pre><div class="info ">
<code class="code">symm2_trace ?n ?upa ?ar ?ac a ?upb ?br ?bc b</code> computes the
      trace of the product of the symmetric (sub-)matrices <code class="code">a</code> and
      <code class="code">b</code>.  <code class="code">n</code> is the number of rows and columns to consider in <code class="code">a</code>
      and <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = dimensions of <code class="code">a</code> and <code class="code">b</code></div>
<div class="param_info"><code class="code">upa</code> : default = true (upper triangular portion of <code class="code">a</code> is accessed)</div>
<div class="param_info"><code class="code">ar</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">ac</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">upb</code> : default = true (upper triangular portion of <code class="code">b</code> is accessed)</div>
<div class="param_info"><code class="code">br</code> : default = <code class="code">1</code></div>
<div class="param_info"><code class="code">bc</code> : default = <code class="code">1</code></div>

<pre><span id="VALssqr_diff"><span class="keyword">val</span> ssqr_diff</span> : <code class="type">?m:int -><br>       ?n:int -><br>       ?ar:int -><br>       ?ac:int -><br>       <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -><br>       ?br:int -> ?bc:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a></code></pre><div class="info ">
<code class="code">ssqr_diff ?m ?n ?ar ?ac a ?br ?bc b</code><br>
<b>Returns</b> the sum of squared
      differences between the <code class="code">m</code> by <code class="code">n</code> sub-matrix of the matrix
      <code class="code">a</code> starting in row <code class="code">ar</code> and column <code class="code">ac</code> with the corresponding
      sub-matrix of the matrix <code class="code">b</code> starting in row <code class="code">br</code> and column <code class="code">bc</code>.<br>
</div>
<div class="param_info"><code class="code">m</code> : default = greater n s.t. <code class="code">ar + m - 1 &lt;= dim1 a</code></div>
<div class="param_info"><code class="code">n</code> : default = greater n s.t. <code class="code">ac + n - 1 &lt;= dim2 a</code></div>
<div class="param_info"><code class="code">ar</code> : default = 1</div>
<div class="param_info"><code class="code">ac</code> : default = 1</div>
<div class="param_info"><code class="code">br</code> : default = 1</div>
<div class="param_info"><code class="code">bc</code> : default = 1</div>
<br>
<h6 id="6_Iteratorsovermatrices">Iterators over matrices</h6><br>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(<a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a> -> <a href="Lacaml_complex64.html#TYPEnum_type">Lacaml_complex64.num_type</a>) -><br>       ?m:int -><br>       ?n:int -><br>       ?br:int -><br>       ?bc:int -><br>       ?b:<a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -><br>       ?ar:int -> ?ac:int -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a></code></pre><div class="info ">
<code class="code">map f ?m ?n ?br ?bc ?b ?ar ?ac a</code><br>
<b>Returns</b> matrix with <code class="code">f</code> applied to each element of <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">m</code> : default = number of rows of <code class="code">a</code></div>
<div class="param_info"><code class="code">n</code> : default = number of columns of <code class="code">a</code></div>
<div class="param_info"><code class="code">b</code> : default = fresh matrix of size m by n</div>

<pre><span id="VALfold_cols"><span class="keyword">val</span> fold_cols</span> : <code class="type">('a -> <a href="Lacaml_complex64.html#TYPEvec">Lacaml_complex64.vec</a> -> 'a) -><br>       ?n:int -> ?ac:int -> 'a -> <a href="Lacaml_complex64.html#TYPEmat">Lacaml_complex64.mat</a> -> 'a</code></pre><div class="info ">
<code class="code">fold_cols f ?n ?ac acc a</code><br>
<b>Returns</b> accumulator resulting from folding over each column vector.<br>
</div>
<div class="param_info"><code class="code">n</code> : default = number of columns of <code class="code">a</code></div>
<div class="param_info"><code class="code">ac</code> : default = 1</div>
</body></html>